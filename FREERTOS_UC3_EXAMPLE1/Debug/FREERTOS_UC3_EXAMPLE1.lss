
FREERTOS_UC3_EXAMPLE1.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000043c8  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80006400  80006400  00006800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80006600  80006600  00006a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       0000037c  80006618  80006618  00006a18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .lalign       00000004  80006994  80006994  00006d94  2**0
                  ALLOC
  8 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  9 .ctors        00000008  00000008  80006998  00007008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dtors        00000008  00000010  800069a0  00007010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .jcr          00000004  00000018  800069a8  00007018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .got          00000000  0000001c  800069ac  0000701c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .data         0000051c  0000001c  800069ac  0000701c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .balign       00000000  00000538  80006ec8  00007538  2**0
                  ALLOC
 15 .bss          00000408  00000538  00000538  00000000  2**2
                  ALLOC
 16 .heap         0000e6c0  00000940  00000940  00000000  2**0
                  ALLOC
 17 .comment      00000030  00000000  00000000  00007538  2**0
                  CONTENTS, READONLY
 18 .debug_aranges 00000f08  00000000  00000000  00007568  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_pubnames 000021c7  00000000  00000000  00008470  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_info   00018073  00000000  00000000  0000a637  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_abbrev 00003f91  00000000  00000000  000226aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   000115a2  00000000  00000000  0002663b  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  000027a4  00000000  00000000  00037be0  2**2
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_str    00005f02  00000000  00000000  0003a384  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_loc    000066e0  00000000  00000000  00040286  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_macinfo 020d0c5b  00000000  00000000  00046966  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 28 .debug_ranges 00000e78  00000000  00000000  021175c1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 21 df 	rcall	800063dc <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb b6 9c 	sub	r11,pc,-18788
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 38 	mov	r10,1336
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 09 40 	mov	r10,2368
8000204e:	e0 6c 05 38 	mov	r12,1336
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 10 8a 	rcall	80004170 <_init_startup>
80002060:	fe cc ba 60 	sub	r12,pc,-17824
80002064:	e0 a0 1c bc 	rcall	800059dc <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 1f c5 	rcall	80005ff8 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 03 37 	rcall	800026ec <main>
80002082:	e0 a0 1c b5 	rcall	800059ec <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 38 	mov	r8,1336
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 3c 	mov	r7,1340
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 38 	mov	r8,1336
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <LED_Display>:
  // Use the LED descriptors to get the connections of a given LED to the MCU.
  tLED_DESCRIPTOR *led_descriptor;
  volatile avr32_gpio_port_t *led_gpio_port;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
800020dc:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  LED_State = leds;
800020e0:	49 28       	lddpc	r8,80002128 <LED_Display+0x4c>
800020e2:	91 0c       	st.w	r8[0x0],r12

  // For all LEDs...
  for (led_descriptor = &LED_DESCRIPTOR[0];
800020e4:	49 28       	lddpc	r8,8000212c <LED_Display+0x50>
800020e6:	f0 c9 ff c0 	sub	r9,r8,-64
800020ea:	12 38       	cp.w	r8,r9
800020ec:	5e 2c       	reths	r12
800020ee:	10 9b       	mov	r11,r8
800020f0:	2f c8       	sub	r8,-4
{
  return LED_State;
}


void LED_Display(U32 leds)
800020f2:	2b cb       	sub	r11,-68
  for (led_descriptor = &LED_DESCRIPTOR[0];
       led_descriptor < LED_DESCRIPTOR + LED_COUNT;
       led_descriptor++)
  {
    // Set the LED to the requested state.
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
800020f4:	f0 f9 ff fc 	ld.w	r9,r8[-4]
800020f8:	a9 79       	lsl	r9,0x9
800020fa:	e0 29 e0 00 	sub	r9,57344
    if (leds & 1)
800020fe:	f5 dc c0 01 	bfextu	r10,r12,0x0,0x1
    {
      led_gpio_port->ovrc  = led_descriptor->GPIO.PIN_MASK;
80002102:	f1 fa 10 00 	ld.wne	r10,r8[0x0]
80002106:	f3 fa 1a 16 	st.wne	r9[0x58],r10
    }
    else
    {
      led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
8000210a:	f1 fa 00 00 	ld.weq	r10,r8[0x0]
8000210e:	f3 fa 0a 15 	st.weq	r9[0x54],r10
    }
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80002112:	70 0a       	ld.w	r10,r8[0x0]
80002114:	f3 4a 00 44 	st.w	r9[68],r10
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80002118:	70 0a       	ld.w	r10,r8[0x0]
8000211a:	93 1a       	st.w	r9[0x4],r10
8000211c:	2f 08       	sub	r8,-16

  // Update the saved state of all LEDs with the requested changes.
  LED_State = leds;

  // For all LEDs...
  for (led_descriptor = &LED_DESCRIPTOR[0];
8000211e:	16 38       	cp.w	r8,r11
80002120:	5e 0c       	reteq	r12
    {
      led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
    }
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
    leds >>= 1;
80002122:	a1 9c       	lsr	r12,0x1
80002124:	ce 8b       	rjmp	800020f4 <LED_Display+0x18>
80002126:	00 00       	add	r0,r0
80002128:	00 00       	add	r0,r0
8000212a:	00 1c       	sub	r12,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	66 18       	ld.w	r8,r3[0x4]

80002130 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80002130:	fe 68 00 00 	mov	r8,-131072
80002134:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80002136:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000213a:	91 09       	st.w	r8[0x0],r9
}
8000213c:	5e fc       	retal	r12

8000213e <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
8000213e:	fe 68 00 00 	mov	r8,-131072
80002142:	70 2c       	ld.w	r12,r8[0x8]
}
80002144:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002148:	5e fc       	retal	r12
8000214a:	d7 03       	nop

8000214c <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
8000214c:	d4 01       	pushm	lr
	while (!flashc_is_ready());
8000214e:	f0 1f 00 03 	mcall	80002158 <flashc_default_wait_until_ready+0xc>
80002152:	cf e0       	breq	8000214e <flashc_default_wait_until_ready+0x2>
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	21 3e       	sub	lr,19

8000215c <flashc_issue_command>:
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
8000215c:	eb cd 40 c0 	pushm	r6-r7,lr
80002160:	18 96       	mov	r6,r12
80002162:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80002164:	48 e8       	lddpc	r8,8000219c <flashc_issue_command+0x40>
80002166:	70 08       	ld.w	r8,r8[0x0]
80002168:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000216a:	fe 68 00 00 	mov	r8,-131072
8000216e:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80002170:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
80002174:	58 07       	cp.w	r7,0
80002176:	c0 35       	brlt	8000217c <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
80002178:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
8000217c:	3a 59       	mov	r9,-91
8000217e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80002182:	fe 69 00 00 	mov	r9,-131072
80002186:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80002188:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8000218a:	e2 19 00 0c 	andl	r9,0xc,COH
8000218e:	48 58       	lddpc	r8,800021a0 <flashc_issue_command+0x44>
80002190:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
80002192:	48 38       	lddpc	r8,8000219c <flashc_issue_command+0x40>
80002194:	70 08       	ld.w	r8,r8[0x0]
80002196:	5d 18       	icall	r8
}
80002198:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000219c:	00 00       	add	r0,r0
8000219e:	00 20       	rsub	r0,r0
800021a0:	00 00       	add	r0,r0
800021a2:	05 40       	ld.w	r0,--r2

800021a4 <flashc_set_flash_waitstate_and_readmode>:
}


#if UC3C
void flashc_set_flash_waitstate_and_readmode(unsigned long cpu_f_hz)
{
800021a4:	eb cd 40 80 	pushm	r7,lr
800021a8:	18 97       	mov	r7,r12
	#define AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ      33000000
	#define AVR32_FLASHC_HSEN_FWS_1_MAX_FREQ      72000000
	// These defines are missing from or wrong in the toolchain header files uc3cxxx.h
	// Put a Bugzilla

	if (cpu_f_hz > AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ) { // > 33MHz
800021aa:	e0 68 8a 40 	mov	r8,35392
800021ae:	ea 18 01 f7 	orh	r8,0x1f7
800021b2:	10 3c       	cp.w	r12,r8
800021b4:	e0 88 00 18 	brls	800021e4 <flashc_set_flash_waitstate_and_readmode+0x40>
		// Set a wait-state
		flashc_set_wait_state(1);
800021b8:	30 1c       	mov	r12,1
800021ba:	f0 1f 00 10 	mcall	800021f8 <flashc_set_flash_waitstate_and_readmode+0x54>
		if (cpu_f_hz <= AVR32_FLASHC_FWS_1_MAX_FREQ) {   // <= 66MHz and >33Mhz
800021be:	e0 68 14 80 	mov	r8,5248
800021c2:	ea 18 03 ef 	orh	r8,0x3ef
800021c6:	10 37       	cp.w	r7,r8
800021c8:	e0 8b 00 08 	brhi	800021d8 <flashc_set_flash_waitstate_and_readmode+0x34>
			// Disable the high-speed read mode.
			flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
800021cc:	3f fb       	mov	r11,-1
800021ce:	31 1c       	mov	r12,17
800021d0:	f0 1f 00 0b 	mcall	800021fc <flashc_set_flash_waitstate_and_readmode+0x58>
800021d4:	e3 cd 80 80 	ldm	sp++,r7,pc
		} else { // > 66Mhz
			// Enable the high-speed read mode.
			flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSEN, -1);
800021d8:	3f fb       	mov	r11,-1
800021da:	31 0c       	mov	r12,16
800021dc:	f0 1f 00 08 	mcall	800021fc <flashc_set_flash_waitstate_and_readmode+0x58>
800021e0:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
	} else { // <= 33 MHz
		// Disable wait-state
		flashc_set_wait_state(0);
800021e4:	30 0c       	mov	r12,0
800021e6:	f0 1f 00 05 	mcall	800021f8 <flashc_set_flash_waitstate_and_readmode+0x54>
		// Disable the high-speed read mode.
		flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
800021ea:	3f fb       	mov	r11,-1
800021ec:	31 1c       	mov	r12,17
800021ee:	f0 1f 00 04 	mcall	800021fc <flashc_set_flash_waitstate_and_readmode+0x58>
800021f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f6:	00 00       	add	r0,r0
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	21 30       	sub	r0,19
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	21 5c       	sub	r12,21

80002200 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002200:	f8 08 16 05 	lsr	r8,r12,0x5
80002204:	a9 78       	lsl	r8,0x9
80002206:	e0 28 e0 00 	sub	r8,57344

	/* Enable the correct function. */
	switch (function) {
8000220a:	58 7b       	cp.w	r11,7
8000220c:	e0 8b 00 05 	brhi	80002216 <gpio_enable_module_pin+0x16>
80002210:	4a 09       	lddpc	r9,80002290 <gpio_enable_module_pin+0x90>
80002212:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
80002216:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002218:	30 19       	mov	r9,1
8000221a:	f2 0c 09 49 	lsl	r9,r9,r12
8000221e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002220:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80002222:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80002224:	c3 18       	rjmp	80002286 <gpio_enable_module_pin+0x86>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002226:	30 19       	mov	r9,1
80002228:	f2 0c 09 49 	lsl	r9,r9,r12
8000222c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000222e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80002230:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80002232:	c2 a8       	rjmp	80002286 <gpio_enable_module_pin+0x86>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002234:	30 19       	mov	r9,1
80002236:	f2 0c 09 49 	lsl	r9,r9,r12
8000223a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000223c:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
8000223e:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80002240:	c2 38       	rjmp	80002286 <gpio_enable_module_pin+0x86>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002242:	30 19       	mov	r9,1
80002244:	f2 0c 09 49 	lsl	r9,r9,r12
80002248:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000224a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
8000224c:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
8000224e:	c1 c8       	rjmp	80002286 <gpio_enable_module_pin+0x86>

#if (AVR32_GPIO_H_VERSION >= 210)
	case 4: /* E function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002250:	30 19       	mov	r9,1
80002252:	f2 0c 09 49 	lsl	r9,r9,r12
80002256:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002258:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
8000225a:	91 d9       	st.w	r8[0x34],r9
		break;
8000225c:	c1 58       	rjmp	80002286 <gpio_enable_module_pin+0x86>

	case 5: /* F function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000225e:	30 19       	mov	r9,1
80002260:	f2 0c 09 49 	lsl	r9,r9,r12
80002264:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002266:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80002268:	91 d9       	st.w	r8[0x34],r9
		break;
8000226a:	c0 e8       	rjmp	80002286 <gpio_enable_module_pin+0x86>

	case 6: /* G function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000226c:	30 19       	mov	r9,1
8000226e:	f2 0c 09 49 	lsl	r9,r9,r12
80002272:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002274:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80002276:	91 d9       	st.w	r8[0x34],r9
		break;
80002278:	c0 78       	rjmp	80002286 <gpio_enable_module_pin+0x86>

	case 7: /* H function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000227a:	30 19       	mov	r9,1
8000227c:	f2 0c 09 49 	lsl	r9,r9,r12
80002280:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002282:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80002284:	91 d9       	st.w	r8[0x34],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002286:	30 19       	mov	r9,1
80002288:	f2 0c 09 4c 	lsl	r12,r9,r12
8000228c:	91 2c       	st.w	r8[0x8],r12
8000228e:	5e fd       	retal	0
80002290:	80 00       	ld.sh	r0,r0[0x0]
80002292:	66 58       	ld.w	r8,r3[0x14]

80002294 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002294:	d4 21       	pushm	r4-r7,lr
80002296:	18 97       	mov	r7,r12
80002298:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000229a:	58 0b       	cp.w	r11,0
8000229c:	c0 31       	brne	800022a2 <gpio_enable_module+0xe>
8000229e:	30 05       	mov	r5,0
800022a0:	c0 d8       	rjmp	800022ba <gpio_enable_module+0x26>
800022a2:	30 06       	mov	r6,0
800022a4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800022a6:	6e 1b       	ld.w	r11,r7[0x4]
800022a8:	6e 0c       	ld.w	r12,r7[0x0]
800022aa:	f0 1f 00 06 	mcall	800022c0 <gpio_enable_module+0x2c>
800022ae:	18 45       	or	r5,r12
		gpiomap++;
800022b0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800022b2:	2f f6       	sub	r6,-1
800022b4:	0c 34       	cp.w	r4,r6
800022b6:	fe 9b ff f8 	brhi	800022a6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800022ba:	0a 9c       	mov	r12,r5
800022bc:	d8 22       	popm	r4-r7,pc
800022be:	00 00       	add	r0,r0
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	22 00       	sub	r0,32

800022c4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800022c4:	c0 08       	rjmp	800022c4 <_unhandled_interrupt>
800022c6:	d7 03       	nop

800022c8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800022c8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800022cc:	49 99       	lddpc	r9,80002330 <INTC_register_interrupt+0x68>
800022ce:	f2 08 00 39 	add	r9,r9,r8<<0x3
800022d2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800022d6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800022d8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800022dc:	58 0a       	cp.w	r10,0
800022de:	c0 91       	brne	800022f0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800022e0:	49 59       	lddpc	r9,80002334 <INTC_register_interrupt+0x6c>
800022e2:	49 6a       	lddpc	r10,80002338 <INTC_register_interrupt+0x70>
800022e4:	12 1a       	sub	r10,r9
800022e6:	fe 79 00 00 	mov	r9,-65536
800022ea:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800022ee:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800022f0:	58 1a       	cp.w	r10,1
800022f2:	c0 a1       	brne	80002306 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800022f4:	49 09       	lddpc	r9,80002334 <INTC_register_interrupt+0x6c>
800022f6:	49 2a       	lddpc	r10,8000233c <INTC_register_interrupt+0x74>
800022f8:	12 1a       	sub	r10,r9
800022fa:	bf aa       	sbr	r10,0x1e
800022fc:	fe 79 00 00 	mov	r9,-65536
80002300:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002304:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80002306:	58 2a       	cp.w	r10,2
80002308:	c0 a1       	brne	8000231c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000230a:	48 b9       	lddpc	r9,80002334 <INTC_register_interrupt+0x6c>
8000230c:	48 da       	lddpc	r10,80002340 <INTC_register_interrupt+0x78>
8000230e:	12 1a       	sub	r10,r9
80002310:	bf ba       	sbr	r10,0x1f
80002312:	fe 79 00 00 	mov	r9,-65536
80002316:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000231a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000231c:	48 69       	lddpc	r9,80002334 <INTC_register_interrupt+0x6c>
8000231e:	48 aa       	lddpc	r10,80002344 <INTC_register_interrupt+0x7c>
80002320:	12 1a       	sub	r10,r9
80002322:	ea 1a c0 00 	orh	r10,0xc000
80002326:	fe 79 00 00 	mov	r9,-65536
8000232a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000232e:	5e fc       	retal	r12
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	66 78       	ld.w	r8,r3[0x1c]
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	64 00       	ld.w	r0,r2[0x0]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	65 04       	ld.w	r4,r2[0x40]
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	65 12       	ld.w	r2,r2[0x44]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	65 20       	ld.w	r0,r2[0x48]
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	65 2e       	ld.w	lr,r2[0x48]

80002348 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002348:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000234a:	49 18       	lddpc	r8,8000238c <INTC_init_interrupts+0x44>
8000234c:	e3 b8 00 01 	mtsr	0x4,r8
80002350:	49 0e       	lddpc	lr,80002390 <INTC_init_interrupts+0x48>
80002352:	30 07       	mov	r7,0
80002354:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002356:	49 0c       	lddpc	r12,80002394 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002358:	49 05       	lddpc	r5,80002398 <INTC_init_interrupts+0x50>
8000235a:	10 15       	sub	r5,r8
8000235c:	fe 76 00 00 	mov	r6,-65536
80002360:	c1 18       	rjmp	80002382 <INTC_init_interrupts+0x3a>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002362:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002364:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002366:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002368:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000236c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000236e:	10 3a       	cp.w	r10,r8
80002370:	fe 9b ff fc 	brhi	80002368 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002374:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002378:	2f f7       	sub	r7,-1
8000237a:	2f 8e       	sub	lr,-8
8000237c:	e0 47 00 2f 	cp.w	r7,47
80002380:	c0 50       	breq	8000238a <INTC_init_interrupts+0x42>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002382:	7c 08       	ld.w	r8,lr[0x0]
80002384:	58 08       	cp.w	r8,0
80002386:	ce e1       	brne	80002362 <INTC_init_interrupts+0x1a>
80002388:	cf 6b       	rjmp	80002374 <INTC_init_interrupts+0x2c>
8000238a:	d8 22       	popm	r4-r7,pc
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	64 00       	ld.w	r0,r2[0x0]
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	66 78       	ld.w	r8,r3[0x1c]
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	22 c4       	sub	r4,44
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	65 04       	ld.w	r4,r2[0x40]

8000239c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000239c:	fe 78 00 00 	mov	r8,-65536
800023a0:	e0 69 00 83 	mov	r9,131
800023a4:	f2 0c 01 0c 	sub	r12,r9,r12
800023a8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800023ac:	f2 ca ff c0 	sub	r10,r9,-64
800023b0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800023b4:	58 08       	cp.w	r8,0
800023b6:	c0 21       	brne	800023ba <_get_interrupt_handler+0x1e>
800023b8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
800023ba:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800023be:	48 5a       	lddpc	r10,800023d0 <_get_interrupt_handler+0x34>
800023c0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800023c4:	f0 08 11 1f 	rsub	r8,r8,31
800023c8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800023ca:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800023ce:	5e fc       	retal	r12
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	66 78       	ld.w	r8,r3[0x1c]

800023d4 <pm_set_mclk_source>:
 **/

long pm_set_mclk_source(pm_clk_src_t src)
{
  // Unlock the write-protected MCCTRL register
  AVR32_ENTER_CRITICAL_REGION( );
800023d4:	e1 b9 00 00 	mfsr	r9,0x0
800023d8:	d3 03       	ssrf	0x10
  PM_UNLOCK(AVR32_PM_MCCTRL);
800023da:	fe 78 04 00 	mov	r8,-64512
800023de:	fc 1a aa 00 	movh	r10,0xaa00
800023e2:	f1 4a 00 58 	st.w	r8[88],r10
  AVR32_PM.mcctrl = src;
800023e6:	91 0c       	st.w	r8[0x0],r12
  AVR32_LEAVE_CRITICAL_REGION( );
800023e8:	12 98       	mov	r8,r9
800023ea:	e6 18 00 01 	andh	r8,0x1,COH
800023ee:	c0 21       	brne	800023f2 <pm_set_mclk_source+0x1e>
800023f0:	d5 03       	csrf	0x10

  return PASS;
}
800023f2:	5e fd       	retal	0

800023f4 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3D device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
800023f4:	eb cd 40 c0 	pushm	r6-r7,lr
800023f8:	16 97       	mov	r7,r11
800023fa:	14 96       	mov	r6,r10
#else
// Implementation for UC3C, UC3L parts.
  #if AVR32_PM_VERSION_RESETVALUE < 0x400
    return PCL_NOT_SUPPORTED;
  #else
  if(PCL_OSC0 == osc)
800023fc:	58 0c       	cp.w	r12,0
800023fe:	c0 50       	breq	80002408 <pcl_switch_to_osc+0x14>
80002400:	fe 7c d8 f0 	mov	r12,-10000
80002404:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
  {
    // Configure OSC0 in crystal mode, external crystal with a fcrystal Hz frequency.
    scif_configure_osc_crystalmode(SCIF_OSC0, fcrystal);
80002408:	30 0c       	mov	r12,0
8000240a:	f0 1f 00 08 	mcall	80002428 <pcl_switch_to_osc+0x34>
    // Enable the OSC0
    scif_enable_osc(SCIF_OSC0, startup, true);
8000240e:	30 1a       	mov	r10,1
80002410:	0c 9b       	mov	r11,r6
80002412:	30 0c       	mov	r12,0
80002414:	f0 1f 00 06 	mcall	8000242c <pcl_switch_to_osc+0x38>
    // Set the Flash wait state and the speed read mode (depending on the target CPU frequency).
#if UC3L || UC3D
    flashcdw_set_flash_waitstate_and_readmode(fcrystal);
#elif UC3C
    flashc_set_flash_waitstate_and_readmode(fcrystal);
80002418:	0e 9c       	mov	r12,r7
8000241a:	f0 1f 00 06 	mcall	80002430 <pcl_switch_to_osc+0x3c>
#endif
    // Set the main clock source as being OSC0.
    pm_set_mclk_source(PM_CLK_SRC_OSC0);
8000241e:	30 1c       	mov	r12,1
80002420:	f0 1f 00 05 	mcall	80002434 <pcl_switch_to_osc+0x40>
80002424:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	24 c8       	sub	r8,76
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	24 54       	sub	r4,69
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	21 a4       	sub	r4,26
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	23 d4       	sub	r4,61

80002438 <scif_pclksr_statushigh_wait>:
 * \return Status.
 *   \retval 0   Status is high.
 *   \retval <0  SCIF_POLL_TIMEOUT Timeout expired before the status was high.
 */
static long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
80002438:	e0 78 86 a0 	mov	r8,100000
  unsigned int timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
8000243c:	fe 7a 08 00 	mov	r10,-63488
80002440:	c0 48       	rjmp	80002448 <scif_pclksr_statushigh_wait+0x10>
  {
    if(--timeout == 0)
80002442:	20 18       	sub	r8,1
80002444:	c0 21       	brne	80002448 <scif_pclksr_statushigh_wait+0x10>
80002446:	5e fe       	retal	-1
 */
static long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
80002448:	74 59       	ld.w	r9,r10[0x14]
8000244a:	f9 e9 00 09 	and	r9,r12,r9
8000244e:	cf a0       	breq	80002442 <scif_pclksr_statushigh_wait+0xa>
80002450:	5e fd       	retal	0
80002452:	d7 03       	nop

80002454 <scif_enable_osc>:

  return PASS;
}

long int scif_enable_osc(scif_osc_t osc, unsigned int startup, bool wait_for_ready)
{
80002454:	eb cd 40 80 	pushm	r7,lr
80002458:	20 2d       	sub	sp,8

  u_avr32_scif_oscctrl_t   u_avr32_scif_oscctrl;

  // Read Register
  u_avr32_scif_oscctrl.OSCCTRL[osc] = AVR32_SCIF.OSCCTRL[osc] ;
8000245a:	fa c8 ff f8 	sub	r8,sp,-8
8000245e:	f0 0c 00 2e 	add	lr,r8,r12<<0x2
80002462:	fe 78 08 00 	mov	r8,-63488
80002466:	f8 c9 ff f7 	sub	r9,r12,-9
8000246a:	f0 09 03 27 	ld.w	r7,r8[r9<<0x2]
  // Modify: Configure the oscillator startup and enable the osc.
  u_avr32_scif_oscctrl.OSCCTRL[osc].startup = startup;
8000246e:	ef db d1 04 	bfins	r7,r11,0x8,0x4
  u_avr32_scif_oscctrl.OSCCTRL[osc].oscen = ENABLE;
80002472:	30 1b       	mov	r11,1
80002474:	ef db d2 01 	bfins	r7,r11,0x10,0x1
80002478:	fd 47 ff f8 	st.w	lr[-8],r7
  AVR32_ENTER_CRITICAL_REGION( );
8000247c:	e1 bb 00 00 	mfsr	r11,0x0
80002480:	d3 03       	ssrf	0x10
  // Unlock the write-protected OSCCTRL0 register
  SCIF_UNLOCK(AVR32_SCIF_OSCCTRL + 4*osc);
80002482:	f2 07 15 02 	lsl	r7,r9,0x2
80002486:	ea 17 aa 00 	orh	r7,0xaa00
8000248a:	91 67       	st.w	r8[0x18],r7
  // Write Back
  AVR32_SCIF.OSCCTRL[osc] = u_avr32_scif_oscctrl.OSCCTRL[osc];
8000248c:	fc fe ff f8 	ld.w	lr,lr[-8]
80002490:	f0 09 09 2e 	st.w	r8[r9<<0x2],lr
  AVR32_LEAVE_CRITICAL_REGION( );
80002494:	16 98       	mov	r8,r11
80002496:	e6 18 00 01 	andh	r8,0x1,COH
8000249a:	c0 21       	brne	8000249e <scif_enable_osc+0x4a>
8000249c:	d5 03       	csrf	0x10

  if(true == wait_for_ready)
8000249e:	58 0a       	cp.w	r10,0
800024a0:	c0 e0       	breq	800024bc <scif_enable_osc+0x68>
  {
	  if (osc == SCIF_OSC0) {
800024a2:	58 0c       	cp.w	r12,0
800024a4:	c0 61       	brne	800024b0 <scif_enable_osc+0x5c>
		  // Wait until OSC0 is stable and ready to be used.
		  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_OSC0RDY_MASK))
800024a6:	30 1c       	mov	r12,1
800024a8:	f0 1f 00 07 	mcall	800024c4 <scif_enable_osc+0x70>
800024ac:	c0 80       	breq	800024bc <scif_enable_osc+0x68>
800024ae:	c0 58       	rjmp	800024b8 <scif_enable_osc+0x64>
			return -1;
	  } else {
		  // Wait until OSC1 is stable and ready to be used.
		  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_OSC1RDY_MASK))
800024b0:	30 2c       	mov	r12,2
800024b2:	f0 1f 00 05 	mcall	800024c4 <scif_enable_osc+0x70>
800024b6:	c0 30       	breq	800024bc <scif_enable_osc+0x68>
800024b8:	3f fc       	mov	r12,-1
800024ba:	c0 28       	rjmp	800024be <scif_enable_osc+0x6a>
800024bc:	30 0c       	mov	r12,0
			return -1;
	  }
  }

  return PASS;
}
800024be:	2f ed       	sub	sp,-8
800024c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	24 38       	sub	r8,67

800024c8 <scif_configure_osc_crystalmode>:

long int scif_configure_osc_crystalmode(scif_osc_t osc, unsigned int fcrystal)
{
  u_avr32_scif_oscctrl_t   u_avr32_scif_oscctrl;

  if (osc == SCIF_OSC0)
800024c8:	58 0c       	cp.w	r12,0
800024ca:	c3 41       	brne	80002532 <scif_configure_osc_crystalmode+0x6a>
  {
    // Read Register
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0] = AVR32_SCIF.OSCCTRL[SCIF_OSC0] ;
800024cc:	fe 78 08 00 	mov	r8,-63488
800024d0:	70 98       	ld.w	r8,r8[0x24]
    // Modify : Configure the oscillator mode to crystal and set the gain according to the
    // crystal frequency.
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0].mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0].gain = (fcrystal <  2000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G0 :
800024d2:	e0 69 84 7f 	mov	r9,33919
800024d6:	ea 19 00 1e 	orh	r9,0x1e
800024da:	12 3b       	cp.w	r11,r9
800024dc:	e0 8b 00 04 	brhi	800024e4 <scif_configure_osc_crystalmode+0x1c>
800024e0:	30 0b       	mov	r11,0
800024e2:	c1 38       	rjmp	80002508 <scif_configure_osc_crystalmode+0x40>
800024e4:	e0 69 96 7f 	mov	r9,38527
800024e8:	ea 19 00 98 	orh	r9,0x98
800024ec:	12 3b       	cp.w	r11,r9
800024ee:	e0 8b 00 04 	brhi	800024f6 <scif_configure_osc_crystalmode+0x2e>
800024f2:	30 1b       	mov	r11,1
800024f4:	c0 a8       	rjmp	80002508 <scif_configure_osc_crystalmode+0x40>
800024f6:	e0 69 24 00 	mov	r9,9216
800024fa:	ea 19 00 f4 	orh	r9,0xf4
800024fe:	12 3b       	cp.w	r11,r9
80002500:	f9 bb 03 02 	movlo	r11,2
80002504:	f9 bb 02 03 	movhs	r11,3
  {
    // Read Register
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0] = AVR32_SCIF.OSCCTRL[SCIF_OSC0] ;
    // Modify : Configure the oscillator mode to crystal and set the gain according to the
    // crystal frequency.
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0].mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
80002508:	30 19       	mov	r9,1
8000250a:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0].gain = (fcrystal <  2000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G0 :
8000250e:	f1 db d0 22 	bfins	r8,r11,0x1,0x2
                                                   (fcrystal < 10000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G1 :
                                                   (fcrystal < 16000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G2 :
                                                                           AVR32_SCIF_OSCCTRL0_GAIN_G3;
    AVR32_ENTER_CRITICAL_REGION( );
80002512:	e1 ba 00 00 	mfsr	r10,0x0
80002516:	d3 03       	ssrf	0x10
    // Unlock the write-protected OSCCTRL0 register
    SCIF_UNLOCK(AVR32_SCIF_OSCCTRL);
80002518:	fe 79 08 00 	mov	r9,-63488
8000251c:	32 4b       	mov	r11,36
8000251e:	ea 1b aa 00 	orh	r11,0xaa00
80002522:	93 6b       	st.w	r9[0x18],r11
    // Write Back
    AVR32_SCIF.OSCCTRL[SCIF_OSC0] = u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC0];
80002524:	93 98       	st.w	r9[0x24],r8
    AVR32_LEAVE_CRITICAL_REGION( );
80002526:	14 98       	mov	r8,r10
80002528:	e6 18 00 01 	andh	r8,0x1,COH
8000252c:	c3 51       	brne	80002596 <scif_configure_osc_crystalmode+0xce>
8000252e:	d5 03       	csrf	0x10
80002530:	c3 38       	rjmp	80002596 <scif_configure_osc_crystalmode+0xce>
  }
  else
  {
    // Read Register
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1] = AVR32_SCIF.OSCCTRL[SCIF_OSC1] ;
80002532:	fe 78 08 00 	mov	r8,-63488
80002536:	70 a8       	ld.w	r8,r8[0x28]
    // Modify : Configure the oscillator mode to crystal and set the gain according to the
    // crystal frequency.
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1].mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1].gain = (fcrystal <  2000000) ? AVR32_SCIF_OSCCTRL1_GAIN_G0 :
80002538:	e0 69 84 7f 	mov	r9,33919
8000253c:	ea 19 00 1e 	orh	r9,0x1e
80002540:	12 3b       	cp.w	r11,r9
80002542:	e0 8b 00 04 	brhi	8000254a <scif_configure_osc_crystalmode+0x82>
80002546:	30 0b       	mov	r11,0
80002548:	c1 38       	rjmp	8000256e <scif_configure_osc_crystalmode+0xa6>
8000254a:	e0 69 96 7f 	mov	r9,38527
8000254e:	ea 19 00 98 	orh	r9,0x98
80002552:	12 3b       	cp.w	r11,r9
80002554:	e0 8b 00 04 	brhi	8000255c <scif_configure_osc_crystalmode+0x94>
80002558:	30 1b       	mov	r11,1
8000255a:	c0 a8       	rjmp	8000256e <scif_configure_osc_crystalmode+0xa6>
8000255c:	e0 69 24 00 	mov	r9,9216
80002560:	ea 19 00 f4 	orh	r9,0xf4
80002564:	12 3b       	cp.w	r11,r9
80002566:	f9 bb 03 02 	movlo	r11,2
8000256a:	f9 bb 02 03 	movhs	r11,3
  {
    // Read Register
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1] = AVR32_SCIF.OSCCTRL[SCIF_OSC1] ;
    // Modify : Configure the oscillator mode to crystal and set the gain according to the
    // crystal frequency.
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1].mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
8000256e:	30 19       	mov	r9,1
80002570:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
    u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1].gain = (fcrystal <  2000000) ? AVR32_SCIF_OSCCTRL1_GAIN_G0 :
80002574:	f1 db d0 22 	bfins	r8,r11,0x1,0x2
                                                   (fcrystal < 10000000) ? AVR32_SCIF_OSCCTRL1_GAIN_G1 :
                                                   (fcrystal < 16000000) ? AVR32_SCIF_OSCCTRL1_GAIN_G2 :
                                                                           AVR32_SCIF_OSCCTRL1_GAIN_G3;
    AVR32_ENTER_CRITICAL_REGION( );
80002578:	e1 ba 00 00 	mfsr	r10,0x0
8000257c:	d3 03       	ssrf	0x10
    // Unlock the write-protected OSCCTRL1 register
    SCIF_UNLOCK(AVR32_SCIF_OSCCTRL1);
8000257e:	fe 79 08 00 	mov	r9,-63488
80002582:	32 8b       	mov	r11,40
80002584:	ea 1b aa 00 	orh	r11,0xaa00
80002588:	93 6b       	st.w	r9[0x18],r11
    // Write Back
    AVR32_SCIF.OSCCTRL[SCIF_OSC1] = u_avr32_scif_oscctrl.OSCCTRL[SCIF_OSC1];
8000258a:	93 a8       	st.w	r9[0x28],r8
    AVR32_LEAVE_CRITICAL_REGION( );
8000258c:	14 98       	mov	r8,r10
8000258e:	e6 18 00 01 	andh	r8,0x1,COH
80002592:	c0 21       	brne	80002596 <scif_configure_osc_crystalmode+0xce>
80002594:	d5 03       	csrf	0x10
  }

  return PASS;
}
80002596:	5e fd       	retal	0

80002598 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002598:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000259a:	f6 08 15 04 	lsl	r8,r11,0x4
8000259e:	14 38       	cp.w	r8,r10
800025a0:	f9 b8 08 10 	movls	r8,16
800025a4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800025a8:	f0 0b 02 4b 	mul	r11,r8,r11
800025ac:	f6 09 16 01 	lsr	r9,r11,0x1
800025b0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800025b4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800025b8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800025bc:	f2 cb 00 01 	sub	r11,r9,1
800025c0:	e0 4b ff fe 	cp.w	r11,65534
800025c4:	e0 88 00 03 	brls	800025ca <usart_set_async_baudrate+0x32>
800025c8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800025ca:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800025cc:	e8 6e 00 00 	mov	lr,524288
800025d0:	59 08       	cp.w	r8,16
800025d2:	fc 08 17 10 	movne	r8,lr
800025d6:	f9 b8 00 00 	moveq	r8,0
800025da:	e4 1b ff f7 	andh	r11,0xfff7
800025de:	e0 1b fe cf 	andl	r11,0xfecf
800025e2:	16 48       	or	r8,r11
800025e4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800025e6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800025ea:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800025ee:	99 89       	st.w	r12[0x20],r9
800025f0:	d8 0a       	popm	pc,r12=0

800025f2 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800025f2:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800025f6:	e6 18 00 01 	andh	r8,0x1,COH
800025fa:	c0 71       	brne	80002608 <usart_reset+0x16>
800025fc:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800025fe:	3f f8       	mov	r8,-1
80002600:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002602:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002604:	d5 03       	csrf	0x10
80002606:	c0 48       	rjmp	8000260e <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80002608:	3f f8       	mov	r8,-1
8000260a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000260c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000260e:	30 08       	mov	r8,0
80002610:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80002612:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80002614:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002616:	ea 68 61 0c 	mov	r8,680204
8000261a:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000261c:	5e fc       	retal	r12
8000261e:	d7 03       	nop

80002620 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002620:	eb cd 40 e0 	pushm	r5-r7,lr
80002624:	18 96       	mov	r6,r12
80002626:	16 97       	mov	r7,r11
80002628:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000262a:	f0 1f 00 2f 	mcall	800026e4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000262e:	58 07       	cp.w	r7,0
80002630:	c5 80       	breq	800026e0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80002632:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002634:	30 49       	mov	r9,4
80002636:	f2 08 18 00 	cp.b	r8,r9
8000263a:	e0 88 00 53 	brls	800026e0 <usart_init_rs232+0xc0>
8000263e:	30 99       	mov	r9,9
80002640:	f2 08 18 00 	cp.b	r8,r9
80002644:	e0 8b 00 4e 	brhi	800026e0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002648:	0f d9       	ld.ub	r9,r7[0x5]
8000264a:	30 78       	mov	r8,7
8000264c:	f0 09 18 00 	cp.b	r9,r8
80002650:	e0 8b 00 48 	brhi	800026e0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80002654:	8e 39       	ld.sh	r9,r7[0x6]
80002656:	e0 68 01 01 	mov	r8,257
8000265a:	f0 09 19 00 	cp.h	r9,r8
8000265e:	e0 8b 00 41 	brhi	800026e0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80002662:	ef 39 00 08 	ld.ub	r9,r7[8]
80002666:	30 38       	mov	r8,3
80002668:	f0 09 18 00 	cp.b	r9,r8
8000266c:	e0 8b 00 3a 	brhi	800026e0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002670:	0a 9a       	mov	r10,r5
80002672:	6e 0b       	ld.w	r11,r7[0x0]
80002674:	0c 9c       	mov	r12,r6
80002676:	f0 1f 00 1d 	mcall	800026e8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000267a:	58 1c       	cp.w	r12,1
8000267c:	c3 20       	breq	800026e0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000267e:	0f c8       	ld.ub	r8,r7[0x4]
80002680:	30 99       	mov	r9,9
80002682:	f2 08 18 00 	cp.b	r8,r9
80002686:	c0 51       	brne	80002690 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002688:	6c 18       	ld.w	r8,r6[0x4]
8000268a:	b1 b8       	sbr	r8,0x11
8000268c:	8d 18       	st.w	r6[0x4],r8
8000268e:	c0 68       	rjmp	8000269a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002690:	6c 19       	ld.w	r9,r6[0x4]
80002692:	20 58       	sub	r8,5
80002694:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80002698:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000269a:	6c 19       	ld.w	r9,r6[0x4]
8000269c:	ef 3a 00 08 	ld.ub	r10,r7[8]
800026a0:	0f d8       	ld.ub	r8,r7[0x5]
800026a2:	a9 78       	lsl	r8,0x9
800026a4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800026a8:	12 48       	or	r8,r9
800026aa:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800026ac:	8e 38       	ld.sh	r8,r7[0x6]
800026ae:	30 29       	mov	r9,2
800026b0:	f2 08 19 00 	cp.h	r8,r9
800026b4:	e0 88 00 09 	brls	800026c6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800026b8:	6c 18       	ld.w	r8,r6[0x4]
800026ba:	ad b8       	sbr	r8,0xd
800026bc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800026be:	8e b8       	ld.uh	r8,r7[0x6]
800026c0:	20 28       	sub	r8,2
800026c2:	8d a8       	st.w	r6[0x28],r8
800026c4:	c0 68       	rjmp	800026d0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800026c6:	6c 19       	ld.w	r9,r6[0x4]
800026c8:	5c 78       	castu.h	r8
800026ca:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800026ce:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800026d0:	6c 18       	ld.w	r8,r6[0x4]
800026d2:	e0 18 ff f0 	andl	r8,0xfff0
800026d6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800026d8:	35 08       	mov	r8,80
800026da:	8d 08       	st.w	r6[0x0],r8
800026dc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800026e0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	25 f2       	sub	r2,95
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	25 98       	sub	r8,89

800026ec <main>:
static void prvIndicateError( void );

/*-----------------------------------------------------------*/

int main( void )
{
800026ec:	eb cd 40 80 	pushm	r7,lr

#else
	// Configure Osc0 in crystal mode (i.e. use of an external crystal source, with
	// frequency FOSC0) with an appropriate startup time then switch the main clock
	// source to Osc0.
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
800026f0:	30 3a       	mov	r10,3
800026f2:	e0 6b 24 00 	mov	r11,9216
800026f6:	ea 1b 00 f4 	orh	r11,0xf4
800026fa:	30 0c       	mov	r12,0
800026fc:	f0 1f 00 18 	mcall	8000275c <main+0x70>
#endif

	portDBG_TRACE("Starting the FreeRTOS AVR32 UC3 Demo...");

	/* Setup the LED's for output. */
	vParTestInitialise();
80002700:	f0 1f 00 18 	mcall	80002760 <main+0x74>
	/* Start the standard demo tasks.  See the WEB documentation for more
	information.
	Note that the UC3L and UC3B parts do not have enough internal RAM to launch all the tasks of this example.
	That's why some of them are commented out using respectively #if (BOARD != UC3L_EK) or #if (BOARD != EVK1101)
	compiler directives. */
	vStartLEDFlashTasks( mainLED_TASK_PRIORITY );
80002704:	30 1c       	mov	r12,1
80002706:	f0 1f 00 18 	mcall	80002764 <main+0x78>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
8000270a:	30 3a       	mov	r10,3
8000270c:	e0 6b e1 00 	mov	r11,57600
80002710:	30 2c       	mov	r12,2
80002712:	f0 1f 00 16 	mcall	80002768 <main+0x7c>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
80002716:	30 2c       	mov	r12,2
80002718:	f0 1f 00 15 	mcall	8000276c <main+0x80>
	#if (BOARD != UC3L_EK)
		vStartIntegerMathTasks( tskIDLE_PRIORITY );
8000271c:	30 0c       	mov	r12,0
8000271e:	f0 1f 00 15 	mcall	80002770 <main+0x84>
		vStartSemaphoreTasks( mainSEM_TEST_PRIORITY );
80002722:	30 1c       	mov	r12,1
80002724:	f0 1f 00 14 	mcall	80002774 <main+0x88>
		vStartDynamicPriorityTasks();
80002728:	f0 1f 00 14 	mcall	80002778 <main+0x8c>
	#endif

	#if (BOARD != EVK1101) && (BOARD != UC3L_EK)
		vStartBlockingQueueTasks( mainBLOCK_Q_PRIORITY );
8000272c:	30 3c       	mov	r12,3
8000272e:	f0 1f 00 14 	mcall	8000277c <main+0x90>
		vStartMathTasks( tskIDLE_PRIORITY );
80002732:	30 0c       	mov	r12,0
80002734:	f0 1f 00 13 	mcall	80002780 <main+0x94>
	#endif

	/* Start the demo tasks defined within this file, specifically the check
	task as described at the top of this file. */
	xTaskCreate(
80002738:	30 07       	mov	r7,0
8000273a:	1a d7       	st.w	--sp,r7
8000273c:	1a d7       	st.w	--sp,r7
8000273e:	1a d7       	st.w	--sp,r7
80002740:	30 48       	mov	r8,4
80002742:	0e 99       	mov	r9,r7
80002744:	e0 6a 01 00 	mov	r10,256
80002748:	48 fb       	lddpc	r11,80002784 <main+0x98>
8000274a:	49 0c       	lddpc	r12,80002788 <main+0x9c>
8000274c:	f0 1f 00 10 	mcall	8000278c <main+0xa0>
		,  NULL
		,  mainCHECK_TASK_PRIORITY
		,  NULL );

	/* Start the scheduler. */
	vTaskStartScheduler();
80002750:	f0 1f 00 10 	mcall	80002790 <main+0xa4>
80002754:	2f dd       	sub	sp,-12

	/* Will only get here if there was insufficient memory to create the idle
	task. */

	return 0;
}
80002756:	0e 9c       	mov	r12,r7
80002758:	e3 cd 80 80 	ldm	sp++,r7,pc
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	23 f4       	sub	r4,63
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	29 d0       	sub	r0,-99
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	34 e0       	mov	r0,78
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	2e e0       	sub	r0,-18
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	3b 1c       	mov	r12,-79
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	3a 64       	mov	r4,-90
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	3c c0       	mov	r0,-52
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	32 50       	mov	r0,37
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	2c e8       	sub	r8,-50
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	37 b0       	mov	r0,123
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	67 f0       	ld.w	r0,r3[0x7c]
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	27 f8       	sub	r8,127
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	4e c0       	lddpc	r0,8000293c <vMemCheckTask+0x1c>
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	50 a4       	stdsp	sp[0x28],r4

80002794 <prvIndicateError>:
	}
}
/*-----------------------------------------------------------*/

static void prvIndicateError( void )
{
80002794:	eb cd 40 f8 	pushm	r3-r7,lr
	/* The check task has found an error in one of the other tasks.
	Set the LEDs to a state that indicates this. */
	vParTestSetLED(mainERROR_LED,pdTRUE);
80002798:	30 1b       	mov	r11,1
8000279a:	30 7c       	mov	r12,7
8000279c:	f0 1f 00 14 	mcall	800027ec <prvIndicateError+0x58>

	#if BOARD == EVK1101 || BOARD == EVK1104 || BOARD == EVK1105 || BOARD == UC3C_EK || BOARD == UC3L_EK
		/* Set all LEDs to the same initial state before toggling them. */
		vParTestSetLED( 0, pdTRUE );
800027a0:	30 1b       	mov	r11,1
800027a2:	30 0c       	mov	r12,0
800027a4:	f0 1f 00 12 	mcall	800027ec <prvIndicateError+0x58>
		vParTestSetLED( 1, pdTRUE );
800027a8:	30 1b       	mov	r11,1
800027aa:	16 9c       	mov	r12,r11
800027ac:	f0 1f 00 10 	mcall	800027ec <prvIndicateError+0x58>
		vParTestSetLED( 2, pdTRUE );
800027b0:	30 1b       	mov	r11,1
800027b2:	30 2c       	mov	r12,2
800027b4:	f0 1f 00 0e 	mcall	800027ec <prvIndicateError+0x58>
		vParTestSetLED( 3, pdTRUE );
800027b8:	30 1b       	mov	r11,1
800027ba:	30 3c       	mov	r12,3
800027bc:	f0 1f 00 0c 	mcall	800027ec <prvIndicateError+0x58>
	{
		#if BOARD == EVK1100
			vParTestToggleLED( mainCHECK_TASK_LED );
			vTaskDelay( mainERROR_FLASH_RATE );
		#elif BOARD == EVK1101 || BOARD == EVK1104 || BOARD == EVK1105 || BOARD == UC3C_EK || BOARD == UC3L_EK
			vParTestToggleLED( 0 );
800027c0:	30 06       	mov	r6,0
			vParTestToggleLED( 1 );
800027c2:	30 17       	mov	r7,1
			vParTestToggleLED( 2 );
800027c4:	30 25       	mov	r5,2
			vParTestToggleLED( 3 );
800027c6:	30 34       	mov	r4,3
			vTaskDelay( mainERROR_FLASH_RATE );
800027c8:	e0 63 01 f4 	mov	r3,500
	{
		#if BOARD == EVK1100
			vParTestToggleLED( mainCHECK_TASK_LED );
			vTaskDelay( mainERROR_FLASH_RATE );
		#elif BOARD == EVK1101 || BOARD == EVK1104 || BOARD == EVK1105 || BOARD == UC3C_EK || BOARD == UC3L_EK
			vParTestToggleLED( 0 );
800027cc:	0c 9c       	mov	r12,r6
800027ce:	f0 1f 00 09 	mcall	800027f0 <prvIndicateError+0x5c>
			vParTestToggleLED( 1 );
800027d2:	0e 9c       	mov	r12,r7
800027d4:	f0 1f 00 07 	mcall	800027f0 <prvIndicateError+0x5c>
			vParTestToggleLED( 2 );
800027d8:	0a 9c       	mov	r12,r5
800027da:	f0 1f 00 06 	mcall	800027f0 <prvIndicateError+0x5c>
			vParTestToggleLED( 3 );
800027de:	08 9c       	mov	r12,r4
800027e0:	f0 1f 00 04 	mcall	800027f0 <prvIndicateError+0x5c>
			vTaskDelay( mainERROR_FLASH_RATE );
800027e4:	06 9c       	mov	r12,r3
800027e6:	f0 1f 00 04 	mcall	800027f4 <prvIndicateError+0x60>
800027ea:	cf 1b       	rjmp	800027cc <prvIndicateError+0x38>
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	2a 20       	sub	r0,-94
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	29 e0       	sub	r0,-98
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	4d 20       	lddpc	r0,8000293c <vMemCheckTask+0x1c>

800027f8 <vErrorChecks>:

/*!
 * \brief The task function for the "Check" task.
 */
static void vErrorChecks( void *pvParameters )
{
800027f8:	d4 31       	pushm	r0-r7,lr
800027fa:	20 2d       	sub	sp,8
800027fc:	30 05       	mov	r5,0
			vTaskStartScheduler() has already been called (thus the hidden IDLE task
			has already been spawned). Since vCreateSuicidalTask() supposes that the
			IDLE task isn't included in the response from uxTaskGetNumberOfTasks(),
			let the MEM_CHECK task play that role. => this is why vCreateSuicidalTasks()
			is not called as the last task. */
			vCreateSuicidalTasks( mainCREATOR_TASK_PRIORITY );
800027fe:	30 17       	mov	r7,1
		}

		/* Reset xCreatedTask.  This is modified by the task about to be
		created so we can tell if it is executing correctly or not. */
		xCreatedTask = mainNO_TASK;
80002800:	0a 96       	mov	r6,r5

		/* Dynamically create a task - passing ulMemCheckTaskRunningCount as a
		parameter. */
		ulMemCheckTaskRunningCount = mainCOUNT_INITIAL_VALUE;

		if( xTaskCreate( vMemCheckTask,
80002802:	fa c4 ff fc 	sub	r4,sp,-4
80002806:	4b 53       	lddpc	r3,800028d8 <vErrorChecks+0xe0>
80002808:	4b 52       	lddpc	r2,800028dc <vErrorChecks+0xe4>
8000280a:	1a 91       	mov	r1,sp
8000280c:	e0 60 01 00 	mov	r0,256
	then it is likely that the memory allocation failed. */

	for( ;; )
	{
		/* Do this only once. */
		if( bSuicidalTask == 0 )
80002810:	58 05       	cp.w	r5,0
80002812:	c0 51       	brne	8000281c <vErrorChecks+0x24>
			vTaskStartScheduler() has already been called (thus the hidden IDLE task
			has already been spawned). Since vCreateSuicidalTask() supposes that the
			IDLE task isn't included in the response from uxTaskGetNumberOfTasks(),
			let the MEM_CHECK task play that role. => this is why vCreateSuicidalTasks()
			is not called as the last task. */
			vCreateSuicidalTasks( mainCREATOR_TASK_PRIORITY );
80002814:	30 3c       	mov	r12,3
80002816:	f0 1f 00 33 	mcall	800028e0 <vErrorChecks+0xe8>
8000281a:	0e 95       	mov	r5,r7
		}

		/* Reset xCreatedTask.  This is modified by the task about to be
		created so we can tell if it is executing correctly or not. */
		xCreatedTask = mainNO_TASK;
8000281c:	50 06       	stdsp	sp[0x0],r6

		/* Dynamically create a task - passing ulMemCheckTaskRunningCount as a
		parameter. */
		ulMemCheckTaskRunningCount = mainCOUNT_INITIAL_VALUE;
8000281e:	50 16       	stdsp	sp[0x4],r6

		if( xTaskCreate( vMemCheckTask,
80002820:	1a d6       	st.w	--sp,r6
80002822:	1a d6       	st.w	--sp,r6
80002824:	1a d1       	st.w	--sp,r1
80002826:	0c 98       	mov	r8,r6
80002828:	08 99       	mov	r9,r4
8000282a:	00 9a       	mov	r10,r0
8000282c:	06 9b       	mov	r11,r3
8000282e:	04 9c       	mov	r12,r2
80002830:	f0 1f 00 2d 	mcall	800028e4 <vErrorChecks+0xec>
80002834:	2f dd       	sub	sp,-12
80002836:	58 1c       	cp.w	r12,1
80002838:	c0 30       	breq	8000283e <vErrorChecks+0x46>
			tskIDLE_PRIORITY, &xCreatedTask ) != pdPASS )
		{
			/* Could not create the task - we have probably run out of heap.
			Don't go any further and flash the LED faster to provide visual
			feedback of the error. */
			prvIndicateError();
8000283a:	f0 1f 00 2c 	mcall	800028e8 <vErrorChecks+0xf0>
		}

		/* Delay until it is time to execute again. */
		vTaskDelay( mainCHECK_PERIOD );
8000283e:	e0 6c 0b b8 	mov	r12,3000
80002842:	f0 1f 00 2b 	mcall	800028ec <vErrorChecks+0xf4>

		/* Delete the dynamically created task. */
		if( xCreatedTask != mainNO_TASK )
80002846:	40 0c       	lddsp	r12,sp[0x0]
80002848:	58 0c       	cp.w	r12,0
8000284a:	c0 30       	breq	80002850 <vErrorChecks+0x58>
		{
			vTaskDelete( xCreatedTask );
8000284c:	f0 1f 00 29 	mcall	800028f0 <vErrorChecks+0xf8>
		}

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
80002850:	4a 98       	lddpc	r8,800028f4 <vErrorChecks+0xfc>
80002852:	70 09       	ld.w	r9,r8[0x0]
80002854:	f2 09 00 19 	add	r9,r9,r9<<0x1
80002858:	91 09       	st.w	r8[0x0],r9
 */
static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreComTestTasksStillRunning() != pdTRUE )
8000285a:	f0 1f 00 28 	mcall	800028f8 <vErrorChecks+0x100>
8000285e:	58 1c       	cp.w	r12,1
80002860:	c0 30       	breq	80002866 <vErrorChecks+0x6e>
	{
		xErrorHasOccurred = pdTRUE;
80002862:	4a 78       	lddpc	r8,800028fc <vErrorChecks+0x104>
80002864:	91 07       	st.w	r8[0x0],r7
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
80002866:	f0 1f 00 27 	mcall	80002900 <vErrorChecks+0x108>
8000286a:	58 1c       	cp.w	r12,1
8000286c:	c0 30       	breq	80002872 <vErrorChecks+0x7a>
	{
		xErrorHasOccurred = pdTRUE;
8000286e:	4a 48       	lddpc	r8,800028fc <vErrorChecks+0x104>
80002870:	91 07       	st.w	r8[0x0],r7
	}

	#if (BOARD != UC3L_EK)
	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
80002872:	f0 1f 00 25 	mcall	80002904 <vErrorChecks+0x10c>
80002876:	58 1c       	cp.w	r12,1
80002878:	c0 30       	breq	8000287e <vErrorChecks+0x86>
	{
		xErrorHasOccurred = pdTRUE;
8000287a:	4a 18       	lddpc	r8,800028fc <vErrorChecks+0x104>
8000287c:	91 07       	st.w	r8[0x0],r7
	}
	#endif

	#if (BOARD != UC3L_EK)
	if( xAreSemaphoreTasksStillRunning() != pdTRUE )
8000287e:	f0 1f 00 23 	mcall	80002908 <vErrorChecks+0x110>
80002882:	58 1c       	cp.w	r12,1
80002884:	c0 30       	breq	8000288a <vErrorChecks+0x92>
	{
		xErrorHasOccurred = pdTRUE;
80002886:	49 e8       	lddpc	r8,800028fc <vErrorChecks+0x104>
80002888:	91 07       	st.w	r8[0x0],r7
	}
	#endif

	#if (BOARD != EVK1101) && (BOARD != UC3L_EK)
	if( xAreBlockingQueuesStillRunning() != pdTRUE )
8000288a:	f0 1f 00 21 	mcall	8000290c <vErrorChecks+0x114>
8000288e:	58 1c       	cp.w	r12,1
80002890:	c0 30       	breq	80002896 <vErrorChecks+0x9e>
	{
		xErrorHasOccurred = pdTRUE;
80002892:	49 b8       	lddpc	r8,800028fc <vErrorChecks+0x104>
80002894:	91 07       	st.w	r8[0x0],r7
	}
	#endif

	#if (BOARD != UC3L_EK)
	if( xAreDynamicPriorityTasksStillRunning() != pdTRUE )
80002896:	f0 1f 00 1f 	mcall	80002910 <vErrorChecks+0x118>
8000289a:	58 1c       	cp.w	r12,1
8000289c:	c0 30       	breq	800028a2 <vErrorChecks+0xaa>
	{
		xErrorHasOccurred = pdTRUE;
8000289e:	49 88       	lddpc	r8,800028fc <vErrorChecks+0x104>
800028a0:	91 07       	st.w	r8[0x0],r7
	}
	#endif

	#if (BOARD != EVK1101) && (BOARD != UC3L_EK)
	if( xAreMathsTaskStillRunning() != pdTRUE )
800028a2:	f0 1f 00 1d 	mcall	80002914 <vErrorChecks+0x11c>
800028a6:	58 1c       	cp.w	r12,1
800028a8:	c0 30       	breq	800028ae <vErrorChecks+0xb6>
	{
		xErrorHasOccurred = pdTRUE;
800028aa:	49 58       	lddpc	r8,800028fc <vErrorChecks+0x104>
800028ac:	91 07       	st.w	r8[0x0],r7
	}
	#endif

	if( xIsCreateTaskStillRunning() != pdTRUE )
800028ae:	f0 1f 00 1b 	mcall	80002918 <vErrorChecks+0x120>
800028b2:	58 1c       	cp.w	r12,1
800028b4:	c0 40       	breq	800028bc <vErrorChecks+0xc4>
	{
		xErrorHasOccurred = pdTRUE;
800028b6:	49 28       	lddpc	r8,800028fc <vErrorChecks+0x104>
800028b8:	91 07       	st.w	r8[0x0],r7
800028ba:	c0 88       	rjmp	800028ca <vErrorChecks+0xd2>
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;

		/* Check all other tasks are still operating without error.
		Check that vMemCheckTask did increment the counter. */
		if( ( prvCheckOtherTasksAreStillRunning() != pdFALSE )
800028bc:	49 08       	lddpc	r8,800028fc <vErrorChecks+0x104>
800028be:	70 08       	ld.w	r8,r8[0x0]
800028c0:	58 08       	cp.w	r8,0
800028c2:	c0 41       	brne	800028ca <vErrorChecks+0xd2>
800028c4:	40 18       	lddsp	r8,sp[0x4]
800028c6:	58 08       	cp.w	r8,0
800028c8:	c0 41       	brne	800028d0 <vErrorChecks+0xd8>
		 || ( ulMemCheckTaskRunningCount == mainCOUNT_INITIAL_VALUE ) )
		{
			/* An error has occurred in one of the tasks.
			Don't go any further and flash the LED faster to give visual
			feedback of the error. */
			prvIndicateError();
800028ca:	f0 1f 00 08 	mcall	800028e8 <vErrorChecks+0xf0>
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;

		/* Check all other tasks are still operating without error.
		Check that vMemCheckTask did increment the counter. */
		if( ( prvCheckOtherTasksAreStillRunning() != pdFALSE )
800028ce:	ca 1b       	rjmp	80002810 <vErrorChecks+0x18>
			prvIndicateError();
		}
		else
		{
			/* Toggle the LED if everything is okay. */
			vParTestToggleLED( mainCHECK_TASK_LED );
800028d0:	30 6c       	mov	r12,6
800028d2:	f0 1f 00 13 	mcall	8000291c <vErrorChecks+0x124>
800028d6:	c9 db       	rjmp	80002810 <vErrorChecks+0x18>
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	67 fc       	ld.w	r12,r3[0x7c]
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	29 20       	sub	r0,-110
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	30 c0       	mov	r0,12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	4e c0       	lddpc	r0,80002a94 <xSerialPutChar+0x20>
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	27 94       	sub	r4,121
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	4d 20       	lddpc	r0,80002a34 <vParTestSetLED+0x14>
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	4c 38       	lddpc	r8,800029fc <vParTestToggleLED+0x1c>
800028f4:	00 00       	add	r0,r0
800028f6:	00 24       	rsub	r4,r0
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	2e cc       	sub	r12,-20
800028fc:	00 00       	add	r0,r0
800028fe:	07 0c       	ld.w	r12,r3++
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	3a f4       	mov	r4,-81
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	3a 50       	mov	r0,-91
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	3c 68       	mov	r8,-58
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	2c 94       	sub	r4,-55
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	32 10       	mov	r0,33
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	37 80       	mov	r0,120
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	30 68       	mov	r8,6
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	29 e0       	sub	r0,-98

80002920 <vMemCheckTask>:
 * See the top of vErrorChecks for more details.
 *
 * \param *pvParameters Parameters for the task (can be of any kind)
 */
static void vMemCheckTask( void *pvParameters )
{
80002920:	d4 31       	pushm	r0-r7,lr
80002922:	18 94       	mov	r4,r12

	pulMemCheckTaskRunningCounter = ( unsigned portLONG * ) pvParameters;

	for( ;; )
	{
		if( lErrorOccurred == pdFALSE )
80002924:	4a 56       	lddpc	r6,800029b8 <vMemCheckTask+0x98>
		exercise.  This has to be in a critical section to ensure the
		task does not get deleted while it has memory allocated. */

		vTaskSuspendAll();
		{
			pvMem1 = pvPortMalloc( mainMEM_CHECK_SIZE_1 );
80002926:	33 33       	mov	r3,51
			{
				lErrorOccurred = pdTRUE;
			}
			else
			{
				memset( pvMem1, 0xaa, mainMEM_CHECK_SIZE_1 );
80002928:	e0 65 00 aa 	mov	r5,170
		{
			pvMem1 = pvPortMalloc( mainMEM_CHECK_SIZE_1 );

			if( pvMem1 == NULL )
			{
				lErrorOccurred = pdTRUE;
8000292c:	30 10       	mov	r0,1
		xTaskResumeAll();

		/* Again - with a different size block. */
		vTaskSuspendAll();
		{
			pvMem2 = pvPortMalloc( mainMEM_CHECK_SIZE_2 );
8000292e:	33 42       	mov	r2,52
		xTaskResumeAll();

		/* Again - with a different size block. */
		vTaskSuspendAll();
		{
			pvMem3 = pvPortMalloc( mainMEM_CHECK_SIZE_3 );
80002930:	30 f1       	mov	r1,15

	pulMemCheckTaskRunningCounter = ( unsigned portLONG * ) pvParameters;

	for( ;; )
	{
		if( lErrorOccurred == pdFALSE )
80002932:	6c 08       	ld.w	r8,r6[0x0]
		{
			/* We have never seen an error so increment the counter. */
			( *pulMemCheckTaskRunningCounter )++;
80002934:	58 08       	cp.w	r8,0
80002936:	e9 f8 00 00 	ld.weq	r8,r4[0x0]
8000293a:	f7 b8 00 ff 	subeq	r8,-1
8000293e:	e9 f8 0a 00 	st.weq	r4[0x0],r8
		}
		else
		{
			/* There has been an error so reset the counter so the check task
			can tell that an error occurred. */
			*pulMemCheckTaskRunningCounter = mainCOUNT_INITIAL_VALUE;
80002942:	f9 b8 01 00 	movne	r8,0
80002946:	e9 f8 1a 00 	st.wne	r4[0x0],r8

		/* Allocate some memory - just to give the allocator some extra
		exercise.  This has to be in a critical section to ensure the
		task does not get deleted while it has memory allocated. */

		vTaskSuspendAll();
8000294a:	f0 1f 00 1d 	mcall	800029bc <vMemCheckTask+0x9c>
		{
			pvMem1 = pvPortMalloc( mainMEM_CHECK_SIZE_1 );
8000294e:	06 9c       	mov	r12,r3
80002950:	f0 1f 00 1c 	mcall	800029c0 <vMemCheckTask+0xa0>
80002954:	18 97       	mov	r7,r12

			if( pvMem1 == NULL )
80002956:	c0 31       	brne	8000295c <vMemCheckTask+0x3c>
			{
				lErrorOccurred = pdTRUE;
80002958:	8d 00       	st.w	r6[0x0],r0
8000295a:	c0 88       	rjmp	8000296a <vMemCheckTask+0x4a>
			}
			else
			{
				memset( pvMem1, 0xaa, mainMEM_CHECK_SIZE_1 );
8000295c:	06 9a       	mov	r10,r3
8000295e:	0a 9b       	mov	r11,r5
80002960:	f0 1f 00 19 	mcall	800029c4 <vMemCheckTask+0xa4>
				vPortFree( pvMem1 );
80002964:	0e 9c       	mov	r12,r7
80002966:	f0 1f 00 19 	mcall	800029c8 <vMemCheckTask+0xa8>
			}
		}
		xTaskResumeAll();
8000296a:	f0 1f 00 19 	mcall	800029cc <vMemCheckTask+0xac>

		/* Again - with a different size block. */
		vTaskSuspendAll();
8000296e:	f0 1f 00 14 	mcall	800029bc <vMemCheckTask+0x9c>
		{
			pvMem2 = pvPortMalloc( mainMEM_CHECK_SIZE_2 );
80002972:	04 9c       	mov	r12,r2
80002974:	f0 1f 00 13 	mcall	800029c0 <vMemCheckTask+0xa0>
80002978:	18 97       	mov	r7,r12

			if( pvMem2 == NULL )
8000297a:	c0 31       	brne	80002980 <vMemCheckTask+0x60>
			{
				lErrorOccurred = pdTRUE;
8000297c:	8d 00       	st.w	r6[0x0],r0
8000297e:	c0 88       	rjmp	8000298e <vMemCheckTask+0x6e>
			}
			else
			{
				memset( pvMem2, 0xaa, mainMEM_CHECK_SIZE_2 );
80002980:	04 9a       	mov	r10,r2
80002982:	0a 9b       	mov	r11,r5
80002984:	f0 1f 00 10 	mcall	800029c4 <vMemCheckTask+0xa4>
				vPortFree( pvMem2 );
80002988:	0e 9c       	mov	r12,r7
8000298a:	f0 1f 00 10 	mcall	800029c8 <vMemCheckTask+0xa8>
			}
		}
		xTaskResumeAll();
8000298e:	f0 1f 00 10 	mcall	800029cc <vMemCheckTask+0xac>

		/* Again - with a different size block. */
		vTaskSuspendAll();
80002992:	f0 1f 00 0b 	mcall	800029bc <vMemCheckTask+0x9c>
		{
			pvMem3 = pvPortMalloc( mainMEM_CHECK_SIZE_3 );
80002996:	02 9c       	mov	r12,r1
80002998:	f0 1f 00 0a 	mcall	800029c0 <vMemCheckTask+0xa0>
8000299c:	18 97       	mov	r7,r12
			if( pvMem3 == NULL )
8000299e:	c0 31       	brne	800029a4 <vMemCheckTask+0x84>
			{
				lErrorOccurred = pdTRUE;
800029a0:	8d 00       	st.w	r6[0x0],r0
800029a2:	c0 88       	rjmp	800029b2 <vMemCheckTask+0x92>
			}
			else
			{
				memset( pvMem3, 0xaa, mainMEM_CHECK_SIZE_3 );
800029a4:	02 9a       	mov	r10,r1
800029a6:	0a 9b       	mov	r11,r5
800029a8:	f0 1f 00 07 	mcall	800029c4 <vMemCheckTask+0xa4>
				vPortFree( pvMem3 );
800029ac:	0e 9c       	mov	r12,r7
800029ae:	f0 1f 00 07 	mcall	800029c8 <vMemCheckTask+0xa8>
			}
		}
		xTaskResumeAll();
800029b2:	f0 1f 00 07 	mcall	800029cc <vMemCheckTask+0xac>
	}
800029b6:	cb eb       	rjmp	80002932 <vMemCheckTask+0x12>
800029b8:	00 00       	add	r0,r0
800029ba:	07 10       	ld.sh	r0,r3++
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	46 7c       	lddsp	r12,sp[0x19c]
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	41 b0       	lddsp	r0,sp[0x6c]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	5f a8       	srle	r8
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	41 88       	lddsp	r8,sp[0x60]
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	49 8c       	lddpc	r12,80002a2c <vParTestSetLED+0xc>

800029d0 <vParTestInitialise>:
static volatile unsigned portCHAR ucCurrentOutputValue = partstALL_OUTPUTS_OFF; /*lint !e956 File scope parameters okay here. */

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
800029d0:	d4 01       	pushm	lr
	LED_Display( partstALL_OUTPUTS_OFF ); /* Start with all LEDs off. */
800029d2:	30 0c       	mov	r12,0
800029d4:	f0 1f 00 02 	mcall	800029dc <vParTestInitialise+0xc>
}
800029d8:	d8 02       	popm	pc
800029da:	00 00       	add	r0,r0
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	20 dc       	sub	r12,13

800029e0 <vParTestToggleLED>:
	xTaskResumeAll();
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
800029e0:	eb cd 40 80 	pushm	r7,lr
800029e4:	18 97       	mov	r7,r12
unsigned portCHAR ucBit;

	  if( uxLED >= partstMAX_OUTPUT_LED )
800029e6:	58 3c       	cp.w	r12,3
800029e8:	e0 8b 00 12 	brhi	80002a0c <vParTestToggleLED+0x2c>
	return;
	}

	ucBit = ( ( unsigned portCHAR ) 1 ) << uxLED;

	vTaskSuspendAll();
800029ec:	f0 1f 00 09 	mcall	80002a10 <vParTestToggleLED+0x30>
	{
		ucCurrentOutputValue ^= ucBit;
800029f0:	48 98       	lddpc	r8,80002a14 <vParTestToggleLED+0x34>
800029f2:	11 89       	ld.ub	r9,r8[0x0]
800029f4:	30 1a       	mov	r10,1
800029f6:	f4 07 09 4a 	lsl	r10,r10,r7
800029fa:	f3 ea 20 07 	eor	r7,r9,r10
800029fe:	5c 57       	castu.b	r7
80002a00:	b0 87       	st.b	r8[0x0],r7
		LED_Display(ucCurrentOutputValue);
80002a02:	11 8c       	ld.ub	r12,r8[0x0]
80002a04:	f0 1f 00 05 	mcall	80002a18 <vParTestToggleLED+0x38>
	}
	xTaskResumeAll();
80002a08:	f0 1f 00 05 	mcall	80002a1c <vParTestToggleLED+0x3c>
80002a0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	46 7c       	lddsp	r12,sp[0x19c]
80002a14:	00 00       	add	r0,r0
80002a16:	07 14       	ld.sh	r4,r3++
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	20 dc       	sub	r12,13
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	49 8c       	lddpc	r12,80002a7c <xSerialPutChar+0x8>

80002a20 <vParTestSetLED>:
	LED_Display( partstALL_OUTPUTS_OFF ); /* Start with all LEDs off. */
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
80002a20:	eb cd 40 c0 	pushm	r6-r7,lr
80002a24:	16 97       	mov	r7,r11
unsigned portCHAR ucBit;

	if( uxLED >= partstMAX_OUTPUT_LED )
80002a26:	58 3c       	cp.w	r12,3
80002a28:	e0 8b 00 1b 	brhi	80002a5e <vParTestSetLED+0x3e>
	{
		return;
	}

	ucBit = ( ( unsigned portCHAR ) 1 ) << uxLED;
80002a2c:	30 16       	mov	r6,1
80002a2e:	ec 0c 09 46 	lsl	r6,r6,r12
80002a32:	5c 56       	castu.b	r6

	vTaskSuspendAll();
80002a34:	f0 1f 00 0c 	mcall	80002a64 <vParTestSetLED+0x44>
	{
		if( xValue == pdTRUE )
80002a38:	58 17       	cp.w	r7,1
80002a3a:	c0 61       	brne	80002a46 <vParTestSetLED+0x26>
		{
			ucCurrentOutputValue |= ucBit;
80002a3c:	48 b8       	lddpc	r8,80002a68 <vParTestSetLED+0x48>
80002a3e:	11 89       	ld.ub	r9,r8[0x0]
80002a40:	12 46       	or	r6,r9
80002a42:	b0 86       	st.b	r8[0x0],r6
80002a44:	c0 78       	rjmp	80002a52 <vParTestSetLED+0x32>
		}
		else
		{
			ucCurrentOutputValue &= ~ucBit;
80002a46:	48 98       	lddpc	r8,80002a68 <vParTestSetLED+0x48>
80002a48:	11 89       	ld.ub	r9,r8[0x0]
80002a4a:	5c d6       	com	r6
80002a4c:	f3 e6 00 06 	and	r6,r9,r6
80002a50:	b0 86       	st.b	r8[0x0],r6
		}

		LED_Display(ucCurrentOutputValue);
80002a52:	48 68       	lddpc	r8,80002a68 <vParTestSetLED+0x48>
80002a54:	11 8c       	ld.ub	r12,r8[0x0]
80002a56:	f0 1f 00 06 	mcall	80002a6c <vParTestSetLED+0x4c>
	}
	xTaskResumeAll();
80002a5a:	f0 1f 00 06 	mcall	80002a70 <vParTestSetLED+0x50>
80002a5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a62:	00 00       	add	r0,r0
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	46 7c       	lddsp	r12,sp[0x19c]
80002a68:	00 00       	add	r0,r0
80002a6a:	07 14       	ld.sh	r4,r3++
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	20 dc       	sub	r12,13
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	49 8c       	lddpc	r12,80002ad0 <xSerialPortInitMinimal+0x14>

80002a74 <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed portCHAR cOutChar, portTickType xBlockTime )
{
80002a74:	d4 01       	pushm	lr
80002a76:	20 1d       	sub	sp,4
80002a78:	ba 8b       	st.b	sp[0x0],r11
volatile avr32_usart_t  *usart = serialPORT_USART;

	/* Place the character in the queue of characters to be transmitted. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
80002a7a:	30 09       	mov	r9,0
80002a7c:	1a 9b       	mov	r11,sp
80002a7e:	48 88       	lddpc	r8,80002a9c <xSerialPutChar+0x28>
80002a80:	70 0c       	ld.w	r12,r8[0x0]
80002a82:	f0 1f 00 08 	mcall	80002aa0 <xSerialPutChar+0x2c>
80002a86:	58 1c       	cp.w	r12,1
80002a88:	c0 30       	breq	80002a8e <xSerialPutChar+0x1a>
80002a8a:	30 0c       	mov	r12,0
80002a8c:	c0 68       	rjmp	80002a98 <xSerialPutChar+0x24>

	/* Turn on the Tx interrupt so the ISR will remove the character from the
	queue and send it.   This does not need to be in a critical section as
	if the interrupt has already removed the character the next interrupt
	will simply turn off the Tx interrupt again. */
	usart->ier = (1 << AVR32_USART_IER_TXRDY_OFFSET);
80002a8e:	30 29       	mov	r9,2
80002a90:	fe 78 2c 00 	mov	r8,-54272
80002a94:	91 29       	st.w	r8[0x8],r9
80002a96:	30 1c       	mov	r12,1

	return pdPASS;
}
80002a98:	2f fd       	sub	sp,-4
80002a9a:	d8 02       	popm	pc
80002a9c:	00 00       	add	r0,r0
80002a9e:	07 18       	ld.sh	r8,r3++
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	44 e8       	lddsp	r8,sp[0x138]

80002aa4 <xSerialGetChar>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed portCHAR *pcRxedChar, portTickType xBlockTime )
{
80002aa4:	d4 01       	pushm	lr
	/* The port handle is not required as this driver only supports UART0. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
80002aa6:	30 09       	mov	r9,0
80002aa8:	48 38       	lddpc	r8,80002ab4 <xSerialGetChar+0x10>
80002aaa:	70 0c       	ld.w	r12,r8[0x0]
80002aac:	f0 1f 00 03 	mcall	80002ab8 <xSerialGetChar+0x14>
	}
	else
	{
		return pdFALSE;
	}
}
80002ab0:	5f 1c       	srne	r12
80002ab2:	d8 02       	popm	pc
80002ab4:	00 00       	add	r0,r0
80002ab6:	07 1c       	ld.sh	r12,r3++
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	43 cc       	lddsp	r12,sp[0xf0]

80002abc <xSerialPortInitMinimal>:

/*
 * Init the serial port for the Minimal implementation.
 */
xComPortHandle xSerialPortInitMinimal( unsigned portLONG ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
80002abc:	eb cd 40 e0 	pushm	r5-r7,lr
80002ac0:	20 3d       	sub	sp,12
80002ac2:	18 95       	mov	r5,r12
80002ac4:	16 96       	mov	r6,r11
		.baudrate     = 57600,
		.charlength   = 8,
		.paritytype   = USART_NO_PARITY,
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};
80002ac6:	4a 59       	lddpc	r9,80002b58 <xSerialPortInitMinimal+0x9c>
80002ac8:	f2 ea 00 00 	ld.d	r10,r9[0]
80002acc:	fa eb 00 00 	st.d	sp[0],r10
80002ad0:	72 29       	ld.w	r9,r9[0x8]
80002ad2:	50 29       	stdsp	sp[0x8],r9

	USART_OPTIONS.baudrate = ulWantedBaud;
80002ad4:	50 0c       	stdsp	sp[0x0],r12
 * Create the rx and tx queues.
 */
static void vprvSerialCreateQueues(  unsigned portBASE_TYPE uxQueueLength, xQueueHandle *pxRxedChars, xQueueHandle *pxCharsForTx )
{
	/* Create the queues used to hold Rx and Tx characters. */
	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
80002ad6:	30 1b       	mov	r11,1
80002ad8:	0c 9c       	mov	r12,r6
80002ada:	f0 1f 00 21 	mcall	80002b5c <xSerialPortInitMinimal+0xa0>
80002ade:	4a 17       	lddpc	r7,80002b60 <xSerialPortInitMinimal+0xa4>
80002ae0:	8f 0c       	st.w	r7[0x0],r12
	xCharsForTx = xQueueCreate( uxQueueLength + 1, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
80002ae2:	30 1b       	mov	r11,1
80002ae4:	ec 0b 00 0c 	add	r12,r6,r11
80002ae8:	f0 1f 00 1d 	mcall	80002b5c <xSerialPortInitMinimal+0xa0>

	/* Pass back a reference to the queues so the serial API file can
	post/receive characters. */
	*pxRxedChars = xRxedChars;
80002aec:	6e 08       	ld.w	r8,r7[0x0]
	*pxCharsForTx = xCharsForTx;
80002aee:	49 e9       	lddpc	r9,80002b64 <xSerialPortInitMinimal+0xa8>
80002af0:	93 0c       	st.w	r9[0x0],r12

	/* Create the rx and tx queues. */
	vprvSerialCreateQueues( uxQueueLength, &xRxedChars, &xCharsForTx );

	/* Configure USART. */
	if( ( xRxedChars != serINVALID_QUEUE ) &&
80002af2:	58 08       	cp.w	r8,0
80002af4:	c2 d0       	breq	80002b4e <xSerialPortInitMinimal+0x92>
80002af6:	58 0c       	cp.w	r12,0
80002af8:	5f 19       	srne	r9
80002afa:	58 05       	cp.w	r5,0
80002afc:	5f 18       	srne	r8
80002afe:	f3 e8 00 08 	and	r8,r9,r8
80002b02:	c2 60       	breq	80002b4e <xSerialPortInitMinimal+0x92>
	  ( xCharsForTx != serINVALID_QUEUE ) &&
	  ( ulWantedBaud != ( unsigned portLONG ) 0 ) )
	{
		portENTER_CRITICAL();
80002b04:	f0 1f 00 19 	mcall	80002b68 <xSerialPortInitMinimal+0xac>
		{
			/**
			** Configure USART.
			**/
			/* Enable USART RXD & TXD pins. */
			gpio_enable_module( USART_GPIO_MAP, sizeof( USART_GPIO_MAP ) / sizeof( USART_GPIO_MAP[0] ) );
80002b08:	30 2b       	mov	r11,2
80002b0a:	49 9c       	lddpc	r12,80002b6c <xSerialPortInitMinimal+0xb0>
80002b0c:	f0 1f 00 19 	mcall	80002b70 <xSerialPortInitMinimal+0xb4>

			// Initialize USART in RS232 mode.
			usart_init_rs232(usart, &USART_OPTIONS, configPBA_CLOCK_HZ);
80002b10:	e0 6a 24 00 	mov	r10,9216
80002b14:	ea 1a 00 f4 	orh	r10,0xf4
80002b18:	1a 9b       	mov	r11,sp
80002b1a:	fe 7c 2c 00 	mov	r12,-54272
80002b1e:	f0 1f 00 16 	mcall	80002b74 <xSerialPortInitMinimal+0xb8>

			/* We're not fully done yet: disable receiver and transmitter. */
			usart->cr |= AVR32_USART_CR_RXDIS_MASK | AVR32_USART_CR_TXDIS_MASK;
80002b22:	fe 77 2c 00 	mov	r7,-54272
80002b26:	6e 08       	ld.w	r8,r7[0x0]
80002b28:	e8 18 00 a0 	orl	r8,0xa0
80002b2c:	8f 08       	st.w	r7[0x0],r8

			/* Register the USART interrupt handler to the interrupt controller and
			 enable the USART interrupt. */
			INTC_register_interrupt((__int_handler)&vUSART_ISR, serialPORT_USART_IRQ, AVR32_INTC_INT1);
80002b2e:	30 1a       	mov	r10,1
80002b30:	e0 6b 02 a0 	mov	r11,672
80002b34:	49 1c       	lddpc	r12,80002b78 <xSerialPortInitMinimal+0xbc>
80002b36:	f0 1f 00 12 	mcall	80002b7c <xSerialPortInitMinimal+0xc0>

			/* Enable USART interrupt sources (but not Tx for now)... */
			usart->ier = AVR32_USART_IER_RXRDY_MASK;
80002b3a:	30 16       	mov	r6,1
80002b3c:	8f 26       	st.w	r7[0x8],r6

			/* Enable receiver and transmitter... */
			usart->cr |= AVR32_USART_CR_TXEN_MASK | AVR32_USART_CR_RXEN_MASK;
80002b3e:	6e 08       	ld.w	r8,r7[0x0]
80002b40:	e8 18 00 50 	orl	r8,0x50
80002b44:	8f 08       	st.w	r7[0x0],r8
		}
		portEXIT_CRITICAL();
80002b46:	f0 1f 00 0f 	mcall	80002b80 <xSerialPortInitMinimal+0xc4>
80002b4a:	0c 9c       	mov	r12,r6

	/* Create the rx and tx queues. */
	vprvSerialCreateQueues( uxQueueLength, &xRxedChars, &xCharsForTx );

	/* Configure USART. */
	if( ( xRxedChars != serINVALID_QUEUE ) &&
80002b4c:	c0 28       	rjmp	80002b50 <xSerialPortInitMinimal+0x94>
80002b4e:	30 0c       	mov	r12,0
	{
		xReturn = serINVALID_COMPORT_HANDLER;
	}

	return xReturn;
}
80002b50:	2f dd       	sub	sp,-12
80002b52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b56:	00 00       	add	r0,r0
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	68 08       	ld.w	r8,r4[0x0]
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	45 e8       	lddsp	r8,sp[0x178]
80002b60:	00 00       	add	r0,r0
80002b62:	07 1c       	ld.sh	r12,r3++
80002b64:	00 00       	add	r0,r0
80002b66:	07 18       	ld.sh	r8,r3++
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	3f a8       	mov	r8,-6
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	68 14       	ld.w	r4,r4[0x4]
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	22 94       	sub	r4,41
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	26 20       	sub	r0,98
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	2c 1c       	sub	r12,-63
80002b7c:	80 00       	ld.sh	r0,r0[0x0]
80002b7e:	22 c8       	sub	r8,44
80002b80:	80 00       	ld.sh	r0,r0[0x0]
80002b82:	40 b4       	lddsp	r4,sp[0x2c]

80002b84 <prvUSART_ISR_NonNakedBehaviour>:
#elif __ICCAVR32__
	#pragma optimize = no_inline
#endif

static portBASE_TYPE prvUSART_ISR_NonNakedBehaviour( void )
{
80002b84:	eb cd 40 c0 	pushm	r6-r7,lr
80002b88:	20 2d       	sub	sp,8
	/* Now we can declare the local variables. */
	signed portCHAR     cChar;
	portBASE_TYPE     xHigherPriorityTaskWoken = pdFALSE;
80002b8a:	30 08       	mov	r8,0
80002b8c:	50 08       	stdsp	sp[0x0],r8
	unsigned portLONG     ulStatus;
	volatile avr32_usart_t  *usart = serialPORT_USART;
	portBASE_TYPE retstatus;

	/* What caused the interrupt? */
	ulStatus = usart->csr & usart->imr;
80002b8e:	fe 78 2c 00 	mov	r8,-54272
80002b92:	70 59       	ld.w	r9,r8[0x14]
80002b94:	70 47       	ld.w	r7,r8[0x10]
80002b96:	12 67       	and	r7,r9

	if (ulStatus & AVR32_USART_CSR_TXRDY_MASK)
80002b98:	0e 98       	mov	r8,r7
80002b9a:	e2 18 00 02 	andl	r8,0x2,COH
80002b9e:	c1 90       	breq	80002bd0 <prvUSART_ISR_NonNakedBehaviour+0x4c>
	{
		/* The interrupt was caused by the THR becoming empty.  Are there any
		more characters to transmit?
		Because FreeRTOS is not supposed to run with nested interrupts, put all OS
		calls in a critical section . */
		portENTER_CRITICAL();
80002ba0:	f0 1f 00 19 	mcall	80002c04 <prvUSART_ISR_NonNakedBehaviour+0x80>
			retstatus = xQueueReceiveFromISR( xCharsForTx, &cChar, &xHigherPriorityTaskWoken );
80002ba4:	1a 9a       	mov	r10,sp
80002ba6:	fa cb ff f9 	sub	r11,sp,-7
80002baa:	49 88       	lddpc	r8,80002c08 <prvUSART_ISR_NonNakedBehaviour+0x84>
80002bac:	70 0c       	ld.w	r12,r8[0x0]
80002bae:	f0 1f 00 18 	mcall	80002c0c <prvUSART_ISR_NonNakedBehaviour+0x88>
80002bb2:	18 96       	mov	r6,r12
		portEXIT_CRITICAL();
80002bb4:	f0 1f 00 17 	mcall	80002c10 <prvUSART_ISR_NonNakedBehaviour+0x8c>

		if (retstatus == pdTRUE)
80002bb8:	58 16       	cp.w	r6,1
80002bba:	c0 71       	brne	80002bc8 <prvUSART_ISR_NonNakedBehaviour+0x44>
		{
			/* A character was retrieved from the queue so can be sent to the
			 THR now. */
			usart->thr = cChar;
80002bbc:	fb 29 00 07 	ld.sb	r9,sp[7]
80002bc0:	fe 78 2c 00 	mov	r8,-54272
80002bc4:	91 79       	st.w	r8[0x1c],r9
80002bc6:	c0 58       	rjmp	80002bd0 <prvUSART_ISR_NonNakedBehaviour+0x4c>
		}
		else
		{
			/* Queue empty, nothing to send so turn off the Tx interrupt. */
			usart->idr = AVR32_USART_IDR_TXRDY_MASK;
80002bc8:	30 29       	mov	r9,2
80002bca:	fe 78 2c 00 	mov	r8,-54272
80002bce:	91 39       	st.w	r8[0xc],r9
		}
	}

	if (ulStatus & AVR32_USART_CSR_RXRDY_MASK)
80002bd0:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
80002bd4:	c1 10       	breq	80002bf6 <prvUSART_ISR_NonNakedBehaviour+0x72>
	{
		/* The interrupt was caused by the receiver getting data. */
		cChar = usart->rhr; //TODO
80002bd6:	fe 78 2c 00 	mov	r8,-54272
80002bda:	70 68       	ld.w	r8,r8[0x18]
80002bdc:	ba f8       	st.b	sp[0x7],r8

		/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
		calls in a critical section . */
		portENTER_CRITICAL();
80002bde:	f0 1f 00 0a 	mcall	80002c04 <prvUSART_ISR_NonNakedBehaviour+0x80>
			xQueueSendFromISR(xRxedChars, &cChar, &xHigherPriorityTaskWoken);
80002be2:	30 09       	mov	r9,0
80002be4:	1a 9a       	mov	r10,sp
80002be6:	fa cb ff f9 	sub	r11,sp,-7
80002bea:	48 b8       	lddpc	r8,80002c14 <prvUSART_ISR_NonNakedBehaviour+0x90>
80002bec:	70 0c       	ld.w	r12,r8[0x0]
80002bee:	f0 1f 00 0b 	mcall	80002c18 <prvUSART_ISR_NonNakedBehaviour+0x94>
		portEXIT_CRITICAL();
80002bf2:	f0 1f 00 08 	mcall	80002c10 <prvUSART_ISR_NonNakedBehaviour+0x8c>

	/* Using data memory barriers in the IRQ handler to make sure that:
	- the request has been disasserted, and that
	- the (potential) write in the idr has been done 
	... before returning from the handler */
	usart->csr;
80002bf6:	fe 78 2c 00 	mov	r8,-54272
80002bfa:	70 58       	ld.w	r8,r8[0x14]

	/* The return value will be used by portEXIT_SWITCHING_ISR() to know if it
	should perform a vTaskSwitchContext(). */
	return ( xHigherPriorityTaskWoken );
}
80002bfc:	40 0c       	lddsp	r12,sp[0x0]
80002bfe:	2f ed       	sub	sp,-8
80002c00:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	3f a8       	mov	r8,-6
80002c08:	00 00       	add	r0,r0
80002c0a:	07 18       	ld.sh	r8,r3++
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	42 28       	lddsp	r8,sp[0x88]
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	40 b4       	lddsp	r4,sp[0x2c]
80002c14:	00 00       	add	r0,r0
80002c16:	07 1c       	ld.sh	r12,r3++
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	42 dc       	lddsp	r12,sp[0xb4]

80002c1c <vUSART_ISR>:
static void vUSART_ISR( void )
{
	/* This ISR can cause a context switch, so the first statement must be a
	call to the portENTER_SWITCHING_ISR() macro.  This must be BEFORE any
	variable declarations. */
	portENTER_SWITCHING_ISR();
80002c1c:	eb cd 00 ff 	pushm	r0-r7
80002c20:	e0 68 00 2c 	mov	r8,44
80002c24:	ea 18 00 00 	orh	r8,0x0
80002c28:	70 00       	ld.w	r0,r8[0x0]
80002c2a:	1a d0       	st.w	--sp,r0
80002c2c:	7a 90       	ld.w	r0,sp[0x24]
80002c2e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002c32:	58 10       	cp.w	r0,1
80002c34:	e0 8b 00 08 	brhi	80002c44 <LABEL_ISR_SKIP_SAVE_CONTEXT_167>
80002c38:	e0 68 08 8c 	mov	r8,2188
80002c3c:	ea 18 00 00 	orh	r8,0x0
80002c40:	70 00       	ld.w	r0,r8[0x0]
80002c42:	81 0d       	st.w	r0[0x0],sp

80002c44 <LABEL_ISR_SKIP_SAVE_CONTEXT_167>:

	prvUSART_ISR_NonNakedBehaviour();
80002c44:	f0 1f 00 10 	mcall	80002c84 <LABEL_ISR_SKIP_RESTORE_CONTEXT_173+0x14>

	/* Exit the ISR.  If a task was woken by either a character being received
	or transmitted then a context switch will occur. */
	portEXIT_SWITCHING_ISR();
80002c48:	7a 90       	ld.w	r0,sp[0x24]
80002c4a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002c4e:	58 10       	cp.w	r0,1
80002c50:	e0 8b 00 10 	brhi	80002c70 <LABEL_ISR_SKIP_RESTORE_CONTEXT_173>
80002c54:	58 1c       	cp.w	r12,1
80002c56:	c0 71       	brne	80002c64 <LABEL_ISR_RESTORE_CONTEXT_173>
80002c58:	f0 1f 00 0c 	mcall	80002c88 <LABEL_ISR_SKIP_RESTORE_CONTEXT_173+0x18>
80002c5c:	f0 1f 00 0c 	mcall	80002c8c <LABEL_ISR_SKIP_RESTORE_CONTEXT_173+0x1c>
80002c60:	f0 1f 00 0c 	mcall	80002c90 <LABEL_ISR_SKIP_RESTORE_CONTEXT_173+0x20>

80002c64 <LABEL_ISR_RESTORE_CONTEXT_173>:
80002c64:	e0 68 08 8c 	mov	r8,2188
80002c68:	ea 18 00 00 	orh	r8,0x0
80002c6c:	70 00       	ld.w	r0,r8[0x0]
80002c6e:	60 0d       	ld.w	sp,r0[0x0]

80002c70 <LABEL_ISR_SKIP_RESTORE_CONTEXT_173>:
80002c70:	1b 00       	ld.w	r0,sp++
80002c72:	e0 68 00 2c 	mov	r8,44
80002c76:	ea 18 00 00 	orh	r8,0x0
80002c7a:	91 00       	st.w	r8[0x0],r0
80002c7c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002c80:	d6 03       	rete
80002c82:	00 00       	add	r0,r0
80002c84:	80 00       	ld.sh	r0,r0[0x0]
80002c86:	2b 84       	sub	r4,-72
80002c88:	80 00       	ld.sh	r0,r0[0x0]
80002c8a:	3f a8       	mov	r8,-6
80002c8c:	80 00       	ld.sh	r0,r0[0x0]
80002c8e:	46 98       	lddsp	r8,sp[0x1a4]
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	40 b4       	lddsp	r4,sp[0x2c]

80002c94 <xAreBlockingQueuesStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreBlockingQueuesStillRunning( void )
{
80002c94:	eb cd 40 c0 	pushm	r6-r7,lr
80002c98:	49 0a       	lddpc	r10,80002cd8 <xAreBlockingQueuesStillRunning+0x44>
80002c9a:	49 19       	lddpc	r9,80002cdc <xAreBlockingQueuesStillRunning+0x48>
80002c9c:	30 08       	mov	r8,0
80002c9e:	30 1c       	mov	r12,1
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
80002ca0:	49 06       	lddpc	r6,80002ce0 <xAreBlockingQueuesStillRunning+0x4c>
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
80002ca2:	49 17       	lddpc	r7,80002ce4 <xAreBlockingQueuesStillRunning+0x50>
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
80002ca4:	ec 08 04 1b 	ld.sh	r11,r6[r8<<0x1]
80002ca8:	94 0e       	ld.sh	lr,r10[0x0]
80002caa:	f6 0e 19 00 	cp.h	lr,r11
80002cae:	f9 bc 00 00 	moveq	r12,0
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
80002cb2:	ec 08 04 1b 	ld.sh	r11,r6[r8<<0x1]
80002cb6:	14 bb       	st.h	r10++,r11


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
80002cb8:	ee 08 04 1b 	ld.sh	r11,r7[r8<<0x1]
80002cbc:	92 0e       	ld.sh	lr,r9[0x0]
80002cbe:	f6 0e 19 00 	cp.h	lr,r11
80002cc2:	f9 bc 00 00 	moveq	r12,0
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
80002cc6:	ee 08 04 1b 	ld.sh	r11,r7[r8<<0x1]
80002cca:	12 bb       	st.h	r9++,r11
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
80002ccc:	2f f8       	sub	r8,-1
80002cce:	58 38       	cp.w	r8,3
80002cd0:	ce a1       	brne	80002ca4 <xAreBlockingQueuesStillRunning+0x10>
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
}
80002cd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cd6:	00 00       	add	r0,r0
80002cd8:	00 00       	add	r0,r0
80002cda:	07 26       	ld.uh	r6,r3++
80002cdc:	00 00       	add	r0,r0
80002cde:	07 32       	ld.ub	r2,r3++
80002ce0:	00 00       	add	r0,r0
80002ce2:	07 2c       	ld.uh	r12,r3++
80002ce4:	00 00       	add	r0,r0
80002ce6:	07 20       	ld.uh	r0,r3++

80002ce8 <vStartBlockingQueueTasks>:
static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };

/*-----------------------------------------------------------*/

void vStartBlockingQueueTasks( unsigned portBASE_TYPE uxPriority )
{
80002ce8:	d4 31       	pushm	r0-r7,lr
80002cea:	20 1d       	sub	sp,4
80002cec:	50 0c       	stdsp	sp[0x0],r12
const portTickType xDontBlock = ( portTickType ) 0;

	/* Create the first two tasks as described at the top of the file. */

	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80002cee:	30 cc       	mov	r12,12
80002cf0:	f0 1f 00 46 	mcall	80002e08 <vStartBlockingQueueTasks+0x120>
80002cf4:	18 96       	mov	r6,r12

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80002cf6:	30 2b       	mov	r11,2
80002cf8:	30 1c       	mov	r12,1
80002cfa:	f0 1f 00 45 	mcall	80002e0c <vStartBlockingQueueTasks+0x124>
80002cfe:	8d 0c       	st.w	r6[0x0],r12

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
80002d00:	e0 64 03 e8 	mov	r4,1000
80002d04:	8d 14       	st.w	r6[0x4],r4

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
80002d06:	4c 31       	lddpc	r1,80002e10 <vStartBlockingQueueTasks+0x128>
80002d08:	8d 21       	st.w	r6[0x8],r1

	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80002d0a:	30 cc       	mov	r12,12
80002d0c:	f0 1f 00 3f 	mcall	80002e08 <vStartBlockingQueueTasks+0x120>
80002d10:	18 95       	mov	r5,r12

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
80002d12:	6c 08       	ld.w	r8,r6[0x0]
80002d14:	99 08       	st.w	r12[0x0],r8

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
80002d16:	30 07       	mov	r7,0
80002d18:	99 17       	st.w	r12[0x4],r7

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
80002d1a:	4b f3       	lddpc	r3,80002e14 <vStartBlockingQueueTasks+0x12c>
80002d1c:	99 23       	st.w	r12[0x8],r3


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
80002d1e:	4b f0       	lddpc	r0,80002e18 <vStartBlockingQueueTasks+0x130>
80002d20:	1a d7       	st.w	--sp,r7
80002d22:	1a d7       	st.w	--sp,r7
80002d24:	1a d7       	st.w	--sp,r7
80002d26:	40 38       	lddsp	r8,sp[0xc]
80002d28:	0c 99       	mov	r9,r6
80002d2a:	e0 6a 01 00 	mov	r10,256
80002d2e:	4b cb       	lddpc	r11,80002e1c <vStartBlockingQueueTasks+0x134>
80002d30:	00 9c       	mov	r12,r0
80002d32:	f0 1f 00 3c 	mcall	80002e20 <vStartBlockingQueueTasks+0x138>
	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
80002d36:	4b c2       	lddpc	r2,80002e24 <vStartBlockingQueueTasks+0x13c>
80002d38:	1a d7       	st.w	--sp,r7
80002d3a:	1a d7       	st.w	--sp,r7
80002d3c:	1a d7       	st.w	--sp,r7
80002d3e:	0e 98       	mov	r8,r7
80002d40:	0a 99       	mov	r9,r5
80002d42:	e0 6a 01 00 	mov	r10,256
80002d46:	4b 9b       	lddpc	r11,80002e28 <vStartBlockingQueueTasks+0x140>
80002d48:	04 9c       	mov	r12,r2
80002d4a:	f0 1f 00 36 	mcall	80002e20 <vStartBlockingQueueTasks+0x138>


	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80002d4e:	30 cc       	mov	r12,12
80002d50:	f0 1f 00 2e 	mcall	80002e08 <vStartBlockingQueueTasks+0x120>
80002d54:	18 96       	mov	r6,r12
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80002d56:	30 2b       	mov	r11,2
80002d58:	30 1c       	mov	r12,1
80002d5a:	f0 1f 00 2d 	mcall	80002e0c <vStartBlockingQueueTasks+0x124>
80002d5e:	8d 0c       	st.w	r6[0x0],r12
	pxQueueParameters3->xBlockTime = xDontBlock;
80002d60:	8d 17       	st.w	r6[0x4],r7
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
80002d62:	e6 c8 ff fe 	sub	r8,r3,-2
80002d66:	8d 28       	st.w	r6[0x8],r8

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80002d68:	30 cc       	mov	r12,12
80002d6a:	f0 1f 00 28 	mcall	80002e08 <vStartBlockingQueueTasks+0x120>
80002d6e:	18 95       	mov	r5,r12
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
80002d70:	6c 08       	ld.w	r8,r6[0x0]
80002d72:	99 08       	st.w	r12[0x0],r8
	pxQueueParameters4->xBlockTime = xBlockTime;
80002d74:	99 14       	st.w	r12[0x4],r4
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
80002d76:	e2 c8 ff fe 	sub	r8,r1,-2
80002d7a:	99 28       	st.w	r12[0x8],r8

	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QProdB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
80002d7c:	1a d7       	st.w	--sp,r7
80002d7e:	1a d7       	st.w	--sp,r7
80002d80:	1a d7       	st.w	--sp,r7
80002d82:	0e 98       	mov	r8,r7
80002d84:	0c 99       	mov	r9,r6
80002d86:	e0 6a 01 00 	mov	r10,256
80002d8a:	4a 9b       	lddpc	r11,80002e2c <vStartBlockingQueueTasks+0x144>
80002d8c:	00 9c       	mov	r12,r0
80002d8e:	f0 1f 00 25 	mcall	80002e20 <vStartBlockingQueueTasks+0x138>
	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QConsB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
80002d92:	2f 7d       	sub	sp,-36
80002d94:	1a d7       	st.w	--sp,r7
80002d96:	1a d7       	st.w	--sp,r7
80002d98:	1a d7       	st.w	--sp,r7
80002d9a:	40 38       	lddsp	r8,sp[0xc]
80002d9c:	0a 99       	mov	r9,r5
80002d9e:	e0 6a 01 00 	mov	r10,256
80002da2:	4a 4b       	lddpc	r11,80002e30 <vStartBlockingQueueTasks+0x148>
80002da4:	04 9c       	mov	r12,r2
80002da6:	f0 1f 00 1f 	mcall	80002e20 <vStartBlockingQueueTasks+0x138>



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80002daa:	30 cc       	mov	r12,12
80002dac:	f0 1f 00 17 	mcall	80002e08 <vStartBlockingQueueTasks+0x120>
80002db0:	18 96       	mov	r6,r12
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80002db2:	30 2b       	mov	r11,2
80002db4:	30 5c       	mov	r12,5
80002db6:	f0 1f 00 16 	mcall	80002e0c <vStartBlockingQueueTasks+0x124>
80002dba:	8d 0c       	st.w	r6[0x0],r12
	pxQueueParameters5->xBlockTime = xBlockTime;
80002dbc:	8d 14       	st.w	r6[0x4],r4
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
80002dbe:	2f c3       	sub	r3,-4
80002dc0:	8d 23       	st.w	r6[0x8],r3

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80002dc2:	30 cc       	mov	r12,12
80002dc4:	f0 1f 00 11 	mcall	80002e08 <vStartBlockingQueueTasks+0x120>
80002dc8:	18 95       	mov	r5,r12
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
80002dca:	6c 08       	ld.w	r8,r6[0x0]
80002dcc:	99 08       	st.w	r12[0x0],r8
	pxQueueParameters6->xBlockTime = xBlockTime;
80002dce:	99 14       	st.w	r12[0x4],r4
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
80002dd0:	2f c1       	sub	r1,-4
80002dd2:	99 21       	st.w	r12[0x8],r1

	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
80002dd4:	1a d7       	st.w	--sp,r7
80002dd6:	1a d7       	st.w	--sp,r7
80002dd8:	1a d7       	st.w	--sp,r7
80002dda:	0e 98       	mov	r8,r7
80002ddc:	0c 99       	mov	r9,r6
80002dde:	e0 6a 01 00 	mov	r10,256
80002de2:	49 5b       	lddpc	r11,80002e34 <vStartBlockingQueueTasks+0x14c>
80002de4:	04 9c       	mov	r12,r2
80002de6:	f0 1f 00 0f 	mcall	80002e20 <vStartBlockingQueueTasks+0x138>
	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
80002dea:	1a d7       	st.w	--sp,r7
80002dec:	1a d7       	st.w	--sp,r7
80002dee:	1a d7       	st.w	--sp,r7
80002df0:	0e 98       	mov	r8,r7
80002df2:	0a 99       	mov	r9,r5
80002df4:	e0 6a 01 00 	mov	r10,256
80002df8:	49 0b       	lddpc	r11,80002e38 <vStartBlockingQueueTasks+0x150>
80002dfa:	00 9c       	mov	r12,r0
80002dfc:	f0 1f 00 09 	mcall	80002e20 <vStartBlockingQueueTasks+0x138>
80002e00:	2f 7d       	sub	sp,-36
}
80002e02:	2f fd       	sub	sp,-4
80002e04:	d8 32       	popm	r0-r7,pc
80002e06:	00 00       	add	r0,r0
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	41 b0       	lddsp	r0,sp[0x6c]
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	45 e8       	lddsp	r8,sp[0x178]
80002e10:	00 00       	add	r0,r0
80002e12:	07 2c       	ld.uh	r12,r3++
80002e14:	00 00       	add	r0,r0
80002e16:	07 20       	ld.uh	r0,r3++
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2e 80       	sub	r0,-24
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	68 24       	ld.w	r4,r4[0x8]
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	4e c0       	lddpc	r0,80002fd0 <vComRxTask+0x8c>
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	2e 3c       	sub	r12,-29
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	68 2c       	ld.w	r12,r4[0x8]
80002e2c:	80 00       	ld.sh	r0,r0[0x0]
80002e2e:	68 34       	ld.w	r4,r4[0xc]
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	68 3c       	ld.w	r12,r4[0xc]
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	68 44       	ld.w	r4,r4[0x10]
80002e38:	80 00       	ld.sh	r0,r0[0x0]
80002e3a:	68 4c       	ld.w	r12,r4[0x10]

80002e3c <vBlockingQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
{
80002e3c:	eb cd 40 f8 	pushm	r3-r7,lr
80002e40:	20 1d       	sub	sp,4
unsigned short usValue = 0;
80002e42:	fa c7 ff fc 	sub	r7,sp,-4
80002e46:	30 08       	mov	r8,0
80002e48:	0e e8       	st.h	--r7,r8
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
80002e4a:	18 96       	mov	r6,r12
80002e4c:	30 05       	mov	r5,0

	for( ;; )
	{
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
80002e4e:	0a 94       	mov	r4,r5
80002e50:	30 13       	mov	r3,1
80002e52:	08 99       	mov	r9,r4
80002e54:	6c 1a       	ld.w	r10,r6[0x4]
80002e56:	0e 9b       	mov	r11,r7
80002e58:	6c 0c       	ld.w	r12,r6[0x0]
80002e5a:	f0 1f 00 09 	mcall	80002e7c <vBlockingQueueProducer+0x40>
80002e5e:	58 1c       	cp.w	r12,1
80002e60:	c0 30       	breq	80002e66 <vBlockingQueueProducer+0x2a>
80002e62:	06 95       	mov	r5,r3
80002e64:	cf 7b       	rjmp	80002e52 <vBlockingQueueProducer+0x16>
		}
		else
		{
			/* We have successfully posted a message, so increment the variable
			used to check we are still running. */
			if( sErrorEverOccurred == pdFALSE )
80002e66:	58 05       	cp.w	r5,0
80002e68:	c0 51       	brne	80002e72 <vBlockingQueueProducer+0x36>
			{
				( *pxQueueParameters->psCheckVariable )++;
80002e6a:	6c 28       	ld.w	r8,r6[0x8]
80002e6c:	90 09       	ld.sh	r9,r8[0x0]
80002e6e:	2f f9       	sub	r9,-1
80002e70:	b0 09       	st.h	r8[0x0],r9
			}

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
80002e72:	9a 18       	ld.sh	r8,sp[0x2]
80002e74:	2f f8       	sub	r8,-1
80002e76:	ba 18       	st.h	sp[0x2],r8
80002e78:	ce db       	rjmp	80002e52 <vBlockingQueueProducer+0x16>
80002e7a:	00 00       	add	r0,r0
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	44 e8       	lddsp	r8,sp[0x138]

80002e80 <vBlockingQueueConsumer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
80002e80:	eb cd 40 fc 	pushm	r2-r7,lr
80002e84:	20 1d       	sub	sp,4
80002e86:	18 97       	mov	r7,r12
unsigned short usData, usExpectedValue = 0;
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
80002e88:	30 03       	mov	r3,0
80002e8a:	06 94       	mov	r4,r3

	for( ;; )
	{
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
80002e8c:	fa c6 ff fe 	sub	r6,sp,-2
80002e90:	06 95       	mov	r5,r3
		{
			if( usData != usExpectedValue )
80002e92:	30 12       	mov	r2,1

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;

	for( ;; )
	{
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
80002e94:	0a 99       	mov	r9,r5
80002e96:	6e 1a       	ld.w	r10,r7[0x4]
80002e98:	0c 9b       	mov	r11,r6
80002e9a:	6e 0c       	ld.w	r12,r7[0x0]
80002e9c:	f0 1f 00 0b 	mcall	80002ec8 <vBlockingQueueConsumer+0x48>
80002ea0:	58 1c       	cp.w	r12,1
80002ea2:	cf 91       	brne	80002e94 <vBlockingQueueConsumer+0x14>
		{
			if( usData != usExpectedValue )
80002ea4:	9a 18       	ld.sh	r8,sp[0x2]
80002ea6:	f0 04 19 00 	cp.h	r4,r8
80002eaa:	c0 50       	breq	80002eb4 <vBlockingQueueConsumer+0x34>
80002eac:	e9 d8 b0 10 	bfexts	r4,r8,0x0,0x10
80002eb0:	04 93       	mov	r3,r2
80002eb2:	cf 1b       	rjmp	80002e94 <vBlockingQueueConsumer+0x14>
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */
				if( sErrorEverOccurred == pdFALSE )
80002eb4:	58 03       	cp.w	r3,0
80002eb6:	c0 51       	brne	80002ec0 <vBlockingQueueConsumer+0x40>
				{
					( *pxQueueParameters->psCheckVariable )++;
80002eb8:	6e 28       	ld.w	r8,r7[0x8]
80002eba:	90 09       	ld.sh	r9,r8[0x0]
80002ebc:	2f f9       	sub	r9,-1
80002ebe:	b0 09       	st.h	r8[0x0],r9
				}

				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
80002ec0:	2f f4       	sub	r4,-1
80002ec2:	5c 84       	casts.h	r4
80002ec4:	ce 8b       	rjmp	80002e94 <vBlockingQueueConsumer+0x14>
80002ec6:	00 00       	add	r0,r0
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	43 cc       	lddsp	r12,sp[0xf0]

80002ecc <xAreComTestTasksStillRunning>:
portBASE_TYPE xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
80002ecc:	48 48       	lddpc	r8,80002edc <xAreComTestTasksStillRunning+0x10>
80002ece:	70 09       	ld.w	r9,r8[0x0]
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
80002ed0:	30 0a       	mov	r10,0
80002ed2:	91 0a       	st.w	r8[0x0],r10
80002ed4:	58 09       	cp.w	r9,0

	return xReturn;
}
80002ed6:	5f 1c       	srne	r12
80002ed8:	5e fc       	retal	r12
80002eda:	00 00       	add	r0,r0
80002edc:	00 00       	add	r0,r0
80002ede:	07 38       	ld.ub	r8,r3++

80002ee0 <vAltStartComTestTasks>:
static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
80002ee0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ee4:	18 96       	mov	r6,r12
80002ee6:	16 9c       	mov	r12,r11
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
80002ee8:	49 08       	lddpc	r8,80002f28 <vAltStartComTestTasks+0x48>
80002eea:	91 0a       	st.w	r8[0x0],r10
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
80002eec:	31 8b       	mov	r11,24
80002eee:	f0 1f 00 10 	mcall	80002f2c <vAltStartComTestTasks+0x4c>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, ( signed char * ) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
80002ef2:	30 07       	mov	r7,0
80002ef4:	1a d7       	st.w	--sp,r7
80002ef6:	1a d7       	st.w	--sp,r7
80002ef8:	1a d7       	st.w	--sp,r7
80002efa:	ec c8 00 01 	sub	r8,r6,1
80002efe:	0e 99       	mov	r9,r7
80002f00:	e0 6a 01 00 	mov	r10,256
80002f04:	48 bb       	lddpc	r11,80002f30 <vAltStartComTestTasks+0x50>
80002f06:	48 cc       	lddpc	r12,80002f34 <vAltStartComTestTasks+0x54>
80002f08:	f0 1f 00 0c 	mcall	80002f38 <vAltStartComTestTasks+0x58>
	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
80002f0c:	1a d7       	st.w	--sp,r7
80002f0e:	1a d7       	st.w	--sp,r7
80002f10:	1a d7       	st.w	--sp,r7
80002f12:	0c 98       	mov	r8,r6
80002f14:	0e 99       	mov	r9,r7
80002f16:	e0 6a 01 00 	mov	r10,256
80002f1a:	48 9b       	lddpc	r11,80002f3c <vAltStartComTestTasks+0x5c>
80002f1c:	48 9c       	lddpc	r12,80002f40 <vAltStartComTestTasks+0x60>
80002f1e:	f0 1f 00 07 	mcall	80002f38 <vAltStartComTestTasks+0x58>
80002f22:	2f ad       	sub	sp,-24
}
80002f24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f28:	00 00       	add	r0,r0
80002f2a:	07 3c       	ld.ub	r12,r3++
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	2a bc       	sub	r12,-85
80002f30:	80 00       	ld.sh	r0,r0[0x0]
80002f32:	68 54       	ld.w	r4,r4[0x14]
80002f34:	80 00       	ld.sh	r0,r0[0x0]
80002f36:	2f e4       	sub	r4,-2
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	4e c0       	lddpc	r0,800030e8 <vCreateSuicidalTasks+0x28>
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	68 5c       	ld.w	r12,r4[0x14]
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2f 44       	sub	r4,-12

80002f44 <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
80002f44:	d4 31       	pushm	r0-r7,lr
80002f46:	20 1d       	sub	sp,4
80002f48:	30 00       	mov	r0,0
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
80002f4a:	4a 24       	lddpc	r4,80002fd0 <vComRxTask+0x8c>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
80002f4c:	35 96       	mov	r6,89
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
80002f4e:	fa c5 ff fd 	sub	r5,sp,-3
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
80002f52:	35 81       	mov	r1,88
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
80002f54:	34 17       	mov	r7,65
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
80002f56:	e0 63 ff ff 	mov	r3,65535
80002f5a:	30 02       	mov	r2,0
80002f5c:	06 9a       	mov	r10,r3
80002f5e:	0a 9b       	mov	r11,r5
80002f60:	04 9c       	mov	r12,r2
80002f62:	f0 1f 00 1d 	mcall	80002fd4 <vComRxTask+0x90>
80002f66:	c0 90       	breq	80002f78 <vComRxTask+0x34>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
80002f68:	1b b8       	ld.ub	r8,sp[0x3]
80002f6a:	ee 08 18 00 	cp.b	r8,r7
80002f6e:	c2 61       	brne	80002fba <vComRxTask+0x76>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
80002f70:	68 0c       	ld.w	r12,r4[0x0]
80002f72:	2f fc       	sub	r12,-1
80002f74:	f0 1f 00 19 	mcall	80002fd8 <vComRxTask+0x94>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
80002f78:	2f f7       	sub	r7,-1
80002f7a:	5c 57       	castu.b	r7
80002f7c:	ec 07 18 00 	cp.b	r7,r6
80002f80:	ce e1       	brne	80002f5c <vComRxTask+0x18>
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
80002f82:	68 0c       	ld.w	r12,r4[0x0]
80002f84:	30 0b       	mov	r11,0
80002f86:	2f fc       	sub	r12,-1
80002f88:	f0 1f 00 15 	mcall	80002fdc <vComRxTask+0x98>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
80002f8c:	58 10       	cp.w	r0,1
80002f8e:	fe 99 ff e3 	brgt	80002f54 <vComRxTask+0x10>
80002f92:	c0 f8       	rjmp	80002fb0 <vComRxTask+0x6c>
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
80002f94:	e0 67 ff ff 	mov	r7,65535
80002f98:	30 03       	mov	r3,0
80002f9a:	0e 9a       	mov	r10,r7
80002f9c:	0a 9b       	mov	r11,r5
80002f9e:	06 9c       	mov	r12,r3
80002fa0:	f0 1f 00 0d 	mcall	80002fd4 <vComRxTask+0x90>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
80002fa4:	1b b8       	ld.ub	r8,sp[0x3]
80002fa6:	e2 08 18 00 	cp.b	r8,r1
80002faa:	cf 81       	brne	80002f9a <vComRxTask+0x56>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
80002fac:	2f f0       	sub	r0,-1
80002fae:	cd 3b       	rjmp	80002f54 <vComRxTask+0x10>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
80002fb0:	48 c8       	lddpc	r8,80002fe0 <vComRxTask+0x9c>
80002fb2:	70 09       	ld.w	r9,r8[0x0]
80002fb4:	2f f9       	sub	r9,-1
80002fb6:	91 09       	st.w	r8[0x0],r9
80002fb8:	cc eb       	rjmp	80002f54 <vComRxTask+0x10>
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
80002fba:	68 0c       	ld.w	r12,r4[0x0]
80002fbc:	30 0b       	mov	r11,0
80002fbe:	2f fc       	sub	r12,-1
80002fc0:	f0 1f 00 07 	mcall	80002fdc <vComRxTask+0x98>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
80002fc4:	1b b8       	ld.ub	r8,sp[0x3]
80002fc6:	e2 08 18 00 	cp.b	r8,r1
80002fca:	ce 51       	brne	80002f94 <vComRxTask+0x50>
80002fcc:	cf 0b       	rjmp	80002fac <vComRxTask+0x68>
80002fce:	00 00       	add	r0,r0
80002fd0:	00 00       	add	r0,r0
80002fd2:	07 3c       	ld.ub	r12,r3++
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	2a a4       	sub	r4,-86
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	29 e0       	sub	r0,-98
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	2a 20       	sub	r0,-94
80002fe0:	00 00       	add	r0,r0
80002fe2:	07 38       	ld.ub	r8,r3++

80002fe4 <vComTxTask>:
	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
80002fe4:	eb cd 40 fe 	pushm	r1-r7,lr
80002fe8:	34 17       	mov	r7,65

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
80002fea:	35 86       	mov	r6,88
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
80002fec:	30 05       	mov	r5,0
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
80002fee:	49 94       	lddpc	r4,80003050 <vComTxTask+0x6c>
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
80002ff0:	e0 63 81 b5 	mov	r3,33205
80002ff4:	ea 13 1b 4e 	orh	r3,0x1b4e
80002ff8:	e0 62 00 96 	mov	r2,150
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
		}

		vTaskDelay( xTimeToWait );
80002ffc:	0e 91       	mov	r1,r7
80002ffe:	c0 e8       	rjmp	8000301a <vComTxTask+0x36>
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
80003000:	0a 9a       	mov	r10,r5
80003002:	0e 9b       	mov	r11,r7
80003004:	5c 6b       	casts.b	r11
80003006:	0a 9c       	mov	r12,r5
80003008:	f0 1f 00 13 	mcall	80003054 <vComTxTask+0x70>
8000300c:	58 1c       	cp.w	r12,1
8000300e:	c0 41       	brne	80003016 <vComTxTask+0x32>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
80003010:	68 0c       	ld.w	r12,r4[0x0]
80003012:	f0 1f 00 12 	mcall	80003058 <vComTxTask+0x74>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
80003016:	2f f7       	sub	r7,-1
80003018:	5c 57       	castu.b	r7
8000301a:	ec 07 18 00 	cp.b	r7,r6
8000301e:	fe 9a ff f1 	brle	80003000 <vComTxTask+0x1c>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
80003022:	0a 9b       	mov	r11,r5
80003024:	68 0c       	ld.w	r12,r4[0x0]
80003026:	f0 1f 00 0e 	mcall	8000305c <vComTxTask+0x78>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
8000302a:	f0 1f 00 0e 	mcall	80003060 <vComTxTask+0x7c>
8000302e:	f8 c8 ff fd 	sub	r8,r12,-3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
80003032:	f0 03 06 4a 	mulu.d	r10,r8,r3
80003036:	f6 0c 16 04 	lsr	r12,r11,0x4
8000303a:	a5 3c       	mul	r12,r2
8000303c:	f0 0c 01 0c 	sub	r12,r8,r12
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
		}

		vTaskDelay( xTimeToWait );
80003040:	e0 4c 00 31 	cp.w	r12,49
80003044:	f9 bc 08 32 	movls	r12,50
80003048:	f0 1f 00 07 	mcall	80003064 <vComTxTask+0x80>
8000304c:	02 97       	mov	r7,r1
8000304e:	ce 6b       	rjmp	8000301a <vComTxTask+0x36>
80003050:	00 00       	add	r0,r0
80003052:	07 3c       	ld.ub	r12,r3++
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	2a 74       	sub	r4,-89
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	29 e0       	sub	r0,-98
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	2a 20       	sub	r0,-94
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	47 a8       	lddsp	r8,sp[0x1e8]
80003064:	80 00       	ld.sh	r0,r0[0x0]
80003066:	4d 20       	lddpc	r0,800031ac <vSuicidalTask+0x24>

80003068 <xIsCreateTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that the creator task is still running and that there
are not any more than four extra tasks. */
portBASE_TYPE xIsCreateTaskStillRunning( void )
{
80003068:	eb cd 40 80 	pushm	r7,lr
static unsigned short usLastCreationCount = 0xfff;
portBASE_TYPE xReturn = pdTRUE;
static unsigned portBASE_TYPE uxTasksRunningNow;

	if( usLastCreationCount == usCreationCount )
8000306c:	49 08       	lddpc	r8,800030ac <xIsCreateTaskStillRunning+0x44>
8000306e:	90 08       	ld.sh	r8,r8[0x0]
80003070:	49 09       	lddpc	r9,800030b0 <xIsCreateTaskStillRunning+0x48>
80003072:	92 09       	ld.sh	r9,r9[0x0]
80003074:	f0 09 19 00 	cp.h	r9,r8
80003078:	c0 31       	brne	8000307e <xIsCreateTaskStillRunning+0x16>
8000307a:	30 07       	mov	r7,0
8000307c:	c0 68       	rjmp	80003088 <xIsCreateTaskStillRunning+0x20>
	{
		xReturn = pdFALSE;
	}
	else
	{
		usLastCreationCount = usCreationCount;
8000307e:	48 c8       	lddpc	r8,800030ac <xIsCreateTaskStillRunning+0x44>
80003080:	90 09       	ld.sh	r9,r8[0x0]
80003082:	48 c8       	lddpc	r8,800030b0 <xIsCreateTaskStillRunning+0x48>
80003084:	b0 09       	st.h	r8[0x0],r9
80003086:	30 17       	mov	r7,1
	}

	uxTasksRunningNow = ( unsigned portBASE_TYPE ) uxTaskGetNumberOfTasks();
80003088:	f0 1f 00 0b 	mcall	800030b4 <xIsCreateTaskStillRunning+0x4c>
8000308c:	48 b8       	lddpc	r8,800030b8 <xIsCreateTaskStillRunning+0x50>
8000308e:	91 0c       	st.w	r8[0x0],r12

	if( uxTasksRunningNow < uxTasksRunningAtStart )
80003090:	48 b8       	lddpc	r8,800030bc <xIsCreateTaskStillRunning+0x54>
80003092:	70 08       	ld.w	r8,r8[0x0]
80003094:	10 3c       	cp.w	r12,r8
80003096:	c0 73       	brcs	800030a4 <xIsCreateTaskStillRunning+0x3c>
	{
		xReturn = pdFALSE;
	}
	else if( ( uxTasksRunningNow - uxTasksRunningAtStart ) > uxMaxNumberOfExtraTasksRunning )
80003098:	48 98       	lddpc	r8,800030bc <xIsCreateTaskStillRunning+0x54>
8000309a:	70 08       	ld.w	r8,r8[0x0]
8000309c:	10 1c       	sub	r12,r8
8000309e:	58 2c       	cp.w	r12,2
800030a0:	e0 88 00 03 	brls	800030a6 <xIsCreateTaskStillRunning+0x3e>
800030a4:	30 07       	mov	r7,0
	{
		/* Everything is okay. */
	}

	return xReturn;
}
800030a6:	0e 9c       	mov	r12,r7
800030a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800030ac:	00 00       	add	r0,r0
800030ae:	07 44       	ld.w	r4,--r3
800030b0:	00 00       	add	r0,r0
800030b2:	00 28       	rsub	r8,r0
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	46 8c       	lddsp	r12,sp[0x1a0]
800030b8:	00 00       	add	r0,r0
800030ba:	07 40       	ld.w	r0,--r3
800030bc:	00 00       	add	r0,r0
800030be:	07 48       	ld.w	r8,--r3

800030c0 <vCreateSuicidalTasks>:
xTaskHandle xCreatedTask;

/*-----------------------------------------------------------*/

void vCreateSuicidalTasks( unsigned portBASE_TYPE uxPriority )
{
800030c0:	eb cd 40 80 	pushm	r7,lr
800030c4:	18 97       	mov	r7,r12
unsigned portBASE_TYPE *puxPriority;

	/* Create the Creator tasks - passing in as a parameter the priority at which
	the suicidal tasks should be created. */
	puxPriority = ( unsigned portBASE_TYPE * ) pvPortMalloc( sizeof( unsigned portBASE_TYPE ) );
800030c6:	30 4c       	mov	r12,4
800030c8:	f0 1f 00 0d 	mcall	800030fc <vCreateSuicidalTasks+0x3c>
800030cc:	18 99       	mov	r9,r12
	*puxPriority = uxPriority;
800030ce:	99 07       	st.w	r12[0x0],r7

	xTaskCreate( vCreateTasks, ( signed char * ) "CREATOR", deathSTACK_SIZE, ( void * ) puxPriority, uxPriority, NULL );
800030d0:	30 08       	mov	r8,0
800030d2:	1a d8       	st.w	--sp,r8
800030d4:	1a d8       	st.w	--sp,r8
800030d6:	1a d8       	st.w	--sp,r8
800030d8:	0e 98       	mov	r8,r7
800030da:	e0 6a 01 3c 	mov	r10,316
800030de:	48 9b       	lddpc	r11,80003100 <vCreateSuicidalTasks+0x40>
800030e0:	48 9c       	lddpc	r12,80003104 <vCreateSuicidalTasks+0x44>
800030e2:	f0 1f 00 0a 	mcall	80003108 <vCreateSuicidalTasks+0x48>

	/* Record the number of tasks that are running now so we know if any of the
	suicidal tasks have failed to be killed. */
	uxTasksRunningAtStart = ( unsigned portBASE_TYPE ) uxTaskGetNumberOfTasks();
800030e6:	f0 1f 00 0a 	mcall	8000310c <vCreateSuicidalTasks+0x4c>
800030ea:	48 a8       	lddpc	r8,80003110 <vCreateSuicidalTasks+0x50>
800030ec:	91 0c       	st.w	r8[0x0],r12
	/* FreeRTOS.org versions before V3.0 started the idle-task as the very
	first task. The idle task was then already included in uxTasksRunningAtStart.
	From FreeRTOS V3.0 on, the idle task is started when the scheduler is
	started. Therefore the idle task is not yet accounted for. We correct
	this by increasing uxTasksRunningAtStart by 1. */
	uxTasksRunningAtStart++;
800030ee:	70 09       	ld.w	r9,r8[0x0]
800030f0:	2f f9       	sub	r9,-1
800030f2:	91 09       	st.w	r8[0x0],r9
800030f4:	2f dd       	sub	sp,-12
}
800030f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800030fa:	00 00       	add	r0,r0
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	41 b0       	lddsp	r0,sp[0x6c]
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	68 64       	ld.w	r4,r4[0x18]
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	31 14       	mov	r4,17
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	4e c0       	lddpc	r0,800032b8 <vStartDynamicPriorityTasks+0x68>
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	46 8c       	lddsp	r12,sp[0x1a0]
80003110:	00 00       	add	r0,r0
80003112:	07 48       	ld.w	r8,--r3

80003114 <vCreateTasks>:
	}
}/*lint !e818 !e550 Function prototype must be as per standard for task functions. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCreateTasks, pvParameters )
{
80003114:	d4 31       	pushm	r0-r7,lr
const portTickType xDelay = ( portTickType ) 1000 / portTICK_RATE_MS;
unsigned portBASE_TYPE uxPriority;

	uxPriority = *( unsigned portBASE_TYPE * ) pvParameters;
80003116:	78 05       	ld.w	r5,r12[0x0]
	vPortFree( pvParameters );
80003118:	f0 1f 00 14 	mcall	80003168 <vCreateTasks+0x54>

	for( ;; )
	{
		/* Just loop round, delaying then creating the four suicidal tasks. */
		vTaskDelay( xDelay );
8000311c:	e0 61 03 e8 	mov	r1,1000

		xCreatedTask = NULL;
80003120:	49 36       	lddpc	r6,8000316c <vCreateTasks+0x58>
80003122:	30 07       	mov	r7,0

		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
80003124:	49 30       	lddpc	r0,80003170 <vCreateTasks+0x5c>
80003126:	49 44       	lddpc	r4,80003174 <vCreateTasks+0x60>
80003128:	e0 63 01 00 	mov	r3,256
		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );

		++usCreationCount;
8000312c:	49 32       	lddpc	r2,80003178 <vCreateTasks+0x64>
	vPortFree( pvParameters );

	for( ;; )
	{
		/* Just loop round, delaying then creating the four suicidal tasks. */
		vTaskDelay( xDelay );
8000312e:	02 9c       	mov	r12,r1
80003130:	f0 1f 00 13 	mcall	8000317c <vCreateTasks+0x68>

		xCreatedTask = NULL;
80003134:	8d 07       	st.w	r6[0x0],r7

		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
80003136:	1a d7       	st.w	--sp,r7
80003138:	1a d7       	st.w	--sp,r7
8000313a:	1a d6       	st.w	--sp,r6
8000313c:	0a 98       	mov	r8,r5
8000313e:	0e 99       	mov	r9,r7
80003140:	06 9a       	mov	r10,r3
80003142:	00 9b       	mov	r11,r0
80003144:	08 9c       	mov	r12,r4
80003146:	f0 1f 00 0f 	mcall	80003180 <vCreateTasks+0x6c>
		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );
8000314a:	1a d7       	st.w	--sp,r7
8000314c:	1a d7       	st.w	--sp,r7
8000314e:	1a d7       	st.w	--sp,r7
80003150:	0a 98       	mov	r8,r5
80003152:	0c 99       	mov	r9,r6
80003154:	06 9a       	mov	r10,r3
80003156:	48 cb       	lddpc	r11,80003184 <vCreateTasks+0x70>
80003158:	08 9c       	mov	r12,r4
8000315a:	f0 1f 00 0a 	mcall	80003180 <vCreateTasks+0x6c>

		++usCreationCount;
8000315e:	84 08       	ld.sh	r8,r2[0x0]
80003160:	2f f8       	sub	r8,-1
80003162:	a4 08       	st.h	r2[0x0],r8
80003164:	2f ad       	sub	sp,-24
80003166:	ce 4b       	rjmp	8000312e <vCreateTasks+0x1a>
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	41 88       	lddsp	r8,sp[0x60]
8000316c:	00 00       	add	r0,r0
8000316e:	09 30       	ld.ub	r0,r4++
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	68 6c       	ld.w	r12,r4[0x18]
80003174:	80 00       	ld.sh	r0,r0[0x0]
80003176:	31 88       	mov	r8,24
80003178:	00 00       	add	r0,r0
8000317a:	07 44       	ld.w	r4,--r3
8000317c:	80 00       	ld.sh	r0,r0[0x0]
8000317e:	4d 20       	lddpc	r0,800032c4 <vStartDynamicPriorityTasks+0x74>
80003180:	80 00       	ld.sh	r0,r0[0x0]
80003182:	4e c0       	lddpc	r0,80003330 <vQueueReceiveWhenSuspendedTask+0x10>
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	68 74       	ld.w	r4,r4[0x1c]

80003188 <vSuicidalTask>:
	uxTasksRunningAtStart++;
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vSuicidalTask, pvParameters )
{
80003188:	eb cd 40 f8 	pushm	r3-r7,lr
8000318c:	20 2d       	sub	sp,8
volatile long l1, l2;
xTaskHandle xTaskToKill;
const portTickType xDelay = ( portTickType ) 200 / portTICK_RATE_MS;

	if( pvParameters != NULL )
8000318e:	58 0c       	cp.w	r12,0
80003190:	f9 b6 00 00 	moveq	r6,0
	{
		/* This task is periodically created four times.  Two created tasks are
		passed a handle to the other task so it can kill it before killing itself.
		The other task is passed in null. */
		xTaskToKill = *( xTaskHandle* )pvParameters;
80003194:	f9 f6 10 00 	ld.wne	r6,r12[0x0]
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
80003198:	30 28       	mov	r8,2
8000319a:	50 18       	stdsp	sp[0x4],r8
		l2 = 89;
8000319c:	35 98       	mov	r8,89
8000319e:	50 08       	stdsp	sp[0x0],r8
		l2 *= l1;
800031a0:	40 08       	lddsp	r8,sp[0x0]
800031a2:	40 19       	lddsp	r9,sp[0x4]
800031a4:	f2 08 02 48 	mul	r8,r9,r8
800031a8:	50 08       	stdsp	sp[0x0],r8
		vTaskDelay( xDelay );
800031aa:	e0 6c 00 c8 	mov	r12,200
800031ae:	f0 1f 00 17 	mcall	80003208 <vSuicidalTask+0x80>

		if( xTaskToKill != NULL )
800031b2:	58 06       	cp.w	r6,0
800031b4:	c1 a0       	breq	800031e8 <vSuicidalTask+0x60>
		{
			/* Make sure the other task has a go before we delete it. */
			vTaskDelay( ( portTickType ) 0 );
800031b6:	30 07       	mov	r7,0
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
800031b8:	30 25       	mov	r5,2
		l2 = 89;
800031ba:	35 94       	mov	r4,89
		l2 *= l1;
		vTaskDelay( xDelay );
800031bc:	e0 63 00 c8 	mov	r3,200

		if( xTaskToKill != NULL )
		{
			/* Make sure the other task has a go before we delete it. */
			vTaskDelay( ( portTickType ) 0 );
800031c0:	0e 9c       	mov	r12,r7
800031c2:	f0 1f 00 12 	mcall	80003208 <vSuicidalTask+0x80>

			/* Kill the other task that was created by vCreateTasks(). */
			vTaskDelete( xTaskToKill );
800031c6:	0c 9c       	mov	r12,r6
800031c8:	f0 1f 00 11 	mcall	8000320c <vSuicidalTask+0x84>

			/* Kill ourselves. */
			vTaskDelete( NULL );
800031cc:	0e 9c       	mov	r12,r7
800031ce:	f0 1f 00 10 	mcall	8000320c <vSuicidalTask+0x84>
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
800031d2:	50 15       	stdsp	sp[0x4],r5
		l2 = 89;
800031d4:	50 04       	stdsp	sp[0x0],r4
		l2 *= l1;
800031d6:	40 08       	lddsp	r8,sp[0x0]
800031d8:	40 19       	lddsp	r9,sp[0x4]
800031da:	f2 08 02 48 	mul	r8,r9,r8
800031de:	50 08       	stdsp	sp[0x0],r8
		vTaskDelay( xDelay );
800031e0:	06 9c       	mov	r12,r3
800031e2:	f0 1f 00 0a 	mcall	80003208 <vSuicidalTask+0x80>
800031e6:	ce db       	rjmp	800031c0 <vSuicidalTask+0x38>
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
800031e8:	30 26       	mov	r6,2
		l2 = 89;
800031ea:	35 97       	mov	r7,89
		l2 *= l1;
		vTaskDelay( xDelay );
800031ec:	e0 65 00 c8 	mov	r5,200
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
800031f0:	50 16       	stdsp	sp[0x4],r6
		l2 = 89;
800031f2:	50 07       	stdsp	sp[0x0],r7
		l2 *= l1;
800031f4:	40 08       	lddsp	r8,sp[0x0]
800031f6:	40 19       	lddsp	r9,sp[0x4]
800031f8:	f2 08 02 48 	mul	r8,r9,r8
800031fc:	50 08       	stdsp	sp[0x0],r8
		vTaskDelay( xDelay );
800031fe:	0a 9c       	mov	r12,r5
80003200:	f0 1f 00 02 	mcall	80003208 <vSuicidalTask+0x80>
80003204:	cf 6b       	rjmp	800031f0 <vSuicidalTask+0x68>
80003206:	00 00       	add	r0,r0
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	4d 20       	lddpc	r0,80003350 <vQueueReceiveWhenSuspendedTask+0x30>
8000320c:	80 00       	ld.sh	r0,r0[0x0]
8000320e:	4c 38       	lddpc	r8,80003318 <vStartDynamicPriorityTasks+0xc8>

80003210 <xAreDynamicPriorityTasksStillRunning>:
portBASE_TYPE xReturn = pdTRUE;

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
80003210:	48 c8       	lddpc	r8,80003240 <xAreDynamicPriorityTasksStillRunning+0x30>
80003212:	90 08       	ld.sh	r8,r8[0x0]
80003214:	10 9a       	mov	r10,r8
80003216:	48 c8       	lddpc	r8,80003244 <xAreDynamicPriorityTasksStillRunning+0x34>
80003218:	90 09       	ld.sh	r9,r8[0x0]
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueSendError == pdTRUE )
8000321a:	48 c8       	lddpc	r8,80003248 <xAreDynamicPriorityTasksStillRunning+0x38>
8000321c:	70 08       	ld.w	r8,r8[0x0]
8000321e:	58 18       	cp.w	r8,1
80003220:	c0 31       	brne	80003226 <xAreDynamicPriorityTasksStillRunning+0x16>
80003222:	30 0c       	mov	r12,0
80003224:	c0 48       	rjmp	8000322c <xAreDynamicPriorityTasksStillRunning+0x1c>
80003226:	f2 0a 19 00 	cp.h	r10,r9
8000322a:	5f 1c       	srne	r12
	{
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
8000322c:	48 88       	lddpc	r8,8000324c <xAreDynamicPriorityTasksStillRunning+0x3c>
8000322e:	70 08       	ld.w	r8,r8[0x0]
80003230:	58 18       	cp.w	r8,1
80003232:	f9 bc 00 00 	moveq	r12,0
	{
		xReturn = pdFALSE;
	}

	usLastTaskCheck = usCheckVariable;
80003236:	48 38       	lddpc	r8,80003240 <xAreDynamicPriorityTasksStillRunning+0x30>
80003238:	90 09       	ld.sh	r9,r8[0x0]
8000323a:	48 38       	lddpc	r8,80003244 <xAreDynamicPriorityTasksStillRunning+0x34>
8000323c:	b0 09       	st.h	r8[0x0],r9
	return xReturn;
}
8000323e:	5e fc       	retal	r12
80003240:	00 00       	add	r0,r0
80003242:	07 4c       	ld.w	r12,--r3
80003244:	00 00       	add	r0,r0
80003246:	07 64       	ld.uh	r4,--r3
80003248:	00 00       	add	r0,r0
8000324a:	07 58       	ld.sh	r8,--r3
8000324c:	00 00       	add	r0,r0
8000324e:	07 54       	ld.sh	r4,--r3

80003250 <vStartDynamicPriorityTasks>:
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
80003250:	eb cd 40 c0 	pushm	r6-r7,lr
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
80003254:	30 4b       	mov	r11,4
80003256:	30 1c       	mov	r12,1
80003258:	f0 1f 00 22 	mcall	800032e0 <vStartDynamicPriorityTasks+0x90>
8000325c:	4a 28       	lddpc	r8,800032e4 <vStartDynamicPriorityTasks+0x94>
8000325e:	91 0c       	st.w	r8[0x0],r12
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( signed char * ) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
80003260:	4a 26       	lddpc	r6,800032e8 <vStartDynamicPriorityTasks+0x98>
80003262:	30 07       	mov	r7,0
80003264:	1a d7       	st.w	--sp,r7
80003266:	1a d7       	st.w	--sp,r7
80003268:	4a 18       	lddpc	r8,800032ec <vStartDynamicPriorityTasks+0x9c>
8000326a:	1a d8       	st.w	--sp,r8
8000326c:	0e 98       	mov	r8,r7
8000326e:	0c 99       	mov	r9,r6
80003270:	e0 6a 01 00 	mov	r10,256
80003274:	49 fb       	lddpc	r11,800032f0 <vStartDynamicPriorityTasks+0xa0>
80003276:	4a 0c       	lddpc	r12,800032f4 <vStartDynamicPriorityTasks+0xa4>
80003278:	f0 1f 00 20 	mcall	800032f8 <vStartDynamicPriorityTasks+0xa8>
	xTaskCreate( vLimitedIncrementTask, ( signed char * ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
8000327c:	1a d7       	st.w	--sp,r7
8000327e:	1a d7       	st.w	--sp,r7
80003280:	49 f8       	lddpc	r8,800032fc <vStartDynamicPriorityTasks+0xac>
80003282:	1a d8       	st.w	--sp,r8
80003284:	30 18       	mov	r8,1
80003286:	0c 99       	mov	r9,r6
80003288:	e0 6a 01 00 	mov	r10,256
8000328c:	49 db       	lddpc	r11,80003300 <vStartDynamicPriorityTasks+0xb0>
8000328e:	49 ec       	lddpc	r12,80003304 <vStartDynamicPriorityTasks+0xb4>
80003290:	f0 1f 00 1a 	mcall	800032f8 <vStartDynamicPriorityTasks+0xa8>
	xTaskCreate( vCounterControlTask, ( signed char * ) "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
80003294:	1a d7       	st.w	--sp,r7
80003296:	1a d7       	st.w	--sp,r7
80003298:	1a d7       	st.w	--sp,r7
8000329a:	0e 98       	mov	r8,r7
8000329c:	0e 99       	mov	r9,r7
8000329e:	e0 6a 01 00 	mov	r10,256
800032a2:	49 ab       	lddpc	r11,80003308 <vStartDynamicPriorityTasks+0xb8>
800032a4:	49 ac       	lddpc	r12,8000330c <vStartDynamicPriorityTasks+0xbc>
800032a6:	f0 1f 00 15 	mcall	800032f8 <vStartDynamicPriorityTasks+0xa8>
	xTaskCreate( vQueueSendWhenSuspendedTask, ( signed char * ) "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
800032aa:	2f 7d       	sub	sp,-36
800032ac:	1a d7       	st.w	--sp,r7
800032ae:	1a d7       	st.w	--sp,r7
800032b0:	1a d7       	st.w	--sp,r7
800032b2:	0e 98       	mov	r8,r7
800032b4:	0e 99       	mov	r9,r7
800032b6:	e0 6a 01 00 	mov	r10,256
800032ba:	49 6b       	lddpc	r11,80003310 <vStartDynamicPriorityTasks+0xc0>
800032bc:	49 6c       	lddpc	r12,80003314 <vStartDynamicPriorityTasks+0xc4>
800032be:	f0 1f 00 0f 	mcall	800032f8 <vStartDynamicPriorityTasks+0xa8>
	xTaskCreate( vQueueReceiveWhenSuspendedTask, ( signed char * ) "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
800032c2:	1a d7       	st.w	--sp,r7
800032c4:	1a d7       	st.w	--sp,r7
800032c6:	1a d7       	st.w	--sp,r7
800032c8:	0e 98       	mov	r8,r7
800032ca:	0e 99       	mov	r9,r7
800032cc:	e0 6a 01 00 	mov	r10,256
800032d0:	49 2b       	lddpc	r11,80003318 <vStartDynamicPriorityTasks+0xc8>
800032d2:	49 3c       	lddpc	r12,8000331c <vStartDynamicPriorityTasks+0xcc>
800032d4:	f0 1f 00 09 	mcall	800032f8 <vStartDynamicPriorityTasks+0xa8>
800032d8:	2f ad       	sub	sp,-24
}
800032da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800032de:	00 00       	add	r0,r0
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	45 e8       	lddsp	r8,sp[0x178]
800032e4:	00 00       	add	r0,r0
800032e6:	09 34       	ld.ub	r4,r4++
800032e8:	00 00       	add	r0,r0
800032ea:	07 5c       	ld.sh	r12,--r3
800032ec:	00 00       	add	r0,r0
800032ee:	07 68       	ld.uh	r8,--r3
800032f0:	80 00       	ld.sh	r0,r0[0x0]
800032f2:	68 7c       	ld.w	r12,r4[0x1c]
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	34 ac       	mov	r12,74
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	4e c0       	lddpc	r0,800034a8 <vCounterControlTask+0xa4>
800032fc:	00 00       	add	r0,r0
800032fe:	07 50       	ld.sh	r0,--r3
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	68 84       	ld.w	r4,r4[0x20]
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	33 dc       	mov	r12,61
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	68 8c       	ld.w	r12,r4[0x20]
8000330c:	80 00       	ld.sh	r0,r0[0x0]
8000330e:	34 04       	mov	r4,64
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	68 94       	ld.w	r4,r4[0x24]
80003314:	80 00       	ld.sh	r0,r0[0x0]
80003316:	33 84       	mov	r4,56
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	68 9c       	ld.w	r12,r4[0x24]
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	33 20       	mov	r0,50

80003320 <vQueueReceiveWhenSuspendedTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
{
80003320:	eb cd 40 fe 	pushm	r1-r7,lr
			outer call. */
			vTaskSuspendAll();
			{
				vTaskSuspendAll();
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
80003324:	49 16       	lddpc	r6,80003368 <vQueueReceiveWhenSuspendedTask+0x48>
80003326:	49 25       	lddpc	r5,8000336c <vQueueReceiveWhenSuspendedTask+0x4c>
80003328:	30 04       	mov	r4,0
				}
				if( xTaskResumeAll() )
				{
					xSuspendedQueueReceiveError = pdTRUE;
8000332a:	49 23       	lddpc	r3,80003370 <vQueueReceiveWhenSuspendedTask+0x50>
8000332c:	30 12       	mov	r2,1
			}
			#endif

		} while( xGotValue == pdFALSE );

		if( ulReceivedValue != ulExpectedValue )
8000332e:	49 21       	lddpc	r1,80003374 <vQueueReceiveWhenSuspendedTask+0x54>
			/* Suspending the scheduler here is fairly pointless and
			undesirable for a normal application.  It is done here purely
			to test the scheduler.  The inner xTaskResumeAll() should
			never return pdTRUE as the scheduler is still locked by the
			outer call. */
			vTaskSuspendAll();
80003330:	f0 1f 00 12 	mcall	80003378 <vQueueReceiveWhenSuspendedTask+0x58>
			{
				vTaskSuspendAll();
80003334:	f0 1f 00 11 	mcall	80003378 <vQueueReceiveWhenSuspendedTask+0x58>
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
80003338:	08 99       	mov	r9,r4
8000333a:	08 9a       	mov	r10,r4
8000333c:	0c 9b       	mov	r11,r6
8000333e:	6a 0c       	ld.w	r12,r5[0x0]
80003340:	f0 1f 00 0f 	mcall	8000337c <vQueueReceiveWhenSuspendedTask+0x5c>
80003344:	18 97       	mov	r7,r12
				}
				if( xTaskResumeAll() )
80003346:	f0 1f 00 0f 	mcall	80003380 <vQueueReceiveWhenSuspendedTask+0x60>
				{
					xSuspendedQueueReceiveError = pdTRUE;
8000334a:	e7 f2 1a 00 	st.wne	r3[0x0],r2
				}
			}
			xTaskResumeAll();
8000334e:	f0 1f 00 0d 	mcall	80003380 <vQueueReceiveWhenSuspendedTask+0x60>
			{
				taskYIELD();
			}
			#endif

		} while( xGotValue == pdFALSE );
80003352:	58 07       	cp.w	r7,0
80003354:	ce e0       	breq	80003330 <vQueueReceiveWhenSuspendedTask+0x10>

		if( ulReceivedValue != ulExpectedValue )
80003356:	62 08       	ld.w	r8,r1[0x0]
80003358:	6c 09       	ld.w	r9,r6[0x0]
		{
			xSuspendedQueueReceiveError = pdTRUE;
8000335a:	10 39       	cp.w	r9,r8
8000335c:	e7 f2 1a 00 	st.wne	r3[0x0],r2
		}

		++ulExpectedValue;
80003360:	2f f8       	sub	r8,-1
80003362:	83 08       	st.w	r1[0x0],r8
80003364:	ce 6b       	rjmp	80003330 <vQueueReceiveWhenSuspendedTask+0x10>
80003366:	00 00       	add	r0,r0
80003368:	00 00       	add	r0,r0
8000336a:	07 60       	ld.uh	r0,--r3
8000336c:	00 00       	add	r0,r0
8000336e:	09 34       	ld.ub	r4,r4++
80003370:	00 00       	add	r0,r0
80003372:	07 54       	ld.sh	r4,--r3
80003374:	00 00       	add	r0,r0
80003376:	07 70       	ld.ub	r0,--r3
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	46 7c       	lddsp	r12,sp[0x19c]
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	43 cc       	lddsp	r12,sp[0xf0]
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	49 8c       	lddpc	r12,800033e0 <vLimitedIncrementTask+0x4>

80003384 <vQueueSendWhenSuspendedTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
{
80003384:	eb cd 40 fc 	pushm	r2-r7,lr
	for( ;; )
	{
		vTaskSuspendAll();
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
80003388:	48 e7       	lddpc	r7,800033c0 <vQueueSendWhenSuspendedTask+0x3c>
8000338a:	48 f6       	lddpc	r6,800033c4 <vQueueSendWhenSuspendedTask+0x40>
8000338c:	30 05       	mov	r5,0
			{
				xSuspendedQueueSendError = pdTRUE;
8000338e:	48 f3       	lddpc	r3,800033c8 <vQueueSendWhenSuspendedTask+0x44>
80003390:	30 12       	mov	r2,1
			}
		}
		xTaskResumeAll();

		vTaskDelay( priSLEEP_TIME );
80003392:	e0 64 00 80 	mov	r4,128
	/* Just to stop warning messages. */
	( void ) pvParameters;

	for( ;; )
	{
		vTaskSuspendAll();
80003396:	f0 1f 00 0e 	mcall	800033cc <vQueueSendWhenSuspendedTask+0x48>
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
8000339a:	0a 99       	mov	r9,r5
8000339c:	0a 9a       	mov	r10,r5
8000339e:	0e 9b       	mov	r11,r7
800033a0:	6c 0c       	ld.w	r12,r6[0x0]
800033a2:	f0 1f 00 0c 	mcall	800033d0 <vQueueSendWhenSuspendedTask+0x4c>
			{
				xSuspendedQueueSendError = pdTRUE;
800033a6:	58 1c       	cp.w	r12,1
800033a8:	e7 f2 1a 00 	st.wne	r3[0x0],r2
			}
		}
		xTaskResumeAll();
800033ac:	f0 1f 00 0a 	mcall	800033d4 <vQueueSendWhenSuspendedTask+0x50>

		vTaskDelay( priSLEEP_TIME );
800033b0:	08 9c       	mov	r12,r4
800033b2:	f0 1f 00 0a 	mcall	800033d8 <vQueueSendWhenSuspendedTask+0x54>

		++ulValueToSend;
800033b6:	6e 08       	ld.w	r8,r7[0x0]
800033b8:	2f f8       	sub	r8,-1
800033ba:	8f 08       	st.w	r7[0x0],r8
	}
800033bc:	ce db       	rjmp	80003396 <vQueueSendWhenSuspendedTask+0x12>
800033be:	00 00       	add	r0,r0
800033c0:	00 00       	add	r0,r0
800033c2:	07 6c       	ld.uh	r12,--r3
800033c4:	00 00       	add	r0,r0
800033c6:	09 34       	ld.ub	r4,r4++
800033c8:	00 00       	add	r0,r0
800033ca:	07 58       	ld.sh	r8,--r3
800033cc:	80 00       	ld.sh	r0,r0[0x0]
800033ce:	46 7c       	lddsp	r12,sp[0x19c]
800033d0:	80 00       	ld.sh	r0,r0[0x0]
800033d2:	44 e8       	lddsp	r8,sp[0x138]
800033d4:	80 00       	ld.sh	r0,r0[0x0]
800033d6:	49 8c       	lddpc	r12,80003434 <vCounterControlTask+0x30>
800033d8:	80 00       	ld.sh	r0,r0[0x0]
800033da:	4d 20       	lddpc	r0,80003520 <vLEDFlashTask>

800033dc <vLimitedIncrementTask>:
/*
 * Just loops around incrementing the shared variable until the limit has been
 * reached.  Once the limit has been reached it suspends itself.
 */
static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
{
800033dc:	eb cd 40 c0 	pushm	r6-r7,lr
800033e0:	18 97       	mov	r7,r12
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
800033e2:	30 0c       	mov	r12,0
800033e4:	f0 1f 00 07 	mcall	80003400 <vLimitedIncrementTask+0x24>
		/* Just count up to a value then suspend. */
		( *pulCounter )++;

		if( *pulCounter >= priMAX_COUNT )
		{
			vTaskSuspend( NULL );
800033e8:	30 06       	mov	r6,0
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
800033ea:	6e 08       	ld.w	r8,r7[0x0]
800033ec:	2f f8       	sub	r8,-1
	for( ;; )
	{
		/* Just count up to a value then suspend. */
		( *pulCounter )++;

		if( *pulCounter >= priMAX_COUNT )
800033ee:	e0 48 00 fe 	cp.w	r8,254
800033f2:	fe 98 ff fd 	brls	800033ec <vLimitedIncrementTask+0x10>
800033f6:	8f 08       	st.w	r7[0x0],r8
		{
			vTaskSuspend( NULL );
800033f8:	0c 9c       	mov	r12,r6
800033fa:	f0 1f 00 02 	mcall	80003400 <vLimitedIncrementTask+0x24>
800033fe:	cf 6b       	rjmp	800033ea <vLimitedIncrementTask+0xe>
80003400:	80 00       	ld.sh	r0,r0[0x0]
80003402:	4a f4       	lddpc	r4,800034bc <vContinuousIncrementTask+0x10>

80003404 <vCounterControlTask>:

/*
 * Controller task as described above.
 */
static portTASK_FUNCTION( vCounterControlTask, pvParameters )
{
80003404:	d4 31       	pushm	r0-r7,lr
80003406:	30 04       	mov	r4,0
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( unsigned long ) 0;
80003408:	49 e6       	lddpc	r6,80003480 <vCounterControlTask+0x7c>
8000340a:	08 90       	mov	r0,r4
		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption. */
			vTaskSuspend( xContinousIncrementHandle );
8000340c:	49 e3       	lddpc	r3,80003484 <vCounterControlTask+0x80>
				ulLastCounter = ulCounter;
			vTaskResume( xContinousIncrementHandle );

			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
8000340e:	e0 61 00 80 	mov	r1,128
		ulCounter = ( unsigned long ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
80003412:	30 52       	mov	r2,5
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( unsigned long ) 0;
80003414:	8d 00       	st.w	r6[0x0],r0
80003416:	00 97       	mov	r7,r0
		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption. */
			vTaskSuspend( xContinousIncrementHandle );
80003418:	66 0c       	ld.w	r12,r3[0x0]
8000341a:	f0 1f 00 1c 	mcall	80003488 <vCounterControlTask+0x84>
				ulLastCounter = ulCounter;
8000341e:	6c 05       	ld.w	r5,r6[0x0]
			vTaskResume( xContinousIncrementHandle );
80003420:	66 0c       	ld.w	r12,r3[0x0]
80003422:	f0 1f 00 1b 	mcall	8000348c <vCounterControlTask+0x88>

			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
80003426:	02 9c       	mov	r12,r1
80003428:	f0 1f 00 1a 	mcall	80003490 <vCounterControlTask+0x8c>

			/* Check the shared variable again.  This time to ensure mutual
			exclusion the whole scheduler will be locked.  This is just for
			demo purposes! */
			vTaskSuspendAll();
8000342c:	f0 1f 00 1a 	mcall	80003494 <vCounterControlTask+0x90>
			{
				if( ulLastCounter == ulCounter )
80003430:	6c 08       	ld.w	r8,r6[0x0]
80003432:	10 35       	cp.w	r5,r8
80003434:	f9 b4 00 01 	moveq	r4,1
					/* The shared variable has not changed.  There is a problem
					with the continuous count task so flag an error. */
					sError = pdTRUE;
				}
			}
			xTaskResumeAll();
80003438:	f0 1f 00 18 	mcall	80003498 <vCounterControlTask+0x94>
		ulCounter = ( unsigned long ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
8000343c:	2f f7       	sub	r7,-1
8000343e:	5c 87       	casts.h	r7
80003440:	e4 07 19 00 	cp.h	r7,r2
80003444:	ce a1       	brne	80003418 <vCounterControlTask+0x14>


		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared variable. */
		vTaskSuspend( xContinousIncrementHandle );
80003446:	66 0c       	ld.w	r12,r3[0x0]
80003448:	f0 1f 00 10 	mcall	80003488 <vCounterControlTask+0x84>

		/* Reset the variable. */
		ulCounter = ( unsigned long ) 0;
8000344c:	30 08       	mov	r8,0
8000344e:	8d 08       	st.w	r6[0x0],r8

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
80003450:	49 38       	lddpc	r8,8000349c <vCounterControlTask+0x98>
80003452:	70 0c       	ld.w	r12,r8[0x0]
80003454:	f0 1f 00 0e 	mcall	8000348c <vCounterControlTask+0x88>

		/* Does the counter variable have the expected value? */
		if( ulCounter != priMAX_COUNT )
80003458:	6c 08       	ld.w	r8,r6[0x0]
8000345a:	e0 48 00 ff 	cp.w	r8,255
8000345e:	c0 30       	breq	80003464 <vCounterControlTask+0x60>
80003460:	30 14       	mov	r4,1
80003462:	c0 b8       	rjmp	80003478 <vCounterControlTask+0x74>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80003464:	58 04       	cp.w	r4,0
80003466:	c0 91       	brne	80003478 <vCounterControlTask+0x74>
		{
			/* If no errors have occurred then increment the check variable. */
			portENTER_CRITICAL();
80003468:	f0 1f 00 0e 	mcall	800034a0 <vCounterControlTask+0x9c>
				usCheckVariable++;
8000346c:	48 e8       	lddpc	r8,800034a4 <vCounterControlTask+0xa0>
8000346e:	90 09       	ld.sh	r9,r8[0x0]
80003470:	2f f9       	sub	r9,-1
80003472:	b0 09       	st.h	r8[0x0],r9
			portEXIT_CRITICAL();
80003474:	f0 1f 00 0d 	mcall	800034a8 <vCounterControlTask+0xa4>
		}

		/* Resume the continuous count task and do it all again. */
		vTaskResume( xContinousIncrementHandle );
80003478:	66 0c       	ld.w	r12,r3[0x0]
8000347a:	f0 1f 00 05 	mcall	8000348c <vCounterControlTask+0x88>
	}
8000347e:	cc bb       	rjmp	80003414 <vCounterControlTask+0x10>
80003480:	00 00       	add	r0,r0
80003482:	07 5c       	ld.sh	r12,--r3
80003484:	00 00       	add	r0,r0
80003486:	07 68       	ld.uh	r8,--r3
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	4a f4       	lddpc	r4,80003544 <vLEDFlashTask+0x24>
8000348c:	80 00       	ld.sh	r0,r0[0x0]
8000348e:	4a 74       	lddpc	r4,80003528 <vLEDFlashTask+0x8>
80003490:	80 00       	ld.sh	r0,r0[0x0]
80003492:	4d 20       	lddpc	r0,800035d8 <vCompetingMathTask1+0x54>
80003494:	80 00       	ld.sh	r0,r0[0x0]
80003496:	46 7c       	lddsp	r12,sp[0x19c]
80003498:	80 00       	ld.sh	r0,r0[0x0]
8000349a:	49 8c       	lddpc	r12,800034f8 <vStartLEDFlashTasks+0x18>
8000349c:	00 00       	add	r0,r0
8000349e:	07 50       	ld.sh	r0,--r3
800034a0:	80 00       	ld.sh	r0,r0[0x0]
800034a2:	3f a8       	mov	r8,-6
800034a4:	00 00       	add	r0,r0
800034a6:	07 4c       	ld.w	r12,--r3
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	40 b4       	lddsp	r4,sp[0x2c]

800034ac <vContinuousIncrementTask>:
/*
 * Just keep counting the shared variable up.  The control task will suspend
 * this task when it wants.
 */
static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
{
800034ac:	d4 21       	pushm	r4-r7,lr
800034ae:	18 96       	mov	r6,r12
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;

	/* Query our priority so we can raise it when exclusive access to the
	shared variable is required. */
	uxOurPriority = uxTaskPriorityGet( NULL );
800034b0:	30 0c       	mov	r12,0
800034b2:	f0 1f 00 0a 	mcall	800034d8 <vContinuousIncrementTask+0x2c>
800034b6:	18 95       	mov	r5,r12

	for( ;; )
	{
		/* Raise our priority above the controller task to ensure a context
		switch does not occur while we are accessing this variable. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
800034b8:	f8 c4 ff ff 	sub	r4,r12,-1
800034bc:	30 07       	mov	r7,0
800034be:	08 9b       	mov	r11,r4
800034c0:	0e 9c       	mov	r12,r7
800034c2:	f0 1f 00 07 	mcall	800034dc <vContinuousIncrementTask+0x30>
			( *pulCounter )++;
800034c6:	6c 08       	ld.w	r8,r6[0x0]
800034c8:	2f f8       	sub	r8,-1
800034ca:	8d 08       	st.w	r6[0x0],r8
		vTaskPrioritySet( NULL, uxOurPriority );
800034cc:	0a 9b       	mov	r11,r5
800034ce:	0e 9c       	mov	r12,r7
800034d0:	f0 1f 00 03 	mcall	800034dc <vContinuousIncrementTask+0x30>
800034d4:	cf 5b       	rjmp	800034be <vContinuousIncrementTask+0x12>
800034d6:	00 00       	add	r0,r0
800034d8:	80 00       	ld.sh	r0,r0[0x0]
800034da:	47 cc       	lddsp	r12,sp[0x1f0]
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	4b 8c       	lddpc	r12,800035bc <vCompetingMathTask1+0x38>

800034e0 <vStartLEDFlashTasks>:
static portTASK_FUNCTION_PROTO( vLEDFlashTask, pvParameters );

/*-----------------------------------------------------------*/

void vStartLEDFlashTasks( unsigned portBASE_TYPE uxPriority )
{
800034e0:	eb cd 40 fc 	pushm	r2-r7,lr
800034e4:	18 93       	mov	r3,r12
800034e6:	30 06       	mov	r6,0

	/* Create the three tasks. */
	for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
	{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, ( signed char * ) "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
800034e8:	48 b5       	lddpc	r5,80003514 <vStartLEDFlashTasks+0x34>
800034ea:	48 c4       	lddpc	r4,80003518 <vStartLEDFlashTasks+0x38>
800034ec:	0c 97       	mov	r7,r6
800034ee:	e0 62 01 00 	mov	r2,256
800034f2:	1a d7       	st.w	--sp,r7
800034f4:	1a d7       	st.w	--sp,r7
800034f6:	1a d7       	st.w	--sp,r7
800034f8:	06 98       	mov	r8,r3
800034fa:	0e 99       	mov	r9,r7
800034fc:	04 9a       	mov	r10,r2
800034fe:	0a 9b       	mov	r11,r5
80003500:	08 9c       	mov	r12,r4
80003502:	f0 1f 00 07 	mcall	8000351c <vStartLEDFlashTasks+0x3c>
void vStartLEDFlashTasks( unsigned portBASE_TYPE uxPriority )
{
signed portBASE_TYPE xLEDTask;

	/* Create the three tasks. */
	for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
80003506:	2f f6       	sub	r6,-1
80003508:	2f dd       	sub	sp,-12
8000350a:	58 36       	cp.w	r6,3
8000350c:	cf 31       	brne	800034f2 <vStartLEDFlashTasks+0x12>
	{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, ( signed char * ) "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
	}
}
8000350e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003512:	00 00       	add	r0,r0
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	68 a4       	ld.w	r4,r4[0x28]
80003518:	80 00       	ld.sh	r0,r0[0x0]
8000351a:	35 20       	mov	r0,82
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	4e c0       	lddpc	r0,800036cc <vCompetingMathTask2+0x48>

80003520 <vLEDFlashTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vLEDFlashTask, pvParameters )
{
80003520:	eb cd 40 e0 	pushm	r5-r7,lr
80003524:	20 1d       	sub	sp,4

	/* The parameters are not used. */
	( void ) pvParameters;

	/* Calculate the LED and flash rate. */
	portENTER_CRITICAL();
80003526:	f0 1f 00 12 	mcall	8000356c <vLEDFlashTask+0x4c>
	{
		/* See which of the eight LED's we should use. */
		uxLED = uxFlashTaskNumber;
8000352a:	49 28       	lddpc	r8,80003570 <vLEDFlashTask+0x50>
8000352c:	70 06       	ld.w	r6,r8[0x0]

		/* Update so the next task uses the next LED. */
		uxFlashTaskNumber++;
8000352e:	70 09       	ld.w	r9,r8[0x0]
80003530:	2f f9       	sub	r9,-1
80003532:	91 09       	st.w	r8[0x0],r9
	}
	portEXIT_CRITICAL();
80003534:	f0 1f 00 10 	mcall	80003574 <vLEDFlashTask+0x54>

	xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( portTickType ) uxLED );
80003538:	ec c5 ff ff 	sub	r5,r6,-1
8000353c:	e0 68 01 4d 	mov	r8,333
80003540:	b1 35       	mul	r5,r8
	xFlashRate /= portTICK_RATE_MS;

	/* We will turn the LED on and off again in the delay period, so each
	delay is only half the total period. */
	xFlashRate /= ( portTickType ) 2;
80003542:	a1 95       	lsr	r5,0x1

	/* We need to initialise xLastFlashTime prior to the first call to
	vTaskDelayUntil(). */
	xLastFlashTime = xTaskGetTickCount();
80003544:	f0 1f 00 0d 	mcall	80003578 <vLEDFlashTask+0x58>
80003548:	fa c7 ff fc 	sub	r7,sp,-4
8000354c:	0e dc       	st.w	--r7,r12

	for(;;)
	{
		/* Delay for half the flash period then turn the LED on. */
		vTaskDelayUntil( &xLastFlashTime, xFlashRate );
8000354e:	0a 9b       	mov	r11,r5
80003550:	1a 9c       	mov	r12,sp
80003552:	f0 1f 00 0b 	mcall	8000357c <vLEDFlashTask+0x5c>
		vParTestToggleLED( uxLED );
80003556:	0c 9c       	mov	r12,r6
80003558:	f0 1f 00 0a 	mcall	80003580 <vLEDFlashTask+0x60>

		/* Delay for half the flash period then turn the LED off. */
		vTaskDelayUntil( &xLastFlashTime, xFlashRate );
8000355c:	0a 9b       	mov	r11,r5
8000355e:	1a 9c       	mov	r12,sp
80003560:	f0 1f 00 07 	mcall	8000357c <vLEDFlashTask+0x5c>
		vParTestToggleLED( uxLED );
80003564:	0c 9c       	mov	r12,r6
80003566:	f0 1f 00 07 	mcall	80003580 <vLEDFlashTask+0x60>
8000356a:	cf 2b       	rjmp	8000354e <vLEDFlashTask+0x2e>
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	3f a8       	mov	r8,-6
80003570:	00 00       	add	r0,r0
80003572:	07 74       	ld.ub	r4,--r3
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	40 b4       	lddsp	r4,sp[0x2c]
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	47 a8       	lddsp	r8,sp[0x1e8]
8000357c:	80 00       	ld.sh	r0,r0[0x0]
8000357e:	4d 68       	lddpc	r8,800036d4 <vCompetingMathTask2+0x50>
80003580:	80 00       	ld.sh	r0,r0[0x0]
80003582:	29 e0       	sub	r0,-98

80003584 <vCompetingMathTask1>:
	xTaskCreate( vCompetingMathTask4, ( signed char * ) "Math8", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 7 ] ), uxPriority, NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompetingMathTask1, pvParameters )
{
80003584:	d4 31       	pushm	r0-r7,lr
80003586:	20 ad       	sub	sp,40
80003588:	18 95       	mov	r5,r12
volatile portDOUBLE d1, d2, d3, d4;
volatile unsigned short *pusTaskCheckVariable;
volatile portDOUBLE dAnswer;
short sError = pdFALSE;

	d1 = 123.4567;
8000358a:	e0 68 05 53 	mov	r8,1363
8000358e:	ea 18 92 a3 	orh	r8,0x92a3
80003592:	e0 69 dd 3a 	mov	r9,56634
80003596:	ea 19 40 5e 	orh	r9,0x405e
8000359a:	fa e9 00 20 	st.d	sp[32],r8
	d2 = 2345.6789;
8000359e:	e0 68 e2 82 	mov	r8,57986
800035a2:	ea 18 98 c7 	orh	r8,0x98c7
800035a6:	e0 69 53 5b 	mov	r9,21339
800035aa:	ea 19 40 a2 	orh	r9,0x40a2
800035ae:	fa e9 00 18 	st.d	sp[24],r8
	d3 = -918.222;
800035b2:	e0 68 9d b2 	mov	r8,40370
800035b6:	ea 18 a7 ef 	orh	r8,0xa7ef
800035ba:	e0 69 b1 c6 	mov	r9,45510
800035be:	ea 19 c0 8c 	orh	r9,0xc08c
800035c2:	fa e9 00 10 	st.d	sp[16],r8

	dAnswer = ( d1 + d2 ) * d3;
800035c6:	fa ea 00 20 	ld.d	r10,sp[32]
800035ca:	fa e8 00 18 	ld.d	r8,sp[24]
800035ce:	fa e6 00 10 	ld.d	r6,sp[16]
800035d2:	f0 1f 00 29 	mcall	80003674 <vCompetingMathTask1+0xf0>
800035d6:	0c 98       	mov	r8,r6
800035d8:	0e 99       	mov	r9,r7
800035da:	f0 1f 00 28 	mcall	80003678 <vCompetingMathTask1+0xf4>
800035de:	fa eb 00 00 	st.d	sp[0],r10

	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;
800035e2:	30 04       	mov	r4,0

	/* Keep performing a calculation and checking the result against a constant. */
	for(;;)
	{
		d1 = 123.4567;
800035e4:	e0 62 05 53 	mov	r2,1363
800035e8:	ea 12 92 a3 	orh	r2,0x92a3
800035ec:	e0 63 dd 3a 	mov	r3,56634
800035f0:	ea 13 40 5e 	orh	r3,0x405e
		d2 = 2345.6789;
800035f4:	e0 60 e2 82 	mov	r0,57986
800035f8:	ea 10 98 c7 	orh	r0,0x98c7
800035fc:	e0 61 53 5b 	mov	r1,21339
80003600:	ea 11 40 a2 	orh	r1,0x40a2
80003604:	c0 28       	rjmp	80003608 <vCompetingMathTask1+0x84>

	dAnswer = ( d1 + d2 ) * d3;

	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;
80003606:	30 14       	mov	r4,1

	/* Keep performing a calculation and checking the result against a constant. */
	for(;;)
	{
		d1 = 123.4567;
80003608:	fa e3 00 20 	st.d	sp[32],r2
		d2 = 2345.6789;
8000360c:	fa e1 00 18 	st.d	sp[24],r0
		d3 = -918.222;
80003610:	e0 68 9d b2 	mov	r8,40370
80003614:	ea 18 a7 ef 	orh	r8,0xa7ef
80003618:	e0 69 b1 c6 	mov	r9,45510
8000361c:	ea 19 c0 8c 	orh	r9,0xc08c
80003620:	fa e9 00 10 	st.d	sp[16],r8

		d4 = ( d1 + d2 ) * d3;
80003624:	fa ea 00 20 	ld.d	r10,sp[32]
80003628:	fa e8 00 18 	ld.d	r8,sp[24]
8000362c:	fa e6 00 10 	ld.d	r6,sp[16]
80003630:	f0 1f 00 11 	mcall	80003674 <vCompetingMathTask1+0xf0>
80003634:	0c 98       	mov	r8,r6
80003636:	0e 99       	mov	r9,r7
80003638:	f0 1f 00 10 	mcall	80003678 <vCompetingMathTask1+0xf4>
8000363c:	fa eb 00 08 	st.d	sp[8],r10
			taskYIELD();
		#endif

		/* If the calculation does not match the expected constant, stop the
		increment of the check variable. */
		if( fabs( d4 - dAnswer ) > 0.001 )
80003640:	fa ea 00 08 	ld.d	r10,sp[8]
80003644:	fa e8 00 00 	ld.d	r8,sp[0]
80003648:	f0 1f 00 0d 	mcall	8000367c <vCompetingMathTask1+0xf8>
8000364c:	f3 db c0 1f 	bfextu	r9,r11,0x0,0x1f
80003650:	14 98       	mov	r8,r10
80003652:	e0 6a a9 fc 	mov	r10,43516
80003656:	ea 1a d2 f1 	orh	r10,0xd2f1
8000365a:	e0 6b 62 4d 	mov	r11,25165
8000365e:	ea 1b 3f 50 	orh	r11,0x3f50
80003662:	f0 1f 00 08 	mcall	80003680 <vCompetingMathTask1+0xfc>
80003666:	cd 01       	brne	80003606 <vCompetingMathTask1+0x82>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80003668:	58 04       	cp.w	r4,0
8000366a:	cc f1       	brne	80003608 <vCompetingMathTask1+0x84>
		{
			/* If the calculation has always been correct, increment the check
			variable so we know this task is still running okay. */
			( *pusTaskCheckVariable )++;
8000366c:	8a 08       	ld.sh	r8,r5[0x0]
8000366e:	2f f8       	sub	r8,-1
80003670:	aa 08       	st.h	r5[0x0],r8
80003672:	cc bb       	rjmp	80003608 <vCompetingMathTask1+0x84>
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	54 64       	stdsp	sp[0x118],r4
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	50 f0       	stdsp	sp[0x3c],r0
8000367c:	80 00       	ld.sh	r0,r0[0x0]
8000367e:	52 c8       	stdsp	sp[0xb0],r8
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	56 5c       	stdsp	sp[0x194],r12

80003684 <vCompetingMathTask2>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompetingMathTask2, pvParameters )
{
80003684:	d4 31       	pushm	r0-r7,lr
80003686:	20 ad       	sub	sp,40
80003688:	18 95       	mov	r5,r12
volatile portDOUBLE d1, d2, d3, d4;
volatile unsigned short *pusTaskCheckVariable;
volatile portDOUBLE dAnswer;
short sError = pdFALSE;

	d1 = -389.38;
8000368a:	e0 68 47 ae 	mov	r8,18350
8000368e:	ea 18 7a e1 	orh	r8,0x7ae1
80003692:	e0 69 56 14 	mov	r9,22036
80003696:	ea 19 c0 78 	orh	r9,0xc078
8000369a:	fa e9 00 20 	st.d	sp[32],r8
	d2 = 32498.2;
8000369e:	e0 68 cc cd 	mov	r8,52429
800036a2:	ea 18 cc cc 	orh	r8,0xcccc
800036a6:	e0 69 bc 8c 	mov	r9,48268
800036aa:	ea 19 40 df 	orh	r9,0x40df
800036ae:	fa e9 00 18 	st.d	sp[24],r8
	d3 = -2.0001;
800036b2:	e0 68 d6 39 	mov	r8,54841
800036b6:	ea 18 6d c5 	orh	r8,0x6dc5
800036ba:	33 49       	mov	r9,52
800036bc:	ea 19 c0 00 	orh	r9,0xc000
800036c0:	fa e9 00 10 	st.d	sp[16],r8

	dAnswer = ( d1 / d2 ) * d3;
800036c4:	fa ea 00 20 	ld.d	r10,sp[32]
800036c8:	fa e8 00 18 	ld.d	r8,sp[24]
800036cc:	fa e6 00 10 	ld.d	r6,sp[16]
800036d0:	f0 1f 00 28 	mcall	80003770 <vCompetingMathTask2+0xec>
800036d4:	0c 98       	mov	r8,r6
800036d6:	0e 99       	mov	r9,r7
800036d8:	f0 1f 00 27 	mcall	80003774 <vCompetingMathTask2+0xf0>
800036dc:	fa eb 00 00 	st.d	sp[0],r10


	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;
800036e0:	30 04       	mov	r4,0

	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		d1 = -389.38;
800036e2:	e0 62 47 ae 	mov	r2,18350
800036e6:	ea 12 7a e1 	orh	r2,0x7ae1
800036ea:	e0 63 56 14 	mov	r3,22036
800036ee:	ea 13 c0 78 	orh	r3,0xc078
		d2 = 32498.2;
800036f2:	e0 60 cc cd 	mov	r0,52429
800036f6:	ea 10 cc cc 	orh	r0,0xcccc
800036fa:	e0 61 bc 8c 	mov	r1,48268
800036fe:	ea 11 40 df 	orh	r1,0x40df
80003702:	c0 28       	rjmp	80003706 <vCompetingMathTask2+0x82>
	dAnswer = ( d1 / d2 ) * d3;


	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;
80003704:	30 14       	mov	r4,1

	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		d1 = -389.38;
80003706:	fa e3 00 20 	st.d	sp[32],r2
		d2 = 32498.2;
8000370a:	fa e1 00 18 	st.d	sp[24],r0
		d3 = -2.0001;
8000370e:	e0 68 d6 39 	mov	r8,54841
80003712:	ea 18 6d c5 	orh	r8,0x6dc5
80003716:	33 49       	mov	r9,52
80003718:	ea 19 c0 00 	orh	r9,0xc000
8000371c:	fa e9 00 10 	st.d	sp[16],r8

		d4 = ( d1 / d2 ) * d3;
80003720:	fa ea 00 20 	ld.d	r10,sp[32]
80003724:	fa e8 00 18 	ld.d	r8,sp[24]
80003728:	fa e6 00 10 	ld.d	r6,sp[16]
8000372c:	f0 1f 00 11 	mcall	80003770 <vCompetingMathTask2+0xec>
80003730:	0c 98       	mov	r8,r6
80003732:	0e 99       	mov	r9,r7
80003734:	f0 1f 00 10 	mcall	80003774 <vCompetingMathTask2+0xf0>
80003738:	fa eb 00 08 	st.d	sp[8],r10
			taskYIELD();
		#endif

		/* If the calculation does not match the expected constant, stop the
		increment of the check variable. */
		if( fabs( d4 - dAnswer ) > 0.001 )
8000373c:	fa ea 00 08 	ld.d	r10,sp[8]
80003740:	fa e8 00 00 	ld.d	r8,sp[0]
80003744:	f0 1f 00 0d 	mcall	80003778 <vCompetingMathTask2+0xf4>
80003748:	f3 db c0 1f 	bfextu	r9,r11,0x0,0x1f
8000374c:	14 98       	mov	r8,r10
8000374e:	e0 6a a9 fc 	mov	r10,43516
80003752:	ea 1a d2 f1 	orh	r10,0xd2f1
80003756:	e0 6b 62 4d 	mov	r11,25165
8000375a:	ea 1b 3f 50 	orh	r11,0x3f50
8000375e:	f0 1f 00 08 	mcall	8000377c <vCompetingMathTask2+0xf8>
80003762:	cd 11       	brne	80003704 <vCompetingMathTask2+0x80>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80003764:	58 04       	cp.w	r4,0
80003766:	cd 01       	brne	80003706 <vCompetingMathTask2+0x82>
		{
			/* If the calculation has always been correct, increment the check
			variable so we know
			this task is still running okay. */
			( *pusTaskCheckVariable )++;
80003768:	8a 08       	ld.sh	r8,r5[0x0]
8000376a:	2f f8       	sub	r8,-1
8000376c:	aa 08       	st.h	r5[0x0],r8
8000376e:	cc cb       	rjmp	80003706 <vCompetingMathTask2+0x82>
80003770:	80 00       	ld.sh	r0,r0[0x0]
80003772:	56 c4       	stdsp	sp[0x1b0],r4
80003774:	80 00       	ld.sh	r0,r0[0x0]
80003776:	50 f0       	stdsp	sp[0x3c],r0
80003778:	80 00       	ld.sh	r0,r0[0x0]
8000377a:	52 c8       	stdsp	sp[0xb0],r8
8000377c:	80 00       	ld.sh	r0,r0[0x0]
8000377e:	56 5c       	stdsp	sp[0x194],r12

80003780 <xAreMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreMathsTaskStillRunning( void )
{
80003780:	d4 01       	pushm	lr
80003782:	48 a9       	lddpc	r9,800037a8 <xAreMathsTaskStillRunning+0x28>
80003784:	30 08       	mov	r8,0
80003786:	30 1c       	mov	r12,1

	/* Check the maths tasks are still running by ensuring their check variables
	are still incrementing. */
	for( xTask = 0; xTask < mathNUMBER_OF_TASKS; xTask++ )
	{
		if( usTaskCheck[ xTask ] == usLastTaskCheck[ xTask ] )
80003788:	48 9e       	lddpc	lr,800037ac <xAreMathsTaskStillRunning+0x2c>
8000378a:	fc 08 04 1a 	ld.sh	r10,lr[r8<<0x1]
8000378e:	92 0b       	ld.sh	r11,r9[0x0]
80003790:	f4 0b 19 00 	cp.h	r11,r10
80003794:	f9 bc 00 00 	moveq	r12,0
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
		}

		usLastTaskCheck[ xTask ] = usTaskCheck[ xTask ];
80003798:	fc 08 04 1a 	ld.sh	r10,lr[r8<<0x1]
8000379c:	12 ba       	st.h	r9++,r10
static unsigned short usLastTaskCheck[ mathNUMBER_OF_TASKS ] = { ( unsigned short ) 0 };
portBASE_TYPE xReturn = pdTRUE, xTask;

	/* Check the maths tasks are still running by ensuring their check variables
	are still incrementing. */
	for( xTask = 0; xTask < mathNUMBER_OF_TASKS; xTask++ )
8000379e:	2f f8       	sub	r8,-1
800037a0:	58 88       	cp.w	r8,8
800037a2:	cf 41       	brne	8000378a <xAreMathsTaskStillRunning+0xa>

		usLastTaskCheck[ xTask ] = usTaskCheck[ xTask ];
	}

	return xReturn;
}
800037a4:	d8 02       	popm	pc
800037a6:	00 00       	add	r0,r0
800037a8:	00 00       	add	r0,r0
800037aa:	07 88       	ld.ub	r8,r3[0x0]
800037ac:	00 00       	add	r0,r0
800037ae:	07 78       	ld.ub	r8,--r3

800037b0 <vStartMathTasks>:
static volatile unsigned short usTaskCheck[ mathNUMBER_OF_TASKS ] = { ( unsigned short ) 0 };

/*-----------------------------------------------------------*/

void vStartMathTasks( unsigned portBASE_TYPE uxPriority )
{
800037b0:	eb cd 40 fe 	pushm	r1-r7,lr
800037b4:	18 96       	mov	r6,r12
	xTaskCreate( vCompetingMathTask1, ( signed char * ) "Math1", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 0 ] ), uxPriority, NULL );
800037b6:	4b 65       	lddpc	r5,8000388c <vStartMathTasks+0xdc>
800037b8:	4b 64       	lddpc	r4,80003890 <vStartMathTasks+0xe0>
800037ba:	30 07       	mov	r7,0
800037bc:	1a d7       	st.w	--sp,r7
800037be:	1a d7       	st.w	--sp,r7
800037c0:	1a d7       	st.w	--sp,r7
800037c2:	18 98       	mov	r8,r12
800037c4:	0a 99       	mov	r9,r5
800037c6:	e0 6a 01 00 	mov	r10,256
800037ca:	4b 3b       	lddpc	r11,80003894 <vStartMathTasks+0xe4>
800037cc:	08 9c       	mov	r12,r4
800037ce:	f0 1f 00 33 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask2, ( signed char * ) "Math2", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 1 ] ), uxPriority, NULL );
800037d2:	4b 33       	lddpc	r3,8000389c <vStartMathTasks+0xec>
800037d4:	1a d7       	st.w	--sp,r7
800037d6:	1a d7       	st.w	--sp,r7
800037d8:	1a d7       	st.w	--sp,r7
800037da:	0c 98       	mov	r8,r6
800037dc:	ea c9 ff fe 	sub	r9,r5,-2
800037e0:	e0 6a 01 00 	mov	r10,256
800037e4:	4a fb       	lddpc	r11,800038a0 <vStartMathTasks+0xf0>
800037e6:	06 9c       	mov	r12,r3
800037e8:	f0 1f 00 2c 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask3, ( signed char * ) "Math3", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 2 ] ), uxPriority, NULL );
800037ec:	4a e2       	lddpc	r2,800038a4 <vStartMathTasks+0xf4>
800037ee:	1a d7       	st.w	--sp,r7
800037f0:	1a d7       	st.w	--sp,r7
800037f2:	1a d7       	st.w	--sp,r7
800037f4:	0c 98       	mov	r8,r6
800037f6:	ea c9 ff fc 	sub	r9,r5,-4
800037fa:	e0 6a 01 00 	mov	r10,256
800037fe:	4a bb       	lddpc	r11,800038a8 <vStartMathTasks+0xf8>
80003800:	04 9c       	mov	r12,r2
80003802:	f0 1f 00 26 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask4, ( signed char * ) "Math4", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 3 ] ), uxPriority, NULL );
80003806:	2f 7d       	sub	sp,-36
80003808:	4a 91       	lddpc	r1,800038ac <vStartMathTasks+0xfc>
8000380a:	1a d7       	st.w	--sp,r7
8000380c:	1a d7       	st.w	--sp,r7
8000380e:	1a d7       	st.w	--sp,r7
80003810:	0c 98       	mov	r8,r6
80003812:	ea c9 ff fa 	sub	r9,r5,-6
80003816:	e0 6a 01 00 	mov	r10,256
8000381a:	4a 6b       	lddpc	r11,800038b0 <vStartMathTasks+0x100>
8000381c:	02 9c       	mov	r12,r1
8000381e:	f0 1f 00 1f 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask1, ( signed char * ) "Math5", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 4 ] ), uxPriority, NULL );
80003822:	1a d7       	st.w	--sp,r7
80003824:	1a d7       	st.w	--sp,r7
80003826:	1a d7       	st.w	--sp,r7
80003828:	0c 98       	mov	r8,r6
8000382a:	ea c9 ff f8 	sub	r9,r5,-8
8000382e:	e0 6a 01 00 	mov	r10,256
80003832:	4a 1b       	lddpc	r11,800038b4 <vStartMathTasks+0x104>
80003834:	08 9c       	mov	r12,r4
80003836:	f0 1f 00 19 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask2, ( signed char * ) "Math6", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 5 ] ), uxPriority, NULL );
8000383a:	1a d7       	st.w	--sp,r7
8000383c:	1a d7       	st.w	--sp,r7
8000383e:	1a d7       	st.w	--sp,r7
80003840:	0c 98       	mov	r8,r6
80003842:	ea c9 ff f6 	sub	r9,r5,-10
80003846:	e0 6a 01 00 	mov	r10,256
8000384a:	49 cb       	lddpc	r11,800038b8 <vStartMathTasks+0x108>
8000384c:	06 9c       	mov	r12,r3
8000384e:	f0 1f 00 13 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask3, ( signed char * ) "Math7", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 6 ] ), uxPriority, NULL );
80003852:	2f 7d       	sub	sp,-36
80003854:	1a d7       	st.w	--sp,r7
80003856:	1a d7       	st.w	--sp,r7
80003858:	1a d7       	st.w	--sp,r7
8000385a:	0c 98       	mov	r8,r6
8000385c:	ea c9 ff f4 	sub	r9,r5,-12
80003860:	e0 6a 01 00 	mov	r10,256
80003864:	49 6b       	lddpc	r11,800038bc <vStartMathTasks+0x10c>
80003866:	04 9c       	mov	r12,r2
80003868:	f0 1f 00 0c 	mcall	80003898 <vStartMathTasks+0xe8>
	xTaskCreate( vCompetingMathTask4, ( signed char * ) "Math8", mathSTACK_SIZE, ( void * ) &( usTaskCheck[ 7 ] ), uxPriority, NULL );
8000386c:	1a d7       	st.w	--sp,r7
8000386e:	1a d7       	st.w	--sp,r7
80003870:	1a d7       	st.w	--sp,r7
80003872:	0c 98       	mov	r8,r6
80003874:	ea c9 ff f2 	sub	r9,r5,-14
80003878:	e0 6a 01 00 	mov	r10,256
8000387c:	49 1b       	lddpc	r11,800038c0 <vStartMathTasks+0x110>
8000387e:	02 9c       	mov	r12,r1
80003880:	f0 1f 00 06 	mcall	80003898 <vStartMathTasks+0xe8>
80003884:	2f ad       	sub	sp,-24
}
80003886:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000388a:	00 00       	add	r0,r0
8000388c:	00 00       	add	r0,r0
8000388e:	07 78       	ld.ub	r8,--r3
80003890:	80 00       	ld.sh	r0,r0[0x0]
80003892:	35 84       	mov	r4,88
80003894:	80 00       	ld.sh	r0,r0[0x0]
80003896:	68 ac       	ld.w	r12,r4[0x28]
80003898:	80 00       	ld.sh	r0,r0[0x0]
8000389a:	4e c0       	lddpc	r0,80003a48 <vCompetingMathTask3+0xb8>
8000389c:	80 00       	ld.sh	r0,r0[0x0]
8000389e:	36 84       	mov	r4,104
800038a0:	80 00       	ld.sh	r0,r0[0x0]
800038a2:	68 b4       	ld.w	r4,r4[0x2c]
800038a4:	80 00       	ld.sh	r0,r0[0x0]
800038a6:	39 90       	mov	r0,-103
800038a8:	80 00       	ld.sh	r0,r0[0x0]
800038aa:	68 bc       	ld.w	r12,r4[0x2c]
800038ac:	80 00       	ld.sh	r0,r0[0x0]
800038ae:	38 c4       	mov	r4,-116
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	68 c4       	ld.w	r4,r4[0x30]
800038b4:	80 00       	ld.sh	r0,r0[0x0]
800038b6:	68 cc       	ld.w	r12,r4[0x30]
800038b8:	80 00       	ld.sh	r0,r0[0x0]
800038ba:	68 d4       	ld.w	r4,r4[0x34]
800038bc:	80 00       	ld.sh	r0,r0[0x0]
800038be:	68 dc       	ld.w	r12,r4[0x34]
800038c0:	80 00       	ld.sh	r0,r0[0x0]
800038c2:	68 e4       	ld.w	r4,r4[0x38]

800038c4 <vCompetingMathTask4>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompetingMathTask4, pvParameters )
{
800038c4:	d4 31       	pushm	r0-r7,lr
800038c6:	20 7d       	sub	sp,28
800038c8:	18 90       	mov	r0,r12

	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;

	pdArray = ( portDOUBLE * ) pvPortMalloc( xArraySize * sizeof( portDOUBLE ) );
800038ca:	35 0c       	mov	r12,80
800038cc:	f0 1f 00 2b 	mcall	80003978 <vCompetingMathTask4+0xb4>
800038d0:	30 09       	mov	r9,0
800038d2:	50 09       	stdsp	sp[0x0],r9
	array.  Then run through the array adding up all the values.  If the two totals
	do not match, stop the check variable from incrementing. */
	for( ;; )
	{
		dTotal1 = 0.0;
		dTotal2 = 0.0;
800038d4:	18 91       	mov	r1,r12

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
		{
			pdArray[ xPosition ] = ( portDOUBLE ) xPosition * 12.123;
800038d6:	e0 62 d0 e5 	mov	r2,53477
800038da:	ea 12 db 22 	orh	r2,0xdb22
800038de:	e0 63 3e f9 	mov	r3,16121
800038e2:	ea 13 40 28 	orh	r3,0x4028
		}
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompetingMathTask4, pvParameters )
800038e6:	f8 c4 ff b0 	sub	r4,r12,-80
800038ea:	c0 38       	rjmp	800038f0 <vCompetingMathTask4+0x2c>

	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;

	pdArray = ( portDOUBLE * ) pvPortMalloc( xArraySize * sizeof( portDOUBLE ) );
800038ec:	30 18       	mov	r8,1
800038ee:	50 08       	stdsp	sp[0x0],r8
	/* Keep filling an array, keeping a running total of the values placed in the
	array.  Then run through the array adding up all the values.  If the two totals
	do not match, stop the check variable from incrementing. */
	for( ;; )
	{
		dTotal1 = 0.0;
800038f0:	30 08       	mov	r8,0
800038f2:	30 09       	mov	r9,0
800038f4:	fa e9 00 14 	st.d	sp[20],r8
		dTotal2 = 0.0;
800038f8:	fa e9 00 0c 	st.d	sp[12],r8
800038fc:	02 96       	mov	r6,r1
800038fe:	02 95       	mov	r5,r1
80003900:	30 07       	mov	r7,0

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
		{
			pdArray[ xPosition ] = ( portDOUBLE ) xPosition * 12.123;
80003902:	0e 9c       	mov	r12,r7
80003904:	f0 1f 00 1e 	mcall	8000397c <vCompetingMathTask4+0xb8>
80003908:	04 98       	mov	r8,r2
8000390a:	06 99       	mov	r9,r3
8000390c:	f0 1f 00 1d 	mcall	80003980 <vCompetingMathTask4+0xbc>
80003910:	14 98       	mov	r8,r10
80003912:	16 99       	mov	r9,r11
80003914:	ab 28       	st.d	r5++,r8
			dTotal1 += ( portDOUBLE ) xPosition * 12.123;
80003916:	fa e8 00 14 	ld.d	r8,sp[20]
8000391a:	f0 1f 00 1b 	mcall	80003984 <vCompetingMathTask4+0xc0>
8000391e:	fa eb 00 14 	st.d	sp[20],r10
	for( ;; )
	{
		dTotal1 = 0.0;
		dTotal2 = 0.0;

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
80003922:	2f f7       	sub	r7,-1
80003924:	58 a7       	cp.w	r7,10
80003926:	ce e1       	brne	80003902 <vCompetingMathTask4+0x3e>
			taskYIELD();
		#endif

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
		{
			dTotal2 += pdArray[ xPosition ];
80003928:	ad 0b       	ld.d	r10,r6++
8000392a:	fa e8 00 0c 	ld.d	r8,sp[12]
8000392e:	f0 1f 00 16 	mcall	80003984 <vCompetingMathTask4+0xc0>
80003932:	fa eb 00 0c 	st.d	sp[12],r10

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
80003936:	08 36       	cp.w	r6,r4
80003938:	cf 81       	brne	80003928 <vCompetingMathTask4+0x64>
		{
			dTotal2 += pdArray[ xPosition ];
		}

		dDifference = dTotal1 - dTotal2;
8000393a:	fa ea 00 14 	ld.d	r10,sp[20]
8000393e:	fa e8 00 0c 	ld.d	r8,sp[12]
80003942:	f0 1f 00 12 	mcall	80003988 <vCompetingMathTask4+0xc4>
80003946:	fa eb 00 04 	st.d	sp[4],r10
		if( fabs( dDifference ) > 0.001 )
8000394a:	fa ea 00 04 	ld.d	r10,sp[4]
8000394e:	f3 db c0 1f 	bfextu	r9,r11,0x0,0x1f
80003952:	14 98       	mov	r8,r10
80003954:	e0 6a a9 fc 	mov	r10,43516
80003958:	ea 1a d2 f1 	orh	r10,0xd2f1
8000395c:	e0 6b 62 4d 	mov	r11,25165
80003960:	ea 1b 3f 50 	orh	r11,0x3f50
80003964:	f0 1f 00 0a 	mcall	8000398c <vCompetingMathTask4+0xc8>
80003968:	cc 21       	brne	800038ec <vCompetingMathTask4+0x28>

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		if( sError == pdFALSE )
8000396a:	40 08       	lddsp	r8,sp[0x0]
8000396c:	58 08       	cp.w	r8,0
8000396e:	cc 11       	brne	800038f0 <vCompetingMathTask4+0x2c>
		{
			/* If the calculation has always been correct, increment the check
			variable so we know	this task is still running okay. */
			( *pusTaskCheckVariable )++;
80003970:	80 08       	ld.sh	r8,r0[0x0]
80003972:	2f f8       	sub	r8,-1
80003974:	a0 08       	st.h	r0[0x0],r8
80003976:	cb db       	rjmp	800038f0 <vCompetingMathTask4+0x2c>
80003978:	80 00       	ld.sh	r0,r0[0x0]
8000397a:	41 b0       	lddsp	r0,sp[0x6c]
8000397c:	80 00       	ld.sh	r0,r0[0x0]
8000397e:	55 74       	stdsp	sp[0x15c],r4
80003980:	80 00       	ld.sh	r0,r0[0x0]
80003982:	50 f0       	stdsp	sp[0x3c],r0
80003984:	80 00       	ld.sh	r0,r0[0x0]
80003986:	54 64       	stdsp	sp[0x118],r4
80003988:	80 00       	ld.sh	r0,r0[0x0]
8000398a:	52 c8       	stdsp	sp[0xb0],r8
8000398c:	80 00       	ld.sh	r0,r0[0x0]
8000398e:	56 5c       	stdsp	sp[0x194],r12

80003990 <vCompetingMathTask3>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompetingMathTask3, pvParameters )
{
80003990:	d4 31       	pushm	r0-r7,lr
80003992:	20 7d       	sub	sp,28
80003994:	18 90       	mov	r0,r12

	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;

	pdArray = ( portDOUBLE * ) pvPortMalloc( xArraySize * sizeof( portDOUBLE ) );
80003996:	35 0c       	mov	r12,80
80003998:	f0 1f 00 29 	mcall	80003a3c <vCompetingMathTask3+0xac>
8000399c:	30 09       	mov	r9,0
8000399e:	50 09       	stdsp	sp[0x0],r9
	array.  Then run through the array adding up all the values.  If the two totals
	do not match, stop the check variable from incrementing. */
	for( ;; )
	{
		dTotal1 = 0.0;
		dTotal2 = 0.0;
800039a0:	18 91       	mov	r1,r12

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
		{
			pdArray[ xPosition ] = ( portDOUBLE ) xPosition + 5.5;
800039a2:	30 02       	mov	r2,0
800039a4:	fc 13 40 16 	movh	r3,0x4016
		#endif
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompetingMathTask3, pvParameters )
800039a8:	f8 c4 ff b0 	sub	r4,r12,-80
800039ac:	c0 38       	rjmp	800039b2 <vCompetingMathTask3+0x22>

	/* The variable this task increments to show it is still running is passed in
	as the parameter. */
	pusTaskCheckVariable = ( unsigned short * ) pvParameters;

	pdArray = ( portDOUBLE * ) pvPortMalloc( xArraySize * sizeof( portDOUBLE ) );
800039ae:	30 18       	mov	r8,1
800039b0:	50 08       	stdsp	sp[0x0],r8
	/* Keep filling an array, keeping a running total of the values placed in the
	array.  Then run through the array adding up all the values.  If the two totals
	do not match, stop the check variable from incrementing. */
	for( ;; )
	{
		dTotal1 = 0.0;
800039b2:	30 08       	mov	r8,0
800039b4:	30 09       	mov	r9,0
800039b6:	fa e9 00 14 	st.d	sp[20],r8
		dTotal2 = 0.0;
800039ba:	fa e9 00 0c 	st.d	sp[12],r8
800039be:	02 96       	mov	r6,r1
800039c0:	02 95       	mov	r5,r1
800039c2:	30 07       	mov	r7,0

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
		{
			pdArray[ xPosition ] = ( portDOUBLE ) xPosition + 5.5;
800039c4:	0e 9c       	mov	r12,r7
800039c6:	f0 1f 00 1f 	mcall	80003a40 <vCompetingMathTask3+0xb0>
800039ca:	04 98       	mov	r8,r2
800039cc:	06 99       	mov	r9,r3
800039ce:	f0 1f 00 1e 	mcall	80003a44 <vCompetingMathTask3+0xb4>
800039d2:	14 98       	mov	r8,r10
800039d4:	16 99       	mov	r9,r11
800039d6:	ab 28       	st.d	r5++,r8
			dTotal1 += ( portDOUBLE ) xPosition + 5.5;
800039d8:	fa e8 00 14 	ld.d	r8,sp[20]
800039dc:	f0 1f 00 1a 	mcall	80003a44 <vCompetingMathTask3+0xb4>
800039e0:	fa eb 00 14 	st.d	sp[20],r10
	for( ;; )
	{
		dTotal1 = 0.0;
		dTotal2 = 0.0;

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
800039e4:	2f f7       	sub	r7,-1
800039e6:	58 a7       	cp.w	r7,10
800039e8:	ce e1       	brne	800039c4 <vCompetingMathTask3+0x34>
			taskYIELD();
		#endif

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
		{
			dTotal2 += pdArray[ xPosition ];
800039ea:	ad 0b       	ld.d	r10,r6++
800039ec:	fa e8 00 0c 	ld.d	r8,sp[12]
800039f0:	f0 1f 00 15 	mcall	80003a44 <vCompetingMathTask3+0xb4>
800039f4:	fa eb 00 0c 	st.d	sp[12],r10

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		for( xPosition = 0; xPosition < xArraySize; xPosition++ )
800039f8:	08 36       	cp.w	r6,r4
800039fa:	cf 81       	brne	800039ea <vCompetingMathTask3+0x5a>
		{
			dTotal2 += pdArray[ xPosition ];
		}

		dDifference = dTotal1 - dTotal2;
800039fc:	fa ea 00 14 	ld.d	r10,sp[20]
80003a00:	fa e8 00 0c 	ld.d	r8,sp[12]
80003a04:	f0 1f 00 11 	mcall	80003a48 <vCompetingMathTask3+0xb8>
80003a08:	fa eb 00 04 	st.d	sp[4],r10
		if( fabs( dDifference ) > 0.001 )
80003a0c:	fa ea 00 04 	ld.d	r10,sp[4]
80003a10:	f3 db c0 1f 	bfextu	r9,r11,0x0,0x1f
80003a14:	14 98       	mov	r8,r10
80003a16:	e0 6a a9 fc 	mov	r10,43516
80003a1a:	ea 1a d2 f1 	orh	r10,0xd2f1
80003a1e:	e0 6b 62 4d 	mov	r11,25165
80003a22:	ea 1b 3f 50 	orh	r11,0x3f50
80003a26:	f0 1f 00 0a 	mcall	80003a4c <vCompetingMathTask3+0xbc>
80003a2a:	cc 21       	brne	800039ae <vCompetingMathTask3+0x1e>

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		if( sError == pdFALSE )
80003a2c:	40 08       	lddsp	r8,sp[0x0]
80003a2e:	58 08       	cp.w	r8,0
80003a30:	cc 11       	brne	800039b2 <vCompetingMathTask3+0x22>
		{
			/* If the calculation has always been correct, increment the check
			variable so we know	this task is still running okay. */
			( *pusTaskCheckVariable )++;
80003a32:	80 08       	ld.sh	r8,r0[0x0]
80003a34:	2f f8       	sub	r8,-1
80003a36:	a0 08       	st.h	r0[0x0],r8
80003a38:	cb db       	rjmp	800039b2 <vCompetingMathTask3+0x22>
80003a3a:	00 00       	add	r0,r0
80003a3c:	80 00       	ld.sh	r0,r0[0x0]
80003a3e:	41 b0       	lddsp	r0,sp[0x6c]
80003a40:	80 00       	ld.sh	r0,r0[0x0]
80003a42:	55 74       	stdsp	sp[0x15c],r4
80003a44:	80 00       	ld.sh	r0,r0[0x0]
80003a46:	54 64       	stdsp	sp[0x118],r4
80003a48:	80 00       	ld.sh	r0,r0[0x0]
80003a4a:	52 c8       	stdsp	sp[0xb0],r8
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	56 5c       	stdsp	sp[0x194],r12

80003a50 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
80003a50:	48 48       	lddpc	r8,80003a60 <xAreIntegerMathsTaskStillRunning+0x10>
80003a52:	70 09       	ld.w	r9,r8[0x0]
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
80003a54:	30 0a       	mov	r10,0
80003a56:	91 0a       	st.w	r8[0x0],r10
80003a58:	58 09       	cp.w	r9,0
	}

	return xReturn;
}
80003a5a:	5f 1c       	srne	r12
80003a5c:	5e fc       	retal	r12
80003a5e:	00 00       	add	r0,r0
80003a60:	00 00       	add	r0,r0
80003a62:	07 98       	ld.ub	r8,r3[0x1]

80003a64 <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
80003a64:	d4 01       	pushm	lr
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
80003a66:	30 08       	mov	r8,0
80003a68:	1a d8       	st.w	--sp,r8
80003a6a:	1a d8       	st.w	--sp,r8
80003a6c:	1a d8       	st.w	--sp,r8
80003a6e:	18 98       	mov	r8,r12
80003a70:	48 59       	lddpc	r9,80003a84 <vStartIntegerMathTasks+0x20>
80003a72:	e0 6a 01 00 	mov	r10,256
80003a76:	48 5b       	lddpc	r11,80003a88 <vStartIntegerMathTasks+0x24>
80003a78:	48 5c       	lddpc	r12,80003a8c <vStartIntegerMathTasks+0x28>
80003a7a:	f0 1f 00 06 	mcall	80003a90 <vStartIntegerMathTasks+0x2c>
80003a7e:	2f dd       	sub	sp,-12
	}
}
80003a80:	d8 02       	popm	pc
80003a82:	00 00       	add	r0,r0
80003a84:	00 00       	add	r0,r0
80003a86:	07 98       	ld.ub	r8,r3[0x1]
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	68 ec       	ld.w	r12,r4[0x38]
80003a8c:	80 00       	ld.sh	r0,r0[0x0]
80003a8e:	3a 94       	mov	r4,-87
80003a90:	80 00       	ld.sh	r0,r0[0x0]
80003a92:	4e c0       	lddpc	r0,80003c40 <vPolledQueueConsumer+0x50>

80003a94 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
80003a94:	eb cd 40 f8 	pushm	r3-r7,lr
80003a98:	20 1d       	sub	sp,4
80003a9a:	18 93       	mov	r3,r12
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
80003a9c:	30 06       	mov	r6,0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
80003a9e:	37 b5       	mov	r5,123
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
80003aa0:	e0 64 24 93 	mov	r4,9363
80003aa4:	ea 14 92 49 	orh	r4,0x9249
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
80003aa8:	30 17       	mov	r7,1
80003aaa:	c0 28       	rjmp	80003aae <vCompeteingIntMathTask+0x1a>
80003aac:	0e 96       	mov	r6,r7
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
80003aae:	50 05       	stdsp	sp[0x0],r5
		lValue += intgCONST2;
80003ab0:	40 08       	lddsp	r8,sp[0x0]
80003ab2:	fc 28 6b b9 	sub	r8,-234567
80003ab6:	50 08       	stdsp	sp[0x0],r8
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
80003ab8:	40 08       	lddsp	r8,sp[0x0]
80003aba:	f0 08 01 28 	sub	r8,r8,r8<<0x2
80003abe:	50 08       	stdsp	sp[0x0],r8
		lValue /= intgCONST4;
80003ac0:	40 08       	lddsp	r8,sp[0x0]
80003ac2:	f0 04 04 4a 	muls.d	r10,r8,r4
80003ac6:	f0 0b 00 09 	add	r9,r8,r11
80003aca:	a3 49       	asr	r9,0x2
80003acc:	bf 58       	asr	r8,0x1f
80003ace:	f2 08 01 08 	sub	r8,r9,r8
80003ad2:	50 08       	stdsp	sp[0x0],r8

		/* If the calculation is found to be incorrect we stop setting the
		TaskHasExecuted variable so the check task can see an error has
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
80003ad4:	40 08       	lddsp	r8,sp[0x0]
80003ad6:	fe 48 77 1b 	cp.w	r8,-100581
80003ada:	ce 91       	brne	80003aac <vCompeteingIntMathTask+0x18>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80003adc:	58 06       	cp.w	r6,0
80003ade:	ce 81       	brne	80003aae <vCompeteingIntMathTask+0x1a>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
80003ae0:	f0 1f 00 03 	mcall	80003aec <vCompeteingIntMathTask+0x58>
				*pxTaskHasExecuted = pdTRUE;
80003ae4:	87 07       	st.w	r3[0x0],r7
			portEXIT_CRITICAL();
80003ae6:	f0 1f 00 03 	mcall	80003af0 <vCompeteingIntMathTask+0x5c>
80003aea:	ce 2b       	rjmp	80003aae <vCompeteingIntMathTask+0x1a>
80003aec:	80 00       	ld.sh	r0,r0[0x0]
80003aee:	3f a8       	mov	r8,-6
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	40 b4       	lddsp	r4,sp[0x2c]

80003af4 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
80003af4:	48 88       	lddpc	r8,80003b14 <xArePollingQueuesStillRunning+0x20>
80003af6:	70 08       	ld.w	r8,r8[0x0]
80003af8:	58 08       	cp.w	r8,0
80003afa:	c0 31       	brne	80003b00 <xArePollingQueuesStillRunning+0xc>
80003afc:	30 0c       	mov	r12,0
80003afe:	c0 58       	rjmp	80003b08 <xArePollingQueuesStillRunning+0x14>
		( xPollingProducerCount == pollqINITIAL_VALUE )
80003b00:	48 68       	lddpc	r8,80003b18 <xArePollingQueuesStillRunning+0x24>
80003b02:	70 08       	ld.w	r8,r8[0x0]
80003b04:	58 08       	cp.w	r8,0
80003b06:	5f 1c       	srne	r12
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
80003b08:	30 08       	mov	r8,0
80003b0a:	48 39       	lddpc	r9,80003b14 <xArePollingQueuesStillRunning+0x20>
80003b0c:	93 08       	st.w	r9[0x0],r8
	xPollingProducerCount = pollqINITIAL_VALUE;
80003b0e:	48 39       	lddpc	r9,80003b18 <xArePollingQueuesStillRunning+0x24>
80003b10:	93 08       	st.w	r9[0x0],r8

	return xReturn;
}
80003b12:	5e fc       	retal	r12
80003b14:	00 00       	add	r0,r0
80003b16:	07 a0       	ld.ub	r0,r3[0x2]
80003b18:	00 00       	add	r0,r0
80003b1a:	07 9c       	ld.ub	r12,r3[0x1]

80003b1c <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
80003b1c:	eb cd 40 e0 	pushm	r5-r7,lr
80003b20:	18 95       	mov	r5,r12
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80003b22:	30 2b       	mov	r11,2
80003b24:	30 ac       	mov	r12,10
80003b26:	f0 1f 00 10 	mcall	80003b64 <vStartPolledQueueTasks+0x48>
80003b2a:	49 06       	lddpc	r6,80003b68 <vStartPolledQueueTasks+0x4c>
80003b2c:	8d 0c       	st.w	r6[0x0],r12
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
80003b2e:	30 07       	mov	r7,0
80003b30:	1a d7       	st.w	--sp,r7
80003b32:	1a d7       	st.w	--sp,r7
80003b34:	1a d7       	st.w	--sp,r7
80003b36:	0a 98       	mov	r8,r5
80003b38:	0c 99       	mov	r9,r6
80003b3a:	e0 6a 01 00 	mov	r10,256
80003b3e:	48 cb       	lddpc	r11,80003b6c <vStartPolledQueueTasks+0x50>
80003b40:	48 cc       	lddpc	r12,80003b70 <vStartPolledQueueTasks+0x54>
80003b42:	f0 1f 00 0d 	mcall	80003b74 <vStartPolledQueueTasks+0x58>
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
80003b46:	1a d7       	st.w	--sp,r7
80003b48:	1a d7       	st.w	--sp,r7
80003b4a:	1a d7       	st.w	--sp,r7
80003b4c:	0a 98       	mov	r8,r5
80003b4e:	0c 99       	mov	r9,r6
80003b50:	e0 6a 01 00 	mov	r10,256
80003b54:	48 9b       	lddpc	r11,80003b78 <vStartPolledQueueTasks+0x5c>
80003b56:	48 ac       	lddpc	r12,80003b7c <vStartPolledQueueTasks+0x60>
80003b58:	f0 1f 00 07 	mcall	80003b74 <vStartPolledQueueTasks+0x58>
80003b5c:	2f ad       	sub	sp,-24
}
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b62:	00 00       	add	r0,r0
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	45 e8       	lddsp	r8,sp[0x178]
80003b68:	00 00       	add	r0,r0
80003b6a:	07 a4       	ld.ub	r4,r3[0x2]
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	68 f4       	ld.w	r4,r4[0x3c]
80003b70:	80 00       	ld.sh	r0,r0[0x0]
80003b72:	3b f0       	mov	r0,-65
80003b74:	80 00       	ld.sh	r0,r0[0x0]
80003b76:	4e c0       	lddpc	r0,80003d24 <vStartSemaphoreTasks+0x64>
80003b78:	80 00       	ld.sh	r0,r0[0x0]
80003b7a:	68 fc       	ld.w	r12,r4[0x3c]
80003b7c:	80 00       	ld.sh	r0,r0[0x0]
80003b7e:	3b 80       	mov	r0,-72

80003b80 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
80003b80:	d4 31       	pushm	r0-r7,lr
80003b82:	20 1d       	sub	sp,4
80003b84:	18 93       	mov	r3,r12
unsigned short usValue = ( unsigned short ) 0;
80003b86:	fa c4 ff fc 	sub	r4,sp,-4
80003b8a:	30 08       	mov	r8,0
80003b8c:	08 e8       	st.h	--r4,r8
80003b8e:	30 07       	mov	r7,0
80003b90:	0e 92       	mov	r2,r7
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
80003b92:	0e 96       	mov	r6,r7
				if( xError == pdFALSE )
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
						xPollingProducerCount++;
80003b94:	49 20       	lddpc	r0,80003bdc <vPolledQueueProducer+0x5c>
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
80003b96:	30 11       	mov	r1,1
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
80003b98:	e0 65 00 c8 	mov	r5,200
80003b9c:	c1 88       	rjmp	80003bcc <vPolledQueueProducer+0x4c>
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
80003b9e:	0c 99       	mov	r9,r6
80003ba0:	0c 9a       	mov	r10,r6
80003ba2:	08 9b       	mov	r11,r4
80003ba4:	66 0c       	ld.w	r12,r3[0x0]
80003ba6:	f0 1f 00 0f 	mcall	80003be0 <vPolledQueueProducer+0x60>
80003baa:	58 1c       	cp.w	r12,1
80003bac:	c0 30       	breq	80003bb2 <vPolledQueueProducer+0x32>
80003bae:	02 92       	mov	r2,r1
80003bb0:	c0 d8       	rjmp	80003bca <vPolledQueueProducer+0x4a>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
80003bb2:	58 02       	cp.w	r2,0
80003bb4:	c0 81       	brne	80003bc4 <vPolledQueueProducer+0x44>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
80003bb6:	f0 1f 00 0c 	mcall	80003be4 <vPolledQueueProducer+0x64>
						xPollingProducerCount++;
80003bba:	60 08       	ld.w	r8,r0[0x0]
80003bbc:	2f f8       	sub	r8,-1
80003bbe:	81 08       	st.w	r0[0x0],r8
					portEXIT_CRITICAL();
80003bc0:	f0 1f 00 0a 	mcall	80003be8 <vPolledQueueProducer+0x68>
				}

				/* Update the value we are going to post next time around. */
				usValue++;
80003bc4:	9a 18       	ld.sh	r8,sp[0x2]
80003bc6:	2f f8       	sub	r8,-1
80003bc8:	ba 18       	st.h	sp[0x2],r8
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
80003bca:	2f f7       	sub	r7,-1
80003bcc:	58 27       	cp.w	r7,2
80003bce:	fe 9a ff e8 	brle	80003b9e <vPolledQueueProducer+0x1e>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
80003bd2:	0a 9c       	mov	r12,r5
80003bd4:	f0 1f 00 06 	mcall	80003bec <vPolledQueueProducer+0x6c>
80003bd8:	0c 97       	mov	r7,r6
80003bda:	cf 9b       	rjmp	80003bcc <vPolledQueueProducer+0x4c>
80003bdc:	00 00       	add	r0,r0
80003bde:	07 9c       	ld.ub	r12,r3[0x1]
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	44 e8       	lddsp	r8,sp[0x138]
80003be4:	80 00       	ld.sh	r0,r0[0x0]
80003be6:	3f a8       	mov	r8,-6
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	40 b4       	lddsp	r4,sp[0x2c]
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	4d 20       	lddpc	r0,80003d34 <vStartSemaphoreTasks+0x74>

80003bf0 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
80003bf0:	d4 31       	pushm	r0-r7,lr
80003bf2:	20 1d       	sub	sp,4
80003bf4:	18 97       	mov	r7,r12
80003bf6:	30 00       	mov	r0,0
80003bf8:	00 91       	mov	r1,r0
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
80003bfa:	18 94       	mov	r4,r12
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
80003bfc:	fa c3 ff fe 	sub	r3,sp,-2
80003c00:	00 92       	mov	r2,r0
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
80003c02:	e0 66 00 b4 	mov	r6,180
80003c06:	c1 c8       	rjmp	80003c3e <vPolledQueueConsumer+0x4e>
	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
80003c08:	04 99       	mov	r9,r2
80003c0a:	04 9a       	mov	r10,r2
80003c0c:	06 9b       	mov	r11,r3
80003c0e:	68 0c       	ld.w	r12,r4[0x0]
80003c10:	f0 1f 00 10 	mcall	80003c50 <vPolledQueueConsumer+0x60>
80003c14:	58 1c       	cp.w	r12,1
80003c16:	c1 41       	brne	80003c3e <vPolledQueueConsumer+0x4e>
			{
				if( usData != usExpectedValue )
80003c18:	9a 15       	ld.sh	r5,sp[0x2]
80003c1a:	e2 05 19 00 	cp.h	r5,r1
80003c1e:	c0 30       	breq	80003c24 <vPolledQueueConsumer+0x34>
80003c20:	30 10       	mov	r0,1
80003c22:	c0 b8       	rjmp	80003c38 <vPolledQueueConsumer+0x48>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
80003c24:	58 00       	cp.w	r0,0
80003c26:	c0 91       	brne	80003c38 <vPolledQueueConsumer+0x48>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
80003c28:	f0 1f 00 0b 	mcall	80003c54 <vPolledQueueConsumer+0x64>
							xPollingConsumerCount++;
80003c2c:	48 b9       	lddpc	r9,80003c58 <vPolledQueueConsumer+0x68>
80003c2e:	72 08       	ld.w	r8,r9[0x0]
80003c30:	2f f8       	sub	r8,-1
80003c32:	93 08       	st.w	r9[0x0],r8
						portEXIT_CRITICAL();
80003c34:	f0 1f 00 0a 	mcall	80003c5c <vPolledQueueConsumer+0x6c>
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
80003c38:	2f f5       	sub	r5,-1
80003c3a:	e3 d5 b0 10 	bfexts	r1,r5,0x0,0x10
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
80003c3e:	6e 0c       	ld.w	r12,r7[0x0]
80003c40:	f0 1f 00 08 	mcall	80003c60 <vPolledQueueConsumer+0x70>
80003c44:	ce 21       	brne	80003c08 <vPolledQueueConsumer+0x18>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
80003c46:	0c 9c       	mov	r12,r6
80003c48:	f0 1f 00 07 	mcall	80003c64 <vPolledQueueConsumer+0x74>
80003c4c:	cf 9b       	rjmp	80003c3e <vPolledQueueConsumer+0x4e>
80003c4e:	00 00       	add	r0,r0
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	43 cc       	lddsp	r12,sp[0xf0]
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	3f a8       	mov	r8,-6
80003c58:	00 00       	add	r0,r0
80003c5a:	07 a0       	ld.ub	r0,r3[0x2]
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	40 b4       	lddsp	r4,sp[0x2c]
80003c60:	80 00       	ld.sh	r0,r0[0x0]
80003c62:	41 d8       	lddsp	r8,sp[0x74]
80003c64:	80 00       	ld.sh	r0,r0[0x0]
80003c66:	4d 20       	lddpc	r0,80003dac <vStartSemaphoreTasks+0xec>

80003c68 <xAreSemaphoreTasksStillRunning>:
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
80003c68:	49 49       	lddpc	r9,80003cb8 <xAreSemaphoreTasksStillRunning+0x50>
80003c6a:	92 0a       	ld.sh	r10,r9[0x0]
80003c6c:	49 48       	lddpc	r8,80003cbc <xAreSemaphoreTasksStillRunning+0x54>
80003c6e:	90 0b       	ld.sh	r11,r8[0x0]
80003c70:	f4 0b 19 00 	cp.h	r11,r10
80003c74:	5f 1c       	srne	r12
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
80003c76:	92 0a       	ld.sh	r10,r9[0x0]
80003c78:	b0 0a       	st.h	r8[0x0],r10
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
80003c7a:	92 19       	ld.sh	r9,r9[0x2]
80003c7c:	90 18       	ld.sh	r8,r8[0x2]
80003c7e:	f2 08 19 00 	cp.h	r8,r9
80003c82:	f9 bc 00 00 	moveq	r12,0
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
80003c86:	48 d8       	lddpc	r8,80003cb8 <xAreSemaphoreTasksStillRunning+0x50>
80003c88:	90 1a       	ld.sh	r10,r8[0x2]
80003c8a:	48 d9       	lddpc	r9,80003cbc <xAreSemaphoreTasksStillRunning+0x54>
80003c8c:	b2 1a       	st.h	r9[0x2],r10
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
80003c8e:	90 28       	ld.sh	r8,r8[0x4]
80003c90:	92 29       	ld.sh	r9,r9[0x4]
80003c92:	f0 09 19 00 	cp.h	r9,r8
80003c96:	f9 bc 00 00 	moveq	r12,0
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
80003c9a:	48 88       	lddpc	r8,80003cb8 <xAreSemaphoreTasksStillRunning+0x50>
80003c9c:	90 2a       	ld.sh	r10,r8[0x4]
80003c9e:	48 89       	lddpc	r9,80003cbc <xAreSemaphoreTasksStillRunning+0x54>
80003ca0:	b2 2a       	st.h	r9[0x4],r10
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
80003ca2:	90 38       	ld.sh	r8,r8[0x6]
80003ca4:	92 39       	ld.sh	r9,r9[0x6]
80003ca6:	f0 09 19 00 	cp.h	r9,r8
80003caa:	f9 bc 00 00 	moveq	r12,0
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
80003cae:	48 38       	lddpc	r8,80003cb8 <xAreSemaphoreTasksStillRunning+0x50>
80003cb0:	90 39       	ld.sh	r9,r8[0x6]
80003cb2:	48 38       	lddpc	r8,80003cbc <xAreSemaphoreTasksStillRunning+0x54>
80003cb4:	b0 39       	st.h	r8[0x6],r9
	}

	return xReturn;
}
80003cb6:	5e fc       	retal	r12
80003cb8:	00 00       	add	r0,r0
80003cba:	07 a8       	ld.ub	r8,r3[0x2]
80003cbc:	00 00       	add	r0,r0
80003cbe:	07 b0       	ld.ub	r0,r3[0x3]

80003cc0 <vStartSemaphoreTasks>:
static volatile short sNextCheckVariable = 0;

/*-----------------------------------------------------------*/

void vStartSemaphoreTasks( unsigned portBASE_TYPE uxPriority )
{
80003cc0:	d4 21       	pushm	r4-r7,lr
80003cc2:	18 95       	mov	r5,r12
xSemaphoreParameters *pxFirstSemaphoreParameters, *pxSecondSemaphoreParameters;
const portTickType xBlockTime = ( portTickType ) 100;

	/* Create the structure used to pass parameters to the first two tasks. */
	pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
80003cc4:	30 cc       	mov	r12,12
80003cc6:	f0 1f 00 35 	mcall	80003d98 <vStartSemaphoreTasks+0xd8>
80003cca:	18 97       	mov	r7,r12

	if( pxFirstSemaphoreParameters != NULL )
80003ccc:	c3 00       	breq	80003d2c <vStartSemaphoreTasks+0x6c>
	{
		/* Create the semaphore used by the first two tasks. */
		vSemaphoreCreateBinary( pxFirstSemaphoreParameters->xSemaphore );
80003cce:	30 0b       	mov	r11,0
80003cd0:	30 1c       	mov	r12,1
80003cd2:	f0 1f 00 33 	mcall	80003d9c <vStartSemaphoreTasks+0xdc>
80003cd6:	8f 0c       	st.w	r7[0x0],r12
80003cd8:	c2 a0       	breq	80003d2c <vStartSemaphoreTasks+0x6c>
80003cda:	30 09       	mov	r9,0
80003cdc:	12 9a       	mov	r10,r9
80003cde:	12 9b       	mov	r11,r9
80003ce0:	f0 1f 00 30 	mcall	80003da0 <vStartSemaphoreTasks+0xe0>

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
80003ce4:	6e 08       	ld.w	r8,r7[0x0]
80003ce6:	58 08       	cp.w	r8,0
80003ce8:	c2 20       	breq	80003d2c <vStartSemaphoreTasks+0x6c>
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80003cea:	30 4c       	mov	r12,4
80003cec:	f0 1f 00 2b 	mcall	80003d98 <vStartSemaphoreTasks+0xd8>
80003cf0:	8f 1c       	st.w	r7[0x4],r12

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
80003cf2:	e0 68 00 ff 	mov	r8,255
80003cf6:	99 08       	st.w	r12[0x0],r8

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;
80003cf8:	30 06       	mov	r6,0
80003cfa:	8f 26       	st.w	r7[0x8],r6

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80003cfc:	4a a4       	lddpc	r4,80003da4 <vStartSemaphoreTasks+0xe4>
80003cfe:	1a d6       	st.w	--sp,r6
80003d00:	1a d6       	st.w	--sp,r6
80003d02:	1a d6       	st.w	--sp,r6
80003d04:	0c 98       	mov	r8,r6
80003d06:	0e 99       	mov	r9,r7
80003d08:	e0 6a 01 00 	mov	r10,256
80003d0c:	4a 7b       	lddpc	r11,80003da8 <vStartSemaphoreTasks+0xe8>
80003d0e:	08 9c       	mov	r12,r4
80003d10:	f0 1f 00 27 	mcall	80003dac <vStartSemaphoreTasks+0xec>
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80003d14:	1a d6       	st.w	--sp,r6
80003d16:	1a d6       	st.w	--sp,r6
80003d18:	1a d6       	st.w	--sp,r6
80003d1a:	0c 98       	mov	r8,r6
80003d1c:	0e 99       	mov	r9,r7
80003d1e:	e0 6a 01 00 	mov	r10,256
80003d22:	4a 4b       	lddpc	r11,80003db0 <vStartSemaphoreTasks+0xf0>
80003d24:	08 9c       	mov	r12,r4
80003d26:	f0 1f 00 22 	mcall	80003dac <vStartSemaphoreTasks+0xec>
80003d2a:	2f ad       	sub	sp,-24
		}
	}

	/* Do exactly the same to create the second set of tasks, only this time
	provide a block time for the semaphore calls. */
	pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
80003d2c:	30 cc       	mov	r12,12
80003d2e:	f0 1f 00 1b 	mcall	80003d98 <vStartSemaphoreTasks+0xd8>
80003d32:	18 97       	mov	r7,r12
	if( pxSecondSemaphoreParameters != NULL )
80003d34:	c3 10       	breq	80003d96 <vStartSemaphoreTasks+0xd6>
	{
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );
80003d36:	30 0b       	mov	r11,0
80003d38:	30 1c       	mov	r12,1
80003d3a:	f0 1f 00 19 	mcall	80003d9c <vStartSemaphoreTasks+0xdc>
80003d3e:	8f 0c       	st.w	r7[0x0],r12
80003d40:	c2 b0       	breq	80003d96 <vStartSemaphoreTasks+0xd6>
80003d42:	30 09       	mov	r9,0
80003d44:	12 9a       	mov	r10,r9
80003d46:	12 9b       	mov	r11,r9
80003d48:	f0 1f 00 16 	mcall	80003da0 <vStartSemaphoreTasks+0xe0>

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
80003d4c:	6e 08       	ld.w	r8,r7[0x0]
80003d4e:	58 08       	cp.w	r8,0
80003d50:	c2 30       	breq	80003d96 <vStartSemaphoreTasks+0xd6>
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80003d52:	30 4c       	mov	r12,4
80003d54:	f0 1f 00 11 	mcall	80003d98 <vStartSemaphoreTasks+0xd8>
80003d58:	8f 1c       	st.w	r7[0x4],r12
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
80003d5a:	e0 68 0f ff 	mov	r8,4095
80003d5e:	99 08       	st.w	r12[0x0],r8
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;
80003d60:	36 48       	mov	r8,100
80003d62:	8f 28       	st.w	r7[0x8],r8

			xTaskCreate( prvSemaphoreTest, ( signed char * ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80003d64:	49 04       	lddpc	r4,80003da4 <vStartSemaphoreTasks+0xe4>
80003d66:	30 06       	mov	r6,0
80003d68:	1a d6       	st.w	--sp,r6
80003d6a:	1a d6       	st.w	--sp,r6
80003d6c:	1a d6       	st.w	--sp,r6
80003d6e:	0a 98       	mov	r8,r5
80003d70:	0e 99       	mov	r9,r7
80003d72:	e0 6a 01 00 	mov	r10,256
80003d76:	49 0b       	lddpc	r11,80003db4 <vStartSemaphoreTasks+0xf4>
80003d78:	08 9c       	mov	r12,r4
80003d7a:	f0 1f 00 0d 	mcall	80003dac <vStartSemaphoreTasks+0xec>
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80003d7e:	1a d6       	st.w	--sp,r6
80003d80:	1a d6       	st.w	--sp,r6
80003d82:	1a d6       	st.w	--sp,r6
80003d84:	0a 98       	mov	r8,r5
80003d86:	0e 99       	mov	r9,r7
80003d88:	e0 6a 01 00 	mov	r10,256
80003d8c:	48 bb       	lddpc	r11,80003db8 <vStartSemaphoreTasks+0xf8>
80003d8e:	08 9c       	mov	r12,r4
80003d90:	f0 1f 00 07 	mcall	80003dac <vStartSemaphoreTasks+0xec>
80003d94:	2f ad       	sub	sp,-24
80003d96:	d8 22       	popm	r4-r7,pc
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	41 b0       	lddsp	r0,sp[0x6c]
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	45 e8       	lddsp	r8,sp[0x178]
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	44 e8       	lddsp	r8,sp[0x138]
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	3d bc       	mov	r12,-37
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	69 04       	ld.w	r4,r4[0x40]
80003dac:	80 00       	ld.sh	r0,r0[0x0]
80003dae:	4e c0       	lddpc	r0,80003f5c <pxPortInitialiseStack+0x48>
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	69 0c       	ld.w	r12,r4[0x40]
80003db4:	80 00       	ld.sh	r0,r0[0x0]
80003db6:	69 14       	ld.w	r4,r4[0x44]
80003db8:	80 00       	ld.sh	r0,r0[0x0]
80003dba:	69 1c       	ld.w	r12,r4[0x44]

80003dbc <prvSemaphoreTest>:
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
80003dbc:	d4 31       	pushm	r0-r7,lr
80003dbe:	20 1d       	sub	sp,4
80003dc0:	18 95       	mov	r5,r12
unsigned long ulCounter;
short sError = pdFALSE, sCheckVariableToUse;

	/* See which check variable to use.  sNextCheckVariable is not semaphore
	protected! */
	portENTER_CRITICAL();
80003dc2:	f0 1f 00 2a 	mcall	80003e68 <prvSemaphoreTest+0xac>
		sCheckVariableToUse = sNextCheckVariable;
80003dc6:	4a a8       	lddpc	r8,80003e6c <prvSemaphoreTest+0xb0>
80003dc8:	90 02       	ld.sh	r2,r8[0x0]
		sNextCheckVariable++;
80003dca:	90 09       	ld.sh	r9,r8[0x0]
80003dcc:	2f f9       	sub	r9,-1
80003dce:	b0 09       	st.h	r8[0x0],r9
	portEXIT_CRITICAL();
80003dd0:	f0 1f 00 28 	mcall	80003e70 <prvSemaphoreTest+0xb4>

	/* A structure is passed in as the parameter.  This contains the shared
	variable being guarded. */
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
	pulSharedVariable = pxParameters->pulSharedVariable;
80003dd4:	6a 16       	ld.w	r6,r5[0x4]

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( portTickType ) 0 )
80003dd6:	6a 28       	ld.w	r8,r5[0x8]
80003dd8:	58 08       	cp.w	r8,0
80003dda:	c0 50       	breq	80003de4 <prvSemaphoreTest+0x28>
	{
		ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
80003ddc:	e0 68 0f ff 	mov	r8,4095
80003de0:	50 08       	stdsp	sp[0x0],r8
80003de2:	c0 48       	rjmp	80003dea <prvSemaphoreTest+0x2e>
	}
	else
	{
		ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
80003de4:	e0 68 00 ff 	mov	r8,255
80003de8:	50 08       	stdsp	sp[0x0],r8
80003dea:	30 07       	mov	r7,0
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
80003dec:	0e 94       	mov	r4,r7
				sError = pdTRUE;
			}

			if( sError == pdFALSE )
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
80003dee:	30 31       	mov	r1,3
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
80003df0:	30 10       	mov	r0,1
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
80003df2:	08 99       	mov	r9,r4
80003df4:	6a 2a       	ld.w	r10,r5[0x8]
80003df6:	08 9b       	mov	r11,r4
80003df8:	6a 0c       	ld.w	r12,r5[0x0]
80003dfa:	f0 1f 00 1f 	mcall	80003e74 <prvSemaphoreTest+0xb8>
80003dfe:	58 1c       	cp.w	r12,1
80003e00:	c2 e1       	brne	80003e5c <prvSemaphoreTest+0xa0>
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
80003e02:	6c 09       	ld.w	r9,r6[0x0]
80003e04:	40 08       	lddsp	r8,sp[0x0]
80003e06:	10 39       	cp.w	r9,r8
80003e08:	f9 b7 01 01 	movne	r7,1
			}

			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
80003e0c:	40 08       	lddsp	r8,sp[0x0]
80003e0e:	08 98       	mov	r8,r4
			{
				*pulSharedVariable = ulCounter;
80003e10:	8d 08       	st.w	r6[0x0],r8
				if( *pulSharedVariable != ulCounter )
80003e12:	6c 09       	ld.w	r9,r6[0x0]
80003e14:	10 39       	cp.w	r9,r8
80003e16:	f9 b7 01 01 	movne	r7,1
			}

			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
80003e1a:	2f f8       	sub	r8,-1
80003e1c:	40 09       	lddsp	r9,sp[0x0]
80003e1e:	10 39       	cp.w	r9,r8
80003e20:	cf 82       	brcc	80003e10 <prvSemaphoreTest+0x54>
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
80003e22:	08 99       	mov	r9,r4
80003e24:	08 9a       	mov	r10,r4
80003e26:	08 9b       	mov	r11,r4
80003e28:	6a 0c       	ld.w	r12,r5[0x0]
80003e2a:	f0 1f 00 14 	mcall	80003e78 <prvSemaphoreTest+0xbc>
80003e2e:	c0 31       	brne	80003e34 <prvSemaphoreTest+0x78>
80003e30:	00 97       	mov	r7,r0
80003e32:	c0 d8       	rjmp	80003e4c <prvSemaphoreTest+0x90>
			{
				sError = pdTRUE;
			}

			if( sError == pdFALSE )
80003e34:	58 07       	cp.w	r7,0
80003e36:	c0 b1       	brne	80003e4c <prvSemaphoreTest+0x90>
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
80003e38:	e2 02 19 00 	cp.h	r2,r1
80003e3c:	e0 89 00 08 	brgt	80003e4c <prvSemaphoreTest+0x90>
				{
					( sCheckVariables[ sCheckVariableToUse ] )++;
80003e40:	48 f9       	lddpc	r9,80003e7c <prvSemaphoreTest+0xc0>
80003e42:	f2 02 04 18 	ld.sh	r8,r9[r2<<0x1]
80003e46:	2f f8       	sub	r8,-1
80003e48:	f2 02 0a 18 	st.h	r9[r2<<0x1],r8
			/* If we have a block time then we are running at a priority higher
			than the idle priority.  This task takes a long time to complete
			a cycle	(deliberately so to test the guarding) so will be starving
			out lower priority tasks.  Block for some time to allow give lower
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
80003e4c:	6a 28       	ld.w	r8,r5[0x8]
80003e4e:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003e52:	f0 0c 15 01 	lsl	r12,r8,0x1
80003e56:	f0 1f 00 0b 	mcall	80003e80 <prvSemaphoreTest+0xc4>
80003e5a:	cc cb       	rjmp	80003df2 <prvSemaphoreTest+0x36>
		}
		else
		{
			if( pxParameters->xBlockTime == ( portTickType ) 0 )
80003e5c:	6a 28       	ld.w	r8,r5[0x8]
80003e5e:	58 08       	cp.w	r8,0
80003e60:	cc 91       	brne	80003df2 <prvSemaphoreTest+0x36>
			{
				/* We have not got the semaphore yet, so no point using the
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
80003e62:	d7 33       	scall
80003e64:	cc 7b       	rjmp	80003df2 <prvSemaphoreTest+0x36>
80003e66:	00 00       	add	r0,r0
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	3f a8       	mov	r8,-6
80003e6c:	00 00       	add	r0,r0
80003e6e:	07 b8       	ld.ub	r8,r3[0x3]
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	40 b4       	lddsp	r4,sp[0x2c]
80003e74:	80 00       	ld.sh	r0,r0[0x0]
80003e76:	43 cc       	lddsp	r12,sp[0xf0]
80003e78:	80 00       	ld.sh	r0,r0[0x0]
80003e7a:	44 e8       	lddsp	r8,sp[0x138]
80003e7c:	00 00       	add	r0,r0
80003e7e:	07 a8       	ld.ub	r8,r3[0x2]
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	4d 20       	lddpc	r0,80003fc8 <xPortStartScheduler+0x10>

80003e84 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80003e84:	f8 c8 ff f8 	sub	r8,r12,-8
80003e88:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80003e8a:	3f f9       	mov	r9,-1
80003e8c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80003e8e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80003e90:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80003e92:	30 08       	mov	r8,0
80003e94:	99 08       	st.w	r12[0x0],r8
}
80003e96:	5e fc       	retal	r12

80003e98 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80003e98:	30 08       	mov	r8,0
80003e9a:	99 48       	st.w	r12[0x10],r8
}
80003e9c:	5e fc       	retal	r12

80003e9e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80003e9e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80003ea0:	70 19       	ld.w	r9,r8[0x4]
80003ea2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80003ea4:	78 19       	ld.w	r9,r12[0x4]
80003ea6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80003ea8:	70 19       	ld.w	r9,r8[0x4]
80003eaa:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80003eac:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80003eae:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80003eb0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80003eb2:	78 08       	ld.w	r8,r12[0x0]
80003eb4:	2f f8       	sub	r8,-1
80003eb6:	99 08       	st.w	r12[0x0],r8
}
80003eb8:	5e fc       	retal	r12

80003eba <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80003eba:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80003ebc:	5b fa       	cp.w	r10,-1
80003ebe:	c0 31       	brne	80003ec4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80003ec0:	78 48       	ld.w	r8,r12[0x10]
80003ec2:	c0 c8       	rjmp	80003eda <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80003ec4:	f8 c8 ff f8 	sub	r8,r12,-8
80003ec8:	70 19       	ld.w	r9,r8[0x4]
80003eca:	72 09       	ld.w	r9,r9[0x0]
80003ecc:	12 3a       	cp.w	r10,r9
80003ece:	c0 63       	brcs	80003eda <vListInsert+0x20>
80003ed0:	70 18       	ld.w	r8,r8[0x4]
80003ed2:	70 19       	ld.w	r9,r8[0x4]
80003ed4:	72 09       	ld.w	r9,r9[0x0]
80003ed6:	12 3a       	cp.w	r10,r9
80003ed8:	cf c2       	brcc	80003ed0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80003eda:	70 19       	ld.w	r9,r8[0x4]
80003edc:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80003ede:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80003ee0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80003ee2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80003ee4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80003ee6:	78 08       	ld.w	r8,r12[0x0]
80003ee8:	2f f8       	sub	r8,-1
80003eea:	99 08       	st.w	r12[0x0],r8
}
80003eec:	5e fc       	retal	r12

80003eee <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80003eee:	78 18       	ld.w	r8,r12[0x4]
80003ef0:	78 29       	ld.w	r9,r12[0x8]
80003ef2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80003ef4:	78 28       	ld.w	r8,r12[0x8]
80003ef6:	78 19       	ld.w	r9,r12[0x4]
80003ef8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80003efa:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80003efc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80003efe:	18 39       	cp.w	r9,r12
80003f00:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80003f04:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80003f08:	30 09       	mov	r9,0
80003f0a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80003f0c:	70 09       	ld.w	r9,r8[0x0]
80003f0e:	20 19       	sub	r9,1
80003f10:	91 09       	st.w	r8[0x0],r9
}
80003f12:	5e fc       	retal	r12

80003f14 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80003f14:	e0 68 08 08 	mov	r8,2056
80003f18:	ea 18 08 08 	orh	r8,0x808
80003f1c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80003f1e:	e0 68 09 09 	mov	r8,2313
80003f22:	ea 18 09 09 	orh	r8,0x909
80003f26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80003f28:	e0 68 0a 0a 	mov	r8,2570
80003f2c:	ea 18 0a 0a 	orh	r8,0xa0a
80003f30:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80003f32:	e0 68 0b 0b 	mov	r8,2827
80003f36:	ea 18 0b 0b 	orh	r8,0xb0b
80003f3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80003f3c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80003f3e:	e0 68 be ef 	mov	r8,48879
80003f42:	ea 18 de ad 	orh	r8,0xdead
80003f46:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80003f48:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80003f4a:	fc 18 00 40 	movh	r8,0x40
80003f4e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80003f50:	e0 68 00 ff 	mov	r8,255
80003f54:	ea 18 ff 00 	orh	r8,0xff00
80003f58:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80003f5a:	e0 68 01 01 	mov	r8,257
80003f5e:	ea 18 01 01 	orh	r8,0x101
80003f62:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80003f64:	e0 68 02 02 	mov	r8,514
80003f68:	ea 18 02 02 	orh	r8,0x202
80003f6c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80003f6e:	e0 68 03 03 	mov	r8,771
80003f72:	ea 18 03 03 	orh	r8,0x303
80003f76:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80003f78:	e0 68 04 04 	mov	r8,1028
80003f7c:	ea 18 04 04 	orh	r8,0x404
80003f80:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80003f82:	e0 68 05 05 	mov	r8,1285
80003f86:	ea 18 05 05 	orh	r8,0x505
80003f8a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80003f8c:	e0 68 06 06 	mov	r8,1542
80003f90:	ea 18 06 06 	orh	r8,0x606
80003f94:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80003f96:	e0 68 07 07 	mov	r8,1799
80003f9a:	ea 18 07 07 	orh	r8,0x707
80003f9e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80003fa0:	30 08       	mov	r8,0
80003fa2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80003fa4:	5e fc       	retal	r12
80003fa6:	d7 03       	nop

80003fa8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80003fa8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80003faa:	48 38       	lddpc	r8,80003fb4 <vPortEnterCritical+0xc>
80003fac:	70 09       	ld.w	r9,r8[0x0]
80003fae:	2f f9       	sub	r9,-1
80003fb0:	91 09       	st.w	r8[0x0],r9
}
80003fb2:	5e fc       	retal	r12
80003fb4:	00 00       	add	r0,r0
80003fb6:	00 2c       	rsub	r12,r0

80003fb8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80003fb8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80003fba:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80003fbc:	30 0a       	mov	r10,0
80003fbe:	14 9b       	mov	r11,r10
80003fc0:	49 2c       	lddpc	r12,80004008 <xPortStartScheduler+0x50>
80003fc2:	f0 1f 00 13 	mcall	8000400c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80003fc6:	e0 68 3e 80 	mov	r8,16000
80003fca:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80003fce:	30 08       	mov	r8,0
80003fd0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80003fd4:	e0 68 08 8c 	mov	r8,2188
80003fd8:	ea 18 00 00 	orh	r8,0x0
80003fdc:	70 00       	ld.w	r0,r8[0x0]
80003fde:	60 0d       	ld.w	sp,r0[0x0]
80003fe0:	1b 00       	ld.w	r0,sp++
80003fe2:	e0 68 00 2c 	mov	r8,44
80003fe6:	ea 18 00 00 	orh	r8,0x0
80003fea:	91 00       	st.w	r8[0x0],r0
80003fec:	e3 cd 00 ff 	ldm	sp++,r0-r7
80003ff0:	2f ed       	sub	sp,-8
80003ff2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80003ff6:	fa f0 ff e0 	ld.w	r0,sp[-32]
80003ffa:	e3 b0 00 00 	mtsr	0x0,r0
80003ffe:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004002:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004006:	d8 0a       	popm	pc,r12=0
80004008:	80 00       	ld.sh	r0,r0[0x0]
8000400a:	40 d4       	lddsp	r4,sp[0x34]
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	22 c8       	sub	r8,44

80004010 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004010:	20 6d       	sub	sp,24
80004012:	eb cd 00 ff 	pushm	r0-r7
80004016:	fa c7 ff c0 	sub	r7,sp,-64
8000401a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000401e:	ef 40 ff e0 	st.w	r7[-32],r0
80004022:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004026:	ef 40 ff e4 	st.w	r7[-28],r0
8000402a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000402e:	e0 68 00 2c 	mov	r8,44
80004032:	ea 18 00 00 	orh	r8,0x0
80004036:	70 00       	ld.w	r0,r8[0x0]
80004038:	1a d0       	st.w	--sp,r0
8000403a:	f0 1f 00 1a 	mcall	800040a0 <LABEL_RET_SCALL_260+0x14>
8000403e:	e0 68 08 8c 	mov	r8,2188
80004042:	ea 18 00 00 	orh	r8,0x0
80004046:	70 00       	ld.w	r0,r8[0x0]
80004048:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000404a:	f0 1f 00 17 	mcall	800040a4 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
8000404e:	e0 68 08 8c 	mov	r8,2188
80004052:	ea 18 00 00 	orh	r8,0x0
80004056:	70 00       	ld.w	r0,r8[0x0]
80004058:	60 0d       	ld.w	sp,r0[0x0]
8000405a:	1b 00       	ld.w	r0,sp++
8000405c:	e0 68 00 2c 	mov	r8,44
80004060:	ea 18 00 00 	orh	r8,0x0
80004064:	91 00       	st.w	r8[0x0],r0
80004066:	fa c7 ff d8 	sub	r7,sp,-40
8000406a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000406e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004072:	e0 61 00 2c 	mov	r1,44
80004076:	ea 11 00 00 	orh	r1,0x0
8000407a:	62 02       	ld.w	r2,r1[0x0]
8000407c:	58 02       	cp.w	r2,0
8000407e:	c0 70       	breq	8000408c <LABEL_RET_SCALL_260>
80004080:	e4 c2 00 01 	sub	r2,r2,1
80004084:	83 02       	st.w	r1[0x0],r2
80004086:	58 02       	cp.w	r2,0
80004088:	c0 21       	brne	8000408c <LABEL_RET_SCALL_260>
8000408a:	b1 c0       	cbr	r0,0x10

8000408c <LABEL_RET_SCALL_260>:
8000408c:	ef 40 ff f8 	st.w	r7[-8],r0
80004090:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004094:	ef 40 ff fc 	st.w	r7[-4],r0
80004098:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000409c:	2f ad       	sub	sp,-24
8000409e:	d6 13       	rets
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	3f a8       	mov	r8,-6
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	46 98       	lddsp	r8,sp[0x1a4]

800040a8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800040a8:	e1 b8 00 43 	mfsr	r8,0x10c
800040ac:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800040b0:	5e fc       	retal	r12
800040b2:	d7 03       	nop

800040b4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800040b4:	48 78       	lddpc	r8,800040d0 <vPortExitCritical+0x1c>
800040b6:	70 08       	ld.w	r8,r8[0x0]
800040b8:	58 08       	cp.w	r8,0
800040ba:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800040bc:	48 58       	lddpc	r8,800040d0 <vPortExitCritical+0x1c>
800040be:	70 09       	ld.w	r9,r8[0x0]
800040c0:	20 19       	sub	r9,1
800040c2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800040c4:	70 08       	ld.w	r8,r8[0x0]
800040c6:	58 08       	cp.w	r8,0
800040c8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800040ca:	d5 03       	csrf	0x10
800040cc:	5e fc       	retal	r12
800040ce:	00 00       	add	r0,r0
800040d0:	00 00       	add	r0,r0
800040d2:	00 2c       	rsub	r12,r0

800040d4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800040d4:	eb cd 00 ff 	pushm	r0-r7
800040d8:	e0 68 00 2c 	mov	r8,44
800040dc:	ea 18 00 00 	orh	r8,0x0
800040e0:	70 00       	ld.w	r0,r8[0x0]
800040e2:	1a d0       	st.w	--sp,r0
800040e4:	7a 90       	ld.w	r0,sp[0x24]
800040e6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800040ea:	58 10       	cp.w	r0,1
800040ec:	e0 8b 00 08 	brhi	800040fc <LABEL_INT_SKIP_SAVE_CONTEXT_234>
800040f0:	e0 68 08 8c 	mov	r8,2188
800040f4:	ea 18 00 00 	orh	r8,0x0
800040f8:	70 00       	ld.w	r0,r8[0x0]
800040fa:	81 0d       	st.w	r0[0x0],sp

800040fc <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800040fc:	f0 1f 00 12 	mcall	80004144 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004100:	f0 1f 00 12 	mcall	80004148 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80004104:	f0 1f 00 12 	mcall	8000414c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80004108:	f0 1f 00 12 	mcall	80004150 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000410c:	7a 90       	ld.w	r0,sp[0x24]
8000410e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004112:	58 10       	cp.w	r0,1
80004114:	e0 8b 00 0e 	brhi	80004130 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80004118:	f0 1f 00 0c 	mcall	80004148 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
8000411c:	f0 1f 00 0e 	mcall	80004154 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80004120:	f0 1f 00 0c 	mcall	80004150 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80004124:	e0 68 08 8c 	mov	r8,2188
80004128:	ea 18 00 00 	orh	r8,0x0
8000412c:	70 00       	ld.w	r0,r8[0x0]
8000412e:	60 0d       	ld.w	sp,r0[0x0]

80004130 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80004130:	1b 00       	ld.w	r0,sp++
80004132:	e0 68 00 2c 	mov	r8,44
80004136:	ea 18 00 00 	orh	r8,0x0
8000413a:	91 00       	st.w	r8[0x0],r0
8000413c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004140:	d6 03       	rete
80004142:	00 00       	add	r0,r0
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	40 a8       	lddsp	r8,sp[0x28]
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	3f a8       	mov	r8,-6
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	48 78       	lddpc	r8,80004168 <__malloc_unlock+0x4>
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	40 b4       	lddsp	r4,sp[0x2c]
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	46 98       	lddsp	r8,sp[0x1a4]

80004158 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004158:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000415a:	f0 1f 00 02 	mcall	80004160 <__malloc_lock+0x8>
}
8000415e:	d8 02       	popm	pc
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	46 7c       	lddsp	r12,sp[0x19c]

80004164 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004164:	d4 01       	pushm	lr
	xTaskResumeAll();
80004166:	f0 1f 00 02 	mcall	8000416c <__malloc_unlock+0x8>
}
8000416a:	d8 02       	popm	pc
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	49 8c       	lddpc	r12,800041cc <pvPortMalloc+0x1c>

80004170 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004170:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004172:	48 48       	lddpc	r8,80004180 <_init_startup+0x10>
80004174:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004178:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
8000417a:	f0 1f 00 03 	mcall	80004184 <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
8000417e:	da 0a       	popm	pc,r12=1
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	64 00       	ld.w	r0,r2[0x0]
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	23 48       	sub	r8,52

80004188 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004188:	eb cd 40 80 	pushm	r7,lr
8000418c:	18 97       	mov	r7,r12
	if( pv )
8000418e:	58 0c       	cp.w	r12,0
80004190:	c0 80       	breq	800041a0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004192:	f0 1f 00 05 	mcall	800041a4 <vPortFree+0x1c>
		{
			free( pv );
80004196:	0e 9c       	mov	r12,r7
80004198:	f0 1f 00 04 	mcall	800041a8 <vPortFree+0x20>
		}
		xTaskResumeAll();
8000419c:	f0 1f 00 04 	mcall	800041ac <vPortFree+0x24>
800041a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	46 7c       	lddsp	r12,sp[0x19c]
800041a8:	80 00       	ld.sh	r0,r0[0x0]
800041aa:	5a 0c       	cp.w	r12,-32
800041ac:	80 00       	ld.sh	r0,r0[0x0]
800041ae:	49 8c       	lddpc	r12,8000420c <prvCopyDataFromQueue+0x14>

800041b0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800041b0:	eb cd 40 80 	pushm	r7,lr
800041b4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800041b6:	f0 1f 00 06 	mcall	800041cc <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800041ba:	0e 9c       	mov	r12,r7
800041bc:	f0 1f 00 05 	mcall	800041d0 <pvPortMalloc+0x20>
800041c0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800041c2:	f0 1f 00 05 	mcall	800041d4 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800041c6:	0e 9c       	mov	r12,r7
800041c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	46 7c       	lddsp	r12,sp[0x19c]
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	5a 1c       	cp.w	r12,-31
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	49 8c       	lddpc	r12,80004234 <xQueueReceiveFromISR+0xc>

800041d8 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
800041d8:	eb cd 40 80 	pushm	r7,lr
800041dc:	18 97       	mov	r7,r12
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
800041de:	f0 1f 00 05 	mcall	800041f0 <uxQueueMessagesWaiting+0x18>
		uxReturn = pxQueue->uxMessagesWaiting;
800041e2:	6e e7       	ld.w	r7,r7[0x38]
	taskEXIT_CRITICAL();
800041e4:	f0 1f 00 04 	mcall	800041f4 <uxQueueMessagesWaiting+0x1c>

	return uxReturn;
}
800041e8:	0e 9c       	mov	r12,r7
800041ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800041ee:	00 00       	add	r0,r0
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	3f a8       	mov	r8,-6
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	40 b4       	lddsp	r4,sp[0x2c]

800041f8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800041f8:	d4 01       	pushm	lr
800041fa:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800041fc:	78 09       	ld.w	r9,r12[0x0]
800041fe:	58 09       	cp.w	r9,0
80004200:	c1 10       	breq	80004222 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004202:	78 3a       	ld.w	r10,r12[0xc]
80004204:	79 09       	ld.w	r9,r12[0x40]
80004206:	f4 09 00 09 	add	r9,r10,r9
8000420a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000420c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000420e:	14 39       	cp.w	r9,r10
80004210:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004214:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004218:	79 0a       	ld.w	r10,r12[0x40]
8000421a:	78 3b       	ld.w	r11,r12[0xc]
8000421c:	10 9c       	mov	r12,r8
8000421e:	f0 1f 00 02 	mcall	80004224 <prvCopyDataFromQueue+0x2c>
80004222:	d8 02       	popm	pc
80004224:	80 00       	ld.sh	r0,r0[0x0]
80004226:	5e 60       	retmi	r0

80004228 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004228:	eb cd 40 c0 	pushm	r6-r7,lr
8000422c:	18 97       	mov	r7,r12
8000422e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004230:	78 e8       	ld.w	r8,r12[0x38]
80004232:	58 08       	cp.w	r8,0
80004234:	c0 31       	brne	8000423a <xQueueReceiveFromISR+0x12>
80004236:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000423a:	f0 1f 00 0e 	mcall	80004270 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000423e:	6e e8       	ld.w	r8,r7[0x38]
80004240:	20 18       	sub	r8,1
80004242:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004244:	6f 18       	ld.w	r8,r7[0x44]
80004246:	5b f8       	cp.w	r8,-1
80004248:	c0 d1       	brne	80004262 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000424a:	6e 48       	ld.w	r8,r7[0x10]
8000424c:	58 08       	cp.w	r8,0
8000424e:	c0 f0       	breq	8000426c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004250:	ee cc ff f0 	sub	r12,r7,-16
80004254:	f0 1f 00 08 	mcall	80004274 <xQueueReceiveFromISR+0x4c>
80004258:	c0 a0       	breq	8000426c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000425a:	30 1c       	mov	r12,1
8000425c:	8d 0c       	st.w	r6[0x0],r12
8000425e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004262:	2f f8       	sub	r8,-1
80004264:	ef 48 00 44 	st.w	r7[68],r8
80004268:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000426c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	41 f8       	lddsp	r8,sp[0x7c]
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	47 f8       	lddsp	r8,sp[0x1fc]

80004278 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80004278:	eb cd 40 80 	pushm	r7,lr
8000427c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000427e:	79 08       	ld.w	r8,r12[0x40]
80004280:	58 08       	cp.w	r8,0
80004282:	c2 50       	breq	800042cc <prvCopyDataToQueue+0x54>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80004284:	58 0a       	cp.w	r10,0
80004286:	c1 01       	brne	800042a6 <prvCopyDataToQueue+0x2e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004288:	10 9a       	mov	r10,r8
8000428a:	78 2c       	ld.w	r12,r12[0x8]
8000428c:	f0 1f 00 13 	mcall	800042d8 <prvCopyDataToQueue+0x60>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80004290:	6e 29       	ld.w	r9,r7[0x8]
80004292:	6f 08       	ld.w	r8,r7[0x40]
80004294:	f2 08 00 08 	add	r8,r9,r8
80004298:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000429a:	6e 19       	ld.w	r9,r7[0x4]
8000429c:	12 38       	cp.w	r8,r9
8000429e:	c1 73       	brcs	800042cc <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800042a0:	6e 08       	ld.w	r8,r7[0x0]
800042a2:	8f 28       	st.w	r7[0x8],r8
800042a4:	c1 48       	rjmp	800042cc <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800042a6:	10 9a       	mov	r10,r8
800042a8:	78 3c       	ld.w	r12,r12[0xc]
800042aa:	f0 1f 00 0c 	mcall	800042d8 <prvCopyDataToQueue+0x60>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800042ae:	6f 08       	ld.w	r8,r7[0x40]
800042b0:	6e 39       	ld.w	r9,r7[0xc]
800042b2:	f2 08 01 08 	sub	r8,r9,r8
800042b6:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800042b8:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800042ba:	12 38       	cp.w	r8,r9
800042bc:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800042c0:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800042c4:	f3 d8 e3 19 	subcs	r9,r9,r8
800042c8:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800042cc:	6e e8       	ld.w	r8,r7[0x38]
800042ce:	2f f8       	sub	r8,-1
800042d0:	8f e8       	st.w	r7[0x38],r8
}
800042d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800042d6:	00 00       	add	r0,r0
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	5e 60       	retmi	r0

800042dc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800042dc:	eb cd 40 c0 	pushm	r6-r7,lr
800042e0:	18 97       	mov	r7,r12
800042e2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800042e4:	78 ec       	ld.w	r12,r12[0x38]
800042e6:	6e f8       	ld.w	r8,r7[0x3c]
800042e8:	10 3c       	cp.w	r12,r8
800042ea:	c0 33       	brcs	800042f0 <xQueueGenericSendFromISR+0x14>
800042ec:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800042f0:	12 9a       	mov	r10,r9
800042f2:	0e 9c       	mov	r12,r7
800042f4:	f0 1f 00 0c 	mcall	80004324 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800042f8:	6f 28       	ld.w	r8,r7[0x48]
800042fa:	5b f8       	cp.w	r8,-1
800042fc:	c0 d1       	brne	80004316 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800042fe:	6e 98       	ld.w	r8,r7[0x24]
80004300:	58 08       	cp.w	r8,0
80004302:	c0 f0       	breq	80004320 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004304:	ee cc ff dc 	sub	r12,r7,-36
80004308:	f0 1f 00 08 	mcall	80004328 <xQueueGenericSendFromISR+0x4c>
8000430c:	c0 a0       	breq	80004320 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000430e:	30 1c       	mov	r12,1
80004310:	8d 0c       	st.w	r6[0x0],r12
80004312:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80004316:	2f f8       	sub	r8,-1
80004318:	ef 48 00 48 	st.w	r7[72],r8
8000431c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004320:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004324:	80 00       	ld.sh	r0,r0[0x0]
80004326:	42 78       	lddsp	r8,sp[0x9c]
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	47 f8       	lddsp	r8,sp[0x1fc]

8000432c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000432c:	eb cd 40 c0 	pushm	r6-r7,lr
80004330:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004332:	f0 1f 00 23 	mcall	800043bc <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004336:	6f 28       	ld.w	r8,r7[0x48]
80004338:	58 08       	cp.w	r8,0
8000433a:	e0 8a 00 18 	brle	8000436a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000433e:	6e 98       	ld.w	r8,r7[0x24]
80004340:	58 08       	cp.w	r8,0
80004342:	c1 40       	breq	8000436a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004344:	ee c6 ff dc 	sub	r6,r7,-36
80004348:	c0 48       	rjmp	80004350 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000434a:	6e 98       	ld.w	r8,r7[0x24]
8000434c:	58 08       	cp.w	r8,0
8000434e:	c0 e0       	breq	8000436a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004350:	0c 9c       	mov	r12,r6
80004352:	f0 1f 00 1c 	mcall	800043c0 <prvUnlockQueue+0x94>
80004356:	c0 30       	breq	8000435c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004358:	f0 1f 00 1b 	mcall	800043c4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000435c:	6f 28       	ld.w	r8,r7[0x48]
8000435e:	20 18       	sub	r8,1
80004360:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004364:	58 08       	cp.w	r8,0
80004366:	fe 99 ff f2 	brgt	8000434a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000436a:	3f f8       	mov	r8,-1
8000436c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004370:	f0 1f 00 16 	mcall	800043c8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004374:	f0 1f 00 12 	mcall	800043bc <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004378:	6f 18       	ld.w	r8,r7[0x44]
8000437a:	58 08       	cp.w	r8,0
8000437c:	e0 8a 00 18 	brle	800043ac <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004380:	6e 48       	ld.w	r8,r7[0x10]
80004382:	58 08       	cp.w	r8,0
80004384:	c1 40       	breq	800043ac <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004386:	ee c6 ff f0 	sub	r6,r7,-16
8000438a:	c0 48       	rjmp	80004392 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000438c:	6e 48       	ld.w	r8,r7[0x10]
8000438e:	58 08       	cp.w	r8,0
80004390:	c0 e0       	breq	800043ac <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004392:	0c 9c       	mov	r12,r6
80004394:	f0 1f 00 0b 	mcall	800043c0 <prvUnlockQueue+0x94>
80004398:	c0 30       	breq	8000439e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000439a:	f0 1f 00 0b 	mcall	800043c4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000439e:	6f 18       	ld.w	r8,r7[0x44]
800043a0:	20 18       	sub	r8,1
800043a2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800043a6:	58 08       	cp.w	r8,0
800043a8:	fe 99 ff f2 	brgt	8000438c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800043ac:	3f f8       	mov	r8,-1
800043ae:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800043b2:	f0 1f 00 06 	mcall	800043c8 <prvUnlockQueue+0x9c>
}
800043b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043ba:	00 00       	add	r0,r0
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	3f a8       	mov	r8,-6
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	47 f8       	lddsp	r8,sp[0x1fc]
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	47 2c       	lddsp	r12,sp[0x1c8]
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	40 b4       	lddsp	r4,sp[0x2c]

800043cc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800043cc:	d4 31       	pushm	r0-r7,lr
800043ce:	20 5d       	sub	sp,20
800043d0:	18 97       	mov	r7,r12
800043d2:	50 0b       	stdsp	sp[0x0],r11
800043d4:	50 2a       	stdsp	sp[0x8],r10
800043d6:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800043d8:	f8 c1 ff dc 	sub	r1,r12,-36
800043dc:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800043de:	fa c4 ff f4 	sub	r4,sp,-12
800043e2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800043e4:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800043e6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800043ea:	f0 1f 00 36 	mcall	800044c0 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800043ee:	6e e8       	ld.w	r8,r7[0x38]
800043f0:	58 08       	cp.w	r8,0
800043f2:	c2 40       	breq	8000443a <xQueueGenericReceive+0x6e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800043f4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800043f6:	40 0b       	lddsp	r11,sp[0x0]
800043f8:	0e 9c       	mov	r12,r7
800043fa:	f0 1f 00 33 	mcall	800044c4 <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
800043fe:	40 18       	lddsp	r8,sp[0x4]
80004400:	58 08       	cp.w	r8,0
80004402:	c0 f1       	brne	80004420 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004404:	6e e8       	ld.w	r8,r7[0x38]
80004406:	20 18       	sub	r8,1
80004408:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000440a:	6e 48       	ld.w	r8,r7[0x10]
8000440c:	58 08       	cp.w	r8,0
8000440e:	c1 20       	breq	80004432 <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004410:	ee cc ff f0 	sub	r12,r7,-16
80004414:	f0 1f 00 2d 	mcall	800044c8 <xQueueGenericReceive+0xfc>
80004418:	58 1c       	cp.w	r12,1
8000441a:	c0 c1       	brne	80004432 <xQueueGenericReceive+0x66>
						{
							portYIELD_WITHIN_API();
8000441c:	d7 33       	scall
8000441e:	c0 a8       	rjmp	80004432 <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004420:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004422:	6e 98       	ld.w	r8,r7[0x24]
80004424:	58 08       	cp.w	r8,0
80004426:	c0 60       	breq	80004432 <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004428:	02 9c       	mov	r12,r1
8000442a:	f0 1f 00 28 	mcall	800044c8 <xQueueGenericReceive+0xfc>
8000442e:	c0 20       	breq	80004432 <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004430:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004432:	f0 1f 00 27 	mcall	800044cc <xQueueGenericReceive+0x100>
80004436:	30 1c       	mov	r12,1
				return pdPASS;
80004438:	c4 28       	rjmp	800044bc <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000443a:	40 28       	lddsp	r8,sp[0x8]
8000443c:	58 08       	cp.w	r8,0
8000443e:	c0 51       	brne	80004448 <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004440:	f0 1f 00 23 	mcall	800044cc <xQueueGenericReceive+0x100>
80004444:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004446:	c3 b8       	rjmp	800044bc <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80004448:	58 05       	cp.w	r5,0
8000444a:	c0 51       	brne	80004454 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000444c:	08 9c       	mov	r12,r4
8000444e:	f0 1f 00 21 	mcall	800044d0 <xQueueGenericReceive+0x104>
80004452:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004454:	f0 1f 00 1e 	mcall	800044cc <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004458:	f0 1f 00 1f 	mcall	800044d4 <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
8000445c:	f0 1f 00 19 	mcall	800044c0 <xQueueGenericReceive+0xf4>
80004460:	6f 18       	ld.w	r8,r7[0x44]
80004462:	5b f8       	cp.w	r8,-1
80004464:	ef f2 0a 11 	st.weq	r7[0x44],r2
80004468:	6f 28       	ld.w	r8,r7[0x48]
8000446a:	5b f8       	cp.w	r8,-1
8000446c:	ef f2 0a 12 	st.weq	r7[0x48],r2
80004470:	f0 1f 00 17 	mcall	800044cc <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004474:	06 9b       	mov	r11,r3
80004476:	08 9c       	mov	r12,r4
80004478:	f0 1f 00 18 	mcall	800044d8 <xQueueGenericReceive+0x10c>
8000447c:	c1 a1       	brne	800044b0 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000447e:	f0 1f 00 11 	mcall	800044c0 <xQueueGenericReceive+0xf4>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80004482:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80004484:	f0 1f 00 12 	mcall	800044cc <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80004488:	58 06       	cp.w	r6,0
8000448a:	c0 d1       	brne	800044a4 <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000448c:	40 2b       	lddsp	r11,sp[0x8]
8000448e:	02 9c       	mov	r12,r1
80004490:	f0 1f 00 13 	mcall	800044dc <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80004494:	0e 9c       	mov	r12,r7
80004496:	f0 1f 00 13 	mcall	800044e0 <xQueueGenericReceive+0x114>
				if( !xTaskResumeAll() )
8000449a:	f0 1f 00 13 	mcall	800044e4 <xQueueGenericReceive+0x118>
8000449e:	ca 61       	brne	800043ea <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800044a0:	d7 33       	scall
800044a2:	ca 4b       	rjmp	800043ea <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800044a4:	0e 9c       	mov	r12,r7
800044a6:	f0 1f 00 0f 	mcall	800044e0 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
800044aa:	f0 1f 00 0f 	mcall	800044e4 <xQueueGenericReceive+0x118>
800044ae:	c9 eb       	rjmp	800043ea <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800044b0:	0e 9c       	mov	r12,r7
800044b2:	f0 1f 00 0c 	mcall	800044e0 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
800044b6:	f0 1f 00 0c 	mcall	800044e4 <xQueueGenericReceive+0x118>
800044ba:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800044bc:	2f bd       	sub	sp,-20
800044be:	d8 32       	popm	r0-r7,pc
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	3f a8       	mov	r8,-6
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	41 f8       	lddsp	r8,sp[0x7c]
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	47 f8       	lddsp	r8,sp[0x1fc]
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	40 b4       	lddsp	r4,sp[0x2c]
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	47 14       	lddsp	r4,sp[0x1c4]
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	46 7c       	lddsp	r12,sp[0x19c]
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	47 38       	lddsp	r8,sp[0x1cc]
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	4d e8       	lddpc	r8,80004654 <xQueueCreate+0x6c>
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	43 2c       	lddsp	r12,sp[0xc8]
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	49 8c       	lddpc	r12,80004544 <xQueueGenericSend+0x5c>

800044e8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800044e8:	d4 31       	pushm	r0-r7,lr
800044ea:	20 5d       	sub	sp,20
800044ec:	18 97       	mov	r7,r12
800044ee:	50 0b       	stdsp	sp[0x0],r11
800044f0:	50 2a       	stdsp	sp[0x8],r10
800044f2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800044f4:	f8 c0 ff f0 	sub	r0,r12,-16
800044f8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800044fa:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800044fe:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004500:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80004504:	f0 1f 00 2f 	mcall	800045c0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004508:	6e e9       	ld.w	r9,r7[0x38]
8000450a:	6e f8       	ld.w	r8,r7[0x3c]
8000450c:	10 39       	cp.w	r9,r8
8000450e:	c1 42       	brcc	80004536 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004510:	40 1a       	lddsp	r10,sp[0x4]
80004512:	40 0b       	lddsp	r11,sp[0x0]
80004514:	0e 9c       	mov	r12,r7
80004516:	f0 1f 00 2c 	mcall	800045c4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000451a:	6e 98       	ld.w	r8,r7[0x24]
8000451c:	58 08       	cp.w	r8,0
8000451e:	c0 80       	breq	8000452e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80004520:	ee cc ff dc 	sub	r12,r7,-36
80004524:	f0 1f 00 29 	mcall	800045c8 <xQueueGenericSend+0xe0>
80004528:	58 1c       	cp.w	r12,1
8000452a:	c0 21       	brne	8000452e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000452c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000452e:	f0 1f 00 28 	mcall	800045cc <xQueueGenericSend+0xe4>
80004532:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80004534:	c4 38       	rjmp	800045ba <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004536:	40 28       	lddsp	r8,sp[0x8]
80004538:	58 08       	cp.w	r8,0
8000453a:	c0 51       	brne	80004544 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000453c:	f0 1f 00 24 	mcall	800045cc <xQueueGenericSend+0xe4>
80004540:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80004542:	c3 c8       	rjmp	800045ba <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80004544:	58 04       	cp.w	r4,0
80004546:	c0 51       	brne	80004550 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004548:	06 9c       	mov	r12,r3
8000454a:	f0 1f 00 22 	mcall	800045d0 <xQueueGenericSend+0xe8>
8000454e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004550:	f0 1f 00 1f 	mcall	800045cc <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004554:	f0 1f 00 20 	mcall	800045d4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80004558:	f0 1f 00 1a 	mcall	800045c0 <xQueueGenericSend+0xd8>
8000455c:	6f 18       	ld.w	r8,r7[0x44]
8000455e:	5b f8       	cp.w	r8,-1
80004560:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004564:	6f 28       	ld.w	r8,r7[0x48]
80004566:	5b f8       	cp.w	r8,-1
80004568:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000456c:	f0 1f 00 18 	mcall	800045cc <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004570:	04 9b       	mov	r11,r2
80004572:	06 9c       	mov	r12,r3
80004574:	f0 1f 00 19 	mcall	800045d8 <xQueueGenericSend+0xf0>
80004578:	c1 b1       	brne	800045ae <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000457a:	f0 1f 00 12 	mcall	800045c0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000457e:	6e e5       	ld.w	r5,r7[0x38]
80004580:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80004582:	f0 1f 00 13 	mcall	800045cc <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80004586:	0c 35       	cp.w	r5,r6
80004588:	c0 d1       	brne	800045a2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000458a:	40 2b       	lddsp	r11,sp[0x8]
8000458c:	00 9c       	mov	r12,r0
8000458e:	f0 1f 00 14 	mcall	800045dc <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80004592:	0e 9c       	mov	r12,r7
80004594:	f0 1f 00 13 	mcall	800045e0 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80004598:	f0 1f 00 13 	mcall	800045e4 <xQueueGenericSend+0xfc>
8000459c:	cb 41       	brne	80004504 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000459e:	d7 33       	scall
800045a0:	cb 2b       	rjmp	80004504 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800045a2:	0e 9c       	mov	r12,r7
800045a4:	f0 1f 00 0f 	mcall	800045e0 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800045a8:	f0 1f 00 0f 	mcall	800045e4 <xQueueGenericSend+0xfc>
800045ac:	ca cb       	rjmp	80004504 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800045ae:	0e 9c       	mov	r12,r7
800045b0:	f0 1f 00 0c 	mcall	800045e0 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800045b4:	f0 1f 00 0c 	mcall	800045e4 <xQueueGenericSend+0xfc>
800045b8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800045ba:	2f bd       	sub	sp,-20
800045bc:	d8 32       	popm	r0-r7,pc
800045be:	00 00       	add	r0,r0
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	3f a8       	mov	r8,-6
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	42 78       	lddsp	r8,sp[0x9c]
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	47 f8       	lddsp	r8,sp[0x1fc]
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	40 b4       	lddsp	r4,sp[0x2c]
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	47 14       	lddsp	r4,sp[0x1c4]
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	46 7c       	lddsp	r12,sp[0x19c]
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	47 38       	lddsp	r8,sp[0x1cc]
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	4d e8       	lddpc	r8,80004754 <xTaskCheckForTimeOut+0x1c>
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	43 2c       	lddsp	r12,sp[0xc8]
800045e4:	80 00       	ld.sh	r0,r0[0x0]
800045e6:	49 8c       	lddpc	r12,80004644 <xQueueCreate+0x5c>

800045e8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800045e8:	d4 21       	pushm	r4-r7,lr
800045ea:	18 97       	mov	r7,r12
800045ec:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800045ee:	58 0c       	cp.w	r12,0
800045f0:	c2 f0       	breq	8000464e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800045f2:	34 cc       	mov	r12,76
800045f4:	f0 1f 00 17 	mcall	80004650 <xQueueCreate+0x68>
800045f8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800045fa:	c2 a0       	breq	8000464e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800045fc:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80004600:	e8 cc ff ff 	sub	r12,r4,-1
80004604:	f0 1f 00 13 	mcall	80004650 <xQueueCreate+0x68>
80004608:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000460a:	c1 e0       	breq	80004646 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000460c:	f8 04 00 04 	add	r4,r12,r4
80004610:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80004612:	30 08       	mov	r8,0
80004614:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80004616:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80004618:	ee c8 00 01 	sub	r8,r7,1
8000461c:	ad 38       	mul	r8,r6
8000461e:	10 0c       	add	r12,r8
80004620:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80004622:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80004624:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80004628:	3f f8       	mov	r8,-1
8000462a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000462e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80004632:	ea cc ff f0 	sub	r12,r5,-16
80004636:	f0 1f 00 08 	mcall	80004654 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000463a:	ea cc ff dc 	sub	r12,r5,-36
8000463e:	f0 1f 00 06 	mcall	80004654 <xQueueCreate+0x6c>
80004642:	0a 9c       	mov	r12,r5
80004644:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80004646:	0a 9c       	mov	r12,r5
80004648:	f0 1f 00 04 	mcall	80004658 <xQueueCreate+0x70>
8000464c:	d8 2a       	popm	r4-r7,pc,r12=0
8000464e:	d8 2a       	popm	r4-r7,pc,r12=0
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	41 b0       	lddsp	r0,sp[0x6c]
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	3e 84       	mov	r4,-24
80004658:	80 00       	ld.sh	r0,r0[0x0]
8000465a:	41 88       	lddsp	r8,sp[0x60]

8000465c <xTaskIsTaskSuspended>:
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
8000465c:	78 59       	ld.w	r9,r12[0x14]
8000465e:	48 68       	lddpc	r8,80004674 <xTaskIsTaskSuspended+0x18>
80004660:	10 39       	cp.w	r9,r8
80004662:	c0 81       	brne	80004672 <xTaskIsTaskSuspended+0x16>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80004664:	78 a8       	ld.w	r8,r12[0x28]
80004666:	48 59       	lddpc	r9,80004678 <xTaskIsTaskSuspended+0x1c>
80004668:	12 38       	cp.w	r8,r9
8000466a:	c0 40       	breq	80004672 <xTaskIsTaskSuspended+0x16>
8000466c:	58 08       	cp.w	r8,0
8000466e:	5f 0c       	sreq	r12
80004670:	5e fc       	retal	r12
80004672:	5e fd       	retal	0
80004674:	00 00       	add	r0,r0
80004676:	08 e0       	st.h	--r4,r0
80004678:	00 00       	add	r0,r0
8000467a:	08 90       	mov	r0,r4

8000467c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000467c:	48 38       	lddpc	r8,80004688 <vTaskSuspendAll+0xc>
8000467e:	70 09       	ld.w	r9,r8[0x0]
80004680:	2f f9       	sub	r9,-1
80004682:	91 09       	st.w	r8[0x0],r9
}
80004684:	5e fc       	retal	r12
80004686:	00 00       	add	r0,r0
80004688:	00 00       	add	r0,r0
8000468a:	08 bc       	st.h	r4++,r12

8000468c <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
8000468c:	48 28       	lddpc	r8,80004694 <uxTaskGetNumberOfTasks+0x8>
8000468e:	70 0c       	ld.w	r12,r8[0x0]
}
80004690:	5e fc       	retal	r12
80004692:	00 00       	add	r0,r0
80004694:	00 00       	add	r0,r0
80004696:	08 d8       	st.w	--r4,r8

80004698 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80004698:	49 a8       	lddpc	r8,80004700 <vTaskSwitchContext+0x68>
8000469a:	70 08       	ld.w	r8,r8[0x0]
8000469c:	58 08       	cp.w	r8,0
8000469e:	c0 b1       	brne	800046b4 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800046a0:	49 98       	lddpc	r8,80004704 <vTaskSwitchContext+0x6c>
800046a2:	70 08       	ld.w	r8,r8[0x0]
800046a4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800046a8:	49 89       	lddpc	r9,80004708 <vTaskSwitchContext+0x70>
800046aa:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800046ae:	58 08       	cp.w	r8,0
800046b0:	c0 60       	breq	800046bc <vTaskSwitchContext+0x24>
800046b2:	c1 18       	rjmp	800046d4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800046b4:	30 19       	mov	r9,1
800046b6:	49 68       	lddpc	r8,8000470c <vTaskSwitchContext+0x74>
800046b8:	91 09       	st.w	r8[0x0],r9
800046ba:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800046bc:	49 28       	lddpc	r8,80004704 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800046be:	49 3a       	lddpc	r10,80004708 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800046c0:	70 09       	ld.w	r9,r8[0x0]
800046c2:	20 19       	sub	r9,1
800046c4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800046c6:	70 09       	ld.w	r9,r8[0x0]
800046c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800046cc:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800046d0:	58 09       	cp.w	r9,0
800046d2:	cf 70       	breq	800046c0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800046d4:	48 c8       	lddpc	r8,80004704 <vTaskSwitchContext+0x6c>
800046d6:	70 08       	ld.w	r8,r8[0x0]
800046d8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800046dc:	48 b9       	lddpc	r9,80004708 <vTaskSwitchContext+0x70>
800046de:	f2 08 00 28 	add	r8,r9,r8<<0x2
800046e2:	70 19       	ld.w	r9,r8[0x4]
800046e4:	72 19       	ld.w	r9,r9[0x4]
800046e6:	91 19       	st.w	r8[0x4],r9
800046e8:	f0 ca ff f8 	sub	r10,r8,-8
800046ec:	14 39       	cp.w	r9,r10
800046ee:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800046f2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800046f6:	70 18       	ld.w	r8,r8[0x4]
800046f8:	70 39       	ld.w	r9,r8[0xc]
800046fa:	48 68       	lddpc	r8,80004710 <vTaskSwitchContext+0x78>
800046fc:	91 09       	st.w	r8[0x0],r9
800046fe:	5e fc       	retal	r12
80004700:	00 00       	add	r0,r0
80004702:	08 bc       	st.h	r4++,r12
80004704:	00 00       	add	r0,r0
80004706:	08 f4       	st.b	--r4,r4
80004708:	00 00       	add	r0,r0
8000470a:	07 d8       	ld.ub	r8,r3[0x5]
8000470c:	00 00       	add	r0,r0
8000470e:	08 dc       	st.w	--r4,r12
80004710:	00 00       	add	r0,r0
80004712:	08 8c       	andn	r12,r4

80004714 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80004714:	48 48       	lddpc	r8,80004724 <vTaskSetTimeOutState+0x10>
80004716:	70 08       	ld.w	r8,r8[0x0]
80004718:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000471a:	48 48       	lddpc	r8,80004728 <vTaskSetTimeOutState+0x14>
8000471c:	70 08       	ld.w	r8,r8[0x0]
8000471e:	99 18       	st.w	r12[0x4],r8
}
80004720:	5e fc       	retal	r12
80004722:	00 00       	add	r0,r0
80004724:	00 00       	add	r0,r0
80004726:	07 d0       	ld.ub	r0,r3[0x5]
80004728:	00 00       	add	r0,r0
8000472a:	08 b8       	st.h	r4++,r8

8000472c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000472c:	30 19       	mov	r9,1
8000472e:	48 28       	lddpc	r8,80004734 <vTaskMissedYield+0x8>
80004730:	91 09       	st.w	r8[0x0],r9
}
80004732:	5e fc       	retal	r12
80004734:	00 00       	add	r0,r0
80004736:	08 dc       	st.w	--r4,r12

80004738 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80004738:	eb cd 40 c0 	pushm	r6-r7,lr
8000473c:	18 97       	mov	r7,r12
8000473e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80004740:	f0 1f 00 15 	mcall	80004794 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80004744:	6c 08       	ld.w	r8,r6[0x0]
80004746:	5b f8       	cp.w	r8,-1
80004748:	c0 31       	brne	8000474e <xTaskCheckForTimeOut+0x16>
8000474a:	30 07       	mov	r7,0
8000474c:	c1 f8       	rjmp	8000478a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000474e:	49 39       	lddpc	r9,80004798 <xTaskCheckForTimeOut+0x60>
80004750:	72 09       	ld.w	r9,r9[0x0]
80004752:	6e 0a       	ld.w	r10,r7[0x0]
80004754:	12 3a       	cp.w	r10,r9
80004756:	c0 70       	breq	80004764 <xTaskCheckForTimeOut+0x2c>
80004758:	49 19       	lddpc	r9,8000479c <xTaskCheckForTimeOut+0x64>
8000475a:	72 09       	ld.w	r9,r9[0x0]
8000475c:	6e 1a       	ld.w	r10,r7[0x4]
8000475e:	12 3a       	cp.w	r10,r9
80004760:	e0 88 00 14 	brls	80004788 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80004764:	48 e9       	lddpc	r9,8000479c <xTaskCheckForTimeOut+0x64>
80004766:	72 0a       	ld.w	r10,r9[0x0]
80004768:	6e 19       	ld.w	r9,r7[0x4]
8000476a:	12 1a       	sub	r10,r9
8000476c:	14 38       	cp.w	r8,r10
8000476e:	e0 88 00 0d 	brls	80004788 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80004772:	48 ba       	lddpc	r10,8000479c <xTaskCheckForTimeOut+0x64>
80004774:	74 0a       	ld.w	r10,r10[0x0]
80004776:	14 19       	sub	r9,r10
80004778:	f2 08 00 08 	add	r8,r9,r8
8000477c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000477e:	0e 9c       	mov	r12,r7
80004780:	f0 1f 00 08 	mcall	800047a0 <xTaskCheckForTimeOut+0x68>
80004784:	30 07       	mov	r7,0
80004786:	c0 28       	rjmp	8000478a <xTaskCheckForTimeOut+0x52>
80004788:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000478a:	f0 1f 00 07 	mcall	800047a4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000478e:	0e 9c       	mov	r12,r7
80004790:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	3f a8       	mov	r8,-6
80004798:	00 00       	add	r0,r0
8000479a:	07 d0       	ld.ub	r0,r3[0x5]
8000479c:	00 00       	add	r0,r0
8000479e:	08 b8       	st.h	r4++,r8
800047a0:	80 00       	ld.sh	r0,r0[0x0]
800047a2:	47 14       	lddsp	r4,sp[0x1c4]
800047a4:	80 00       	ld.sh	r0,r0[0x0]
800047a6:	40 b4       	lddsp	r4,sp[0x2c]

800047a8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800047a8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800047ac:	f0 1f 00 05 	mcall	800047c0 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800047b0:	48 58       	lddpc	r8,800047c4 <xTaskGetTickCount+0x1c>
800047b2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800047b4:	f0 1f 00 05 	mcall	800047c8 <xTaskGetTickCount+0x20>

	return xTicks;
}
800047b8:	0e 9c       	mov	r12,r7
800047ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800047be:	00 00       	add	r0,r0
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	3f a8       	mov	r8,-6
800047c4:	00 00       	add	r0,r0
800047c6:	08 b8       	st.h	r4++,r8
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	40 b4       	lddsp	r4,sp[0x2c]

800047cc <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
800047cc:	eb cd 40 80 	pushm	r7,lr
800047d0:	18 97       	mov	r7,r12
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
800047d2:	f0 1f 00 07 	mcall	800047ec <uxTaskPriorityGet+0x20>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
800047d6:	58 07       	cp.w	r7,0
800047d8:	c0 31       	brne	800047de <uxTaskPriorityGet+0x12>
800047da:	48 68       	lddpc	r8,800047f0 <uxTaskPriorityGet+0x24>
800047dc:	70 07       	ld.w	r7,r8[0x0]
			uxReturn = pxTCB->uxPriority;
800047de:	6e b7       	ld.w	r7,r7[0x2c]
		}
		taskEXIT_CRITICAL();
800047e0:	f0 1f 00 05 	mcall	800047f4 <uxTaskPriorityGet+0x28>

		return uxReturn;
	}
800047e4:	0e 9c       	mov	r12,r7
800047e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800047ea:	00 00       	add	r0,r0
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	3f a8       	mov	r8,-6
800047f0:	00 00       	add	r0,r0
800047f2:	08 8c       	andn	r12,r4
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	40 b4       	lddsp	r4,sp[0x2c]

800047f8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800047f8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800047fc:	78 38       	ld.w	r8,r12[0xc]
800047fe:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80004800:	ee c6 ff e8 	sub	r6,r7,-24
80004804:	0c 9c       	mov	r12,r6
80004806:	f0 1f 00 16 	mcall	8000485c <xTaskRemoveFromEventList+0x64>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000480a:	49 68       	lddpc	r8,80004860 <xTaskRemoveFromEventList+0x68>
8000480c:	70 08       	ld.w	r8,r8[0x0]
8000480e:	58 08       	cp.w	r8,0
80004810:	c1 71       	brne	8000483e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80004812:	ee c6 ff fc 	sub	r6,r7,-4
80004816:	0c 9c       	mov	r12,r6
80004818:	f0 1f 00 11 	mcall	8000485c <xTaskRemoveFromEventList+0x64>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000481c:	6e bc       	ld.w	r12,r7[0x2c]
8000481e:	49 28       	lddpc	r8,80004864 <xTaskRemoveFromEventList+0x6c>
80004820:	70 08       	ld.w	r8,r8[0x0]
80004822:	10 3c       	cp.w	r12,r8
80004824:	e0 88 00 04 	brls	8000482c <xTaskRemoveFromEventList+0x34>
80004828:	48 f8       	lddpc	r8,80004864 <xTaskRemoveFromEventList+0x6c>
8000482a:	91 0c       	st.w	r8[0x0],r12
8000482c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004830:	0c 9b       	mov	r11,r6
80004832:	48 e8       	lddpc	r8,80004868 <xTaskRemoveFromEventList+0x70>
80004834:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004838:	f0 1f 00 0d 	mcall	8000486c <xTaskRemoveFromEventList+0x74>
8000483c:	c0 58       	rjmp	80004846 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000483e:	0c 9b       	mov	r11,r6
80004840:	48 cc       	lddpc	r12,80004870 <xTaskRemoveFromEventList+0x78>
80004842:	f0 1f 00 0b 	mcall	8000486c <xTaskRemoveFromEventList+0x74>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004846:	48 c8       	lddpc	r8,80004874 <xTaskRemoveFromEventList+0x7c>
80004848:	70 08       	ld.w	r8,r8[0x0]
8000484a:	6e bc       	ld.w	r12,r7[0x2c]
8000484c:	70 b8       	ld.w	r8,r8[0x2c]
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000484e:	10 3c       	cp.w	r12,r8
80004850:	f9 bc 02 01 	movhs	r12,1
80004854:	f9 bc 03 00 	movlo	r12,0
80004858:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	3e ee       	mov	lr,-18
80004860:	00 00       	add	r0,r0
80004862:	08 bc       	st.h	r4++,r12
80004864:	00 00       	add	r0,r0
80004866:	08 f4       	st.b	--r4,r4
80004868:	00 00       	add	r0,r0
8000486a:	07 d8       	ld.ub	r8,r3[0x5]
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	3e 9e       	mov	lr,-23
80004870:	00 00       	add	r0,r0
80004872:	08 90       	mov	r0,r4
80004874:	00 00       	add	r0,r0
80004876:	08 8c       	andn	r12,r4

80004878 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80004878:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000487c:	4b 98       	lddpc	r8,80004960 <vTaskIncrementTick+0xe8>
8000487e:	70 08       	ld.w	r8,r8[0x0]
80004880:	58 08       	cp.w	r8,0
80004882:	c6 91       	brne	80004954 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80004884:	4b 88       	lddpc	r8,80004964 <vTaskIncrementTick+0xec>
80004886:	70 09       	ld.w	r9,r8[0x0]
80004888:	2f f9       	sub	r9,-1
8000488a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000488c:	70 08       	ld.w	r8,r8[0x0]
8000488e:	58 08       	cp.w	r8,0
80004890:	c1 a1       	brne	800048c4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80004892:	4b 68       	lddpc	r8,80004968 <vTaskIncrementTick+0xf0>
80004894:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80004896:	4b 69       	lddpc	r9,8000496c <vTaskIncrementTick+0xf4>
80004898:	72 0b       	ld.w	r11,r9[0x0]
8000489a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000489c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000489e:	4b 59       	lddpc	r9,80004970 <vTaskIncrementTick+0xf8>
800048a0:	72 0a       	ld.w	r10,r9[0x0]
800048a2:	2f fa       	sub	r10,-1
800048a4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800048a6:	70 08       	ld.w	r8,r8[0x0]
800048a8:	70 08       	ld.w	r8,r8[0x0]
800048aa:	58 08       	cp.w	r8,0
800048ac:	c0 51       	brne	800048b6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800048ae:	3f f9       	mov	r9,-1
800048b0:	4b 18       	lddpc	r8,80004974 <vTaskIncrementTick+0xfc>
800048b2:	91 09       	st.w	r8[0x0],r9
800048b4:	c0 88       	rjmp	800048c4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800048b6:	4a d8       	lddpc	r8,80004968 <vTaskIncrementTick+0xf0>
800048b8:	70 08       	ld.w	r8,r8[0x0]
800048ba:	70 38       	ld.w	r8,r8[0xc]
800048bc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800048be:	70 19       	ld.w	r9,r8[0x4]
800048c0:	4a d8       	lddpc	r8,80004974 <vTaskIncrementTick+0xfc>
800048c2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800048c4:	4a 88       	lddpc	r8,80004964 <vTaskIncrementTick+0xec>
800048c6:	70 09       	ld.w	r9,r8[0x0]
800048c8:	4a b8       	lddpc	r8,80004974 <vTaskIncrementTick+0xfc>
800048ca:	70 08       	ld.w	r8,r8[0x0]
800048cc:	10 39       	cp.w	r9,r8
800048ce:	c4 73       	brcs	8000495c <vTaskIncrementTick+0xe4>
800048d0:	4a 68       	lddpc	r8,80004968 <vTaskIncrementTick+0xf0>
800048d2:	70 08       	ld.w	r8,r8[0x0]
800048d4:	70 08       	ld.w	r8,r8[0x0]
800048d6:	58 08       	cp.w	r8,0
800048d8:	c0 c0       	breq	800048f0 <vTaskIncrementTick+0x78>
800048da:	4a 48       	lddpc	r8,80004968 <vTaskIncrementTick+0xf0>
800048dc:	70 08       	ld.w	r8,r8[0x0]
800048de:	70 38       	ld.w	r8,r8[0xc]
800048e0:	70 37       	ld.w	r7,r8[0xc]
800048e2:	6e 18       	ld.w	r8,r7[0x4]
800048e4:	4a 09       	lddpc	r9,80004964 <vTaskIncrementTick+0xec>
800048e6:	72 09       	ld.w	r9,r9[0x0]
800048e8:	12 38       	cp.w	r8,r9
800048ea:	e0 88 00 14 	brls	80004912 <vTaskIncrementTick+0x9a>
800048ee:	c0 e8       	rjmp	8000490a <vTaskIncrementTick+0x92>
800048f0:	3f f9       	mov	r9,-1
800048f2:	4a 18       	lddpc	r8,80004974 <vTaskIncrementTick+0xfc>
800048f4:	91 09       	st.w	r8[0x0],r9
800048f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800048fa:	6a 08       	ld.w	r8,r5[0x0]
800048fc:	70 38       	ld.w	r8,r8[0xc]
800048fe:	70 37       	ld.w	r7,r8[0xc]
80004900:	6e 18       	ld.w	r8,r7[0x4]
80004902:	64 09       	ld.w	r9,r2[0x0]
80004904:	12 38       	cp.w	r8,r9
80004906:	e0 88 00 0a 	brls	8000491a <vTaskIncrementTick+0xa2>
8000490a:	49 b9       	lddpc	r9,80004974 <vTaskIncrementTick+0xfc>
8000490c:	93 08       	st.w	r9[0x0],r8
8000490e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004912:	49 a4       	lddpc	r4,80004978 <vTaskIncrementTick+0x100>
80004914:	49 a3       	lddpc	r3,8000497c <vTaskIncrementTick+0x104>
80004916:	49 55       	lddpc	r5,80004968 <vTaskIncrementTick+0xf0>
80004918:	49 32       	lddpc	r2,80004964 <vTaskIncrementTick+0xec>
8000491a:	ee c6 ff fc 	sub	r6,r7,-4
8000491e:	0c 9c       	mov	r12,r6
80004920:	f0 1f 00 18 	mcall	80004980 <vTaskIncrementTick+0x108>
80004924:	6e a8       	ld.w	r8,r7[0x28]
80004926:	58 08       	cp.w	r8,0
80004928:	c0 50       	breq	80004932 <vTaskIncrementTick+0xba>
8000492a:	ee cc ff e8 	sub	r12,r7,-24
8000492e:	f0 1f 00 15 	mcall	80004980 <vTaskIncrementTick+0x108>
80004932:	6e bc       	ld.w	r12,r7[0x2c]
80004934:	68 08       	ld.w	r8,r4[0x0]
80004936:	10 3c       	cp.w	r12,r8
80004938:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000493c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004940:	0c 9b       	mov	r11,r6
80004942:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80004946:	f0 1f 00 10 	mcall	80004984 <vTaskIncrementTick+0x10c>
8000494a:	6a 08       	ld.w	r8,r5[0x0]
8000494c:	70 08       	ld.w	r8,r8[0x0]
8000494e:	58 08       	cp.w	r8,0
80004950:	cd 51       	brne	800048fa <vTaskIncrementTick+0x82>
80004952:	cc fb       	rjmp	800048f0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80004954:	48 d8       	lddpc	r8,80004988 <vTaskIncrementTick+0x110>
80004956:	70 09       	ld.w	r9,r8[0x0]
80004958:	2f f9       	sub	r9,-1
8000495a:	91 09       	st.w	r8[0x0],r9
8000495c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004960:	00 00       	add	r0,r0
80004962:	08 bc       	st.h	r4++,r12
80004964:	00 00       	add	r0,r0
80004966:	08 b8       	st.h	r4++,r8
80004968:	00 00       	add	r0,r0
8000496a:	07 c4       	ld.ub	r4,r3[0x4]
8000496c:	00 00       	add	r0,r0
8000496e:	07 d4       	ld.ub	r4,r3[0x5]
80004970:	00 00       	add	r0,r0
80004972:	07 d0       	ld.ub	r0,r3[0x5]
80004974:	00 00       	add	r0,r0
80004976:	00 30       	cp.w	r0,r0
80004978:	00 00       	add	r0,r0
8000497a:	08 f4       	st.b	--r4,r4
8000497c:	00 00       	add	r0,r0
8000497e:	07 d8       	ld.ub	r8,r3[0x5]
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	3e ee       	mov	lr,-18
80004984:	80 00       	ld.sh	r0,r0[0x0]
80004986:	3e 9e       	mov	lr,-23
80004988:	00 00       	add	r0,r0
8000498a:	07 bc       	ld.ub	r12,r3[0x3]

8000498c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000498c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80004990:	f0 1f 00 2c 	mcall	80004a40 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80004994:	4a c8       	lddpc	r8,80004a44 <xTaskResumeAll+0xb8>
80004996:	70 09       	ld.w	r9,r8[0x0]
80004998:	20 19       	sub	r9,1
8000499a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000499c:	70 08       	ld.w	r8,r8[0x0]
8000499e:	58 08       	cp.w	r8,0
800049a0:	c4 91       	brne	80004a32 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800049a2:	4a a8       	lddpc	r8,80004a48 <xTaskResumeAll+0xbc>
800049a4:	70 08       	ld.w	r8,r8[0x0]
800049a6:	58 08       	cp.w	r8,0
800049a8:	c4 50       	breq	80004a32 <xTaskResumeAll+0xa6>
800049aa:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800049ac:	4a 85       	lddpc	r5,80004a4c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800049ae:	4a 93       	lddpc	r3,80004a50 <xTaskResumeAll+0xc4>
800049b0:	4a 92       	lddpc	r2,80004a54 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800049b2:	4a a1       	lddpc	r1,80004a58 <xTaskResumeAll+0xcc>
800049b4:	c1 e8       	rjmp	800049f0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800049b6:	6a 38       	ld.w	r8,r5[0xc]
800049b8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800049ba:	ee cc ff e8 	sub	r12,r7,-24
800049be:	f0 1f 00 28 	mcall	80004a5c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800049c2:	ee c6 ff fc 	sub	r6,r7,-4
800049c6:	0c 9c       	mov	r12,r6
800049c8:	f0 1f 00 25 	mcall	80004a5c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800049cc:	6e bc       	ld.w	r12,r7[0x2c]
800049ce:	66 08       	ld.w	r8,r3[0x0]
800049d0:	10 3c       	cp.w	r12,r8
800049d2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800049d6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800049da:	0c 9b       	mov	r11,r6
800049dc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800049e0:	f0 1f 00 20 	mcall	80004a60 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800049e4:	62 08       	ld.w	r8,r1[0x0]
800049e6:	6e b9       	ld.w	r9,r7[0x2c]
800049e8:	70 b8       	ld.w	r8,r8[0x2c]
800049ea:	10 39       	cp.w	r9,r8
800049ec:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800049f0:	6a 08       	ld.w	r8,r5[0x0]
800049f2:	58 08       	cp.w	r8,0
800049f4:	ce 11       	brne	800049b6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800049f6:	49 c8       	lddpc	r8,80004a64 <xTaskResumeAll+0xd8>
800049f8:	70 08       	ld.w	r8,r8[0x0]
800049fa:	58 08       	cp.w	r8,0
800049fc:	c0 f0       	breq	80004a1a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800049fe:	49 a8       	lddpc	r8,80004a64 <xTaskResumeAll+0xd8>
80004a00:	70 08       	ld.w	r8,r8[0x0]
80004a02:	58 08       	cp.w	r8,0
80004a04:	c1 10       	breq	80004a26 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80004a06:	49 87       	lddpc	r7,80004a64 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80004a08:	f0 1f 00 18 	mcall	80004a68 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80004a0c:	6e 08       	ld.w	r8,r7[0x0]
80004a0e:	20 18       	sub	r8,1
80004a10:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004a12:	6e 08       	ld.w	r8,r7[0x0]
80004a14:	58 08       	cp.w	r8,0
80004a16:	cf 91       	brne	80004a08 <xTaskResumeAll+0x7c>
80004a18:	c0 78       	rjmp	80004a26 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80004a1a:	58 14       	cp.w	r4,1
80004a1c:	c0 50       	breq	80004a26 <xTaskResumeAll+0x9a>
80004a1e:	49 48       	lddpc	r8,80004a6c <xTaskResumeAll+0xe0>
80004a20:	70 08       	ld.w	r8,r8[0x0]
80004a22:	58 18       	cp.w	r8,1
80004a24:	c0 71       	brne	80004a32 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80004a26:	30 09       	mov	r9,0
80004a28:	49 18       	lddpc	r8,80004a6c <xTaskResumeAll+0xe0>
80004a2a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80004a2c:	d7 33       	scall
80004a2e:	30 17       	mov	r7,1
80004a30:	c0 28       	rjmp	80004a34 <xTaskResumeAll+0xa8>
80004a32:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80004a34:	f0 1f 00 0f 	mcall	80004a70 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80004a38:	0e 9c       	mov	r12,r7
80004a3a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004a3e:	00 00       	add	r0,r0
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	3f a8       	mov	r8,-6
80004a44:	00 00       	add	r0,r0
80004a46:	08 bc       	st.h	r4++,r12
80004a48:	00 00       	add	r0,r0
80004a4a:	08 d8       	st.w	--r4,r8
80004a4c:	00 00       	add	r0,r0
80004a4e:	08 90       	mov	r0,r4
80004a50:	00 00       	add	r0,r0
80004a52:	08 f4       	st.b	--r4,r4
80004a54:	00 00       	add	r0,r0
80004a56:	07 d8       	ld.ub	r8,r3[0x5]
80004a58:	00 00       	add	r0,r0
80004a5a:	08 8c       	andn	r12,r4
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	3e ee       	mov	lr,-18
80004a60:	80 00       	ld.sh	r0,r0[0x0]
80004a62:	3e 9e       	mov	lr,-23
80004a64:	00 00       	add	r0,r0
80004a66:	07 bc       	ld.ub	r12,r3[0x3]
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	48 78       	lddpc	r8,80004a84 <vTaskResume+0x10>
80004a6c:	00 00       	add	r0,r0
80004a6e:	08 dc       	st.w	--r4,r12
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	40 b4       	lddsp	r4,sp[0x2c]

80004a74 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
80004a74:	eb cd 40 c0 	pushm	r6-r7,lr
80004a78:	18 97       	mov	r7,r12
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
80004a7a:	58 0c       	cp.w	r12,0
80004a7c:	c2 a0       	breq	80004ad0 <vTaskResume+0x5c>
80004a7e:	49 68       	lddpc	r8,80004ad4 <vTaskResume+0x60>
80004a80:	70 08       	ld.w	r8,r8[0x0]
80004a82:	10 3c       	cp.w	r12,r8
80004a84:	c2 60       	breq	80004ad0 <vTaskResume+0x5c>
		{
			taskENTER_CRITICAL();
80004a86:	f0 1f 00 15 	mcall	80004ad8 <vTaskResume+0x64>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
80004a8a:	0e 9c       	mov	r12,r7
80004a8c:	f0 1f 00 14 	mcall	80004adc <vTaskResume+0x68>
80004a90:	58 1c       	cp.w	r12,1
80004a92:	c1 d1       	brne	80004acc <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80004a94:	ee c6 ff fc 	sub	r6,r7,-4
80004a98:	0c 9c       	mov	r12,r6
80004a9a:	f0 1f 00 12 	mcall	80004ae0 <vTaskResume+0x6c>
					prvAddTaskToReadyQueue( pxTCB );
80004a9e:	6e bc       	ld.w	r12,r7[0x2c]
80004aa0:	49 18       	lddpc	r8,80004ae4 <vTaskResume+0x70>
80004aa2:	70 08       	ld.w	r8,r8[0x0]
80004aa4:	10 3c       	cp.w	r12,r8
80004aa6:	e0 88 00 04 	brls	80004aae <vTaskResume+0x3a>
80004aaa:	48 f8       	lddpc	r8,80004ae4 <vTaskResume+0x70>
80004aac:	91 0c       	st.w	r8[0x0],r12
80004aae:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004ab2:	0c 9b       	mov	r11,r6
80004ab4:	48 d8       	lddpc	r8,80004ae8 <vTaskResume+0x74>
80004ab6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004aba:	f0 1f 00 0d 	mcall	80004aec <vTaskResume+0x78>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004abe:	48 68       	lddpc	r8,80004ad4 <vTaskResume+0x60>
80004ac0:	70 08       	ld.w	r8,r8[0x0]
80004ac2:	6e b9       	ld.w	r9,r7[0x2c]
80004ac4:	70 b8       	ld.w	r8,r8[0x2c]
80004ac6:	10 39       	cp.w	r9,r8
80004ac8:	c0 23       	brcs	80004acc <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
80004aca:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80004acc:	f0 1f 00 09 	mcall	80004af0 <vTaskResume+0x7c>
80004ad0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ad4:	00 00       	add	r0,r0
80004ad6:	08 8c       	andn	r12,r4
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	3f a8       	mov	r8,-6
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	46 5c       	lddsp	r12,sp[0x194]
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	3e ee       	mov	lr,-18
80004ae4:	00 00       	add	r0,r0
80004ae6:	08 f4       	st.b	--r4,r4
80004ae8:	00 00       	add	r0,r0
80004aea:	07 d8       	ld.ub	r8,r3[0x5]
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	3e 9e       	mov	lr,-23
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	40 b4       	lddsp	r4,sp[0x2c]

80004af4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80004af4:	eb cd 40 e0 	pushm	r5-r7,lr
80004af8:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80004afa:	f0 1f 00 1c 	mcall	80004b68 <vTaskSuspend+0x74>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
80004afe:	49 c8       	lddpc	r8,80004b6c <vTaskSuspend+0x78>
80004b00:	70 08       	ld.w	r8,r8[0x0]
80004b02:	10 37       	cp.w	r7,r8
80004b04:	c0 31       	brne	80004b0a <vTaskSuspend+0x16>
80004b06:	30 07       	mov	r7,0
80004b08:	c0 38       	rjmp	80004b0e <vTaskSuspend+0x1a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
80004b0a:	58 07       	cp.w	r7,0
80004b0c:	c0 41       	brne	80004b14 <vTaskSuspend+0x20>
80004b0e:	49 88       	lddpc	r8,80004b6c <vTaskSuspend+0x78>
80004b10:	70 06       	ld.w	r6,r8[0x0]
80004b12:	c0 28       	rjmp	80004b16 <vTaskSuspend+0x22>
80004b14:	0e 96       	mov	r6,r7

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80004b16:	ec c5 ff fc 	sub	r5,r6,-4
80004b1a:	0a 9c       	mov	r12,r5
80004b1c:	f0 1f 00 15 	mcall	80004b70 <vTaskSuspend+0x7c>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
80004b20:	6c a8       	ld.w	r8,r6[0x28]
80004b22:	58 08       	cp.w	r8,0
80004b24:	c0 50       	breq	80004b2e <vTaskSuspend+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80004b26:	ec cc ff e8 	sub	r12,r6,-24
80004b2a:	f0 1f 00 12 	mcall	80004b70 <vTaskSuspend+0x7c>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
80004b2e:	0a 9b       	mov	r11,r5
80004b30:	49 1c       	lddpc	r12,80004b74 <vTaskSuspend+0x80>
80004b32:	f0 1f 00 12 	mcall	80004b78 <vTaskSuspend+0x84>
		}
		taskEXIT_CRITICAL();
80004b36:	f0 1f 00 12 	mcall	80004b7c <vTaskSuspend+0x88>

		if( ( void * ) pxTaskToSuspend == NULL )
80004b3a:	58 07       	cp.w	r7,0
80004b3c:	c1 31       	brne	80004b62 <vTaskSuspend+0x6e>
		{
			if( xSchedulerRunning != pdFALSE )
80004b3e:	49 18       	lddpc	r8,80004b80 <vTaskSuspend+0x8c>
80004b40:	70 08       	ld.w	r8,r8[0x0]
80004b42:	58 08       	cp.w	r8,0
80004b44:	c0 40       	breq	80004b4c <vTaskSuspend+0x58>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
80004b46:	d7 33       	scall
80004b48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
80004b4c:	48 e8       	lddpc	r8,80004b84 <vTaskSuspend+0x90>
80004b4e:	70 08       	ld.w	r8,r8[0x0]
80004b50:	58 18       	cp.w	r8,1
80004b52:	c0 61       	brne	80004b5e <vTaskSuspend+0x6a>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
80004b54:	30 09       	mov	r9,0
80004b56:	48 68       	lddpc	r8,80004b6c <vTaskSuspend+0x78>
80004b58:	91 09       	st.w	r8[0x0],r9
80004b5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				}
				else
				{
					vTaskSwitchContext();
80004b5e:	f0 1f 00 0b 	mcall	80004b88 <vTaskSuspend+0x94>
80004b62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b66:	00 00       	add	r0,r0
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	3f a8       	mov	r8,-6
80004b6c:	00 00       	add	r0,r0
80004b6e:	08 8c       	andn	r12,r4
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	3e ee       	mov	lr,-18
80004b74:	00 00       	add	r0,r0
80004b76:	08 e0       	st.h	--r4,r0
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	3e 9e       	mov	lr,-23
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	40 b4       	lddsp	r4,sp[0x2c]
80004b80:	00 00       	add	r0,r0
80004b82:	07 c8       	ld.ub	r8,r3[0x4]
80004b84:	00 00       	add	r0,r0
80004b86:	08 d8       	st.w	--r4,r8
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	46 98       	lddsp	r8,sp[0x1a4]

80004b8c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
80004b8c:	eb cd 40 e0 	pushm	r5-r7,lr
80004b90:	18 97       	mov	r7,r12
80004b92:	58 7b       	cp.w	r11,7
80004b94:	f6 05 17 80 	movls	r5,r11
80004b98:	f9 b5 0b 07 	movhi	r5,7
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
80004b9c:	f0 1f 00 20 	mcall	80004c1c <vTaskPrioritySet+0x90>
		{
			if( pxTask == pxCurrentTCB )
80004ba0:	4a 08       	lddpc	r8,80004c20 <vTaskPrioritySet+0x94>
80004ba2:	70 08       	ld.w	r8,r8[0x0]
80004ba4:	10 37       	cp.w	r7,r8
80004ba6:	c0 31       	brne	80004bac <vTaskPrioritySet+0x20>
80004ba8:	30 07       	mov	r7,0
80004baa:	c0 38       	rjmp	80004bb0 <vTaskPrioritySet+0x24>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
80004bac:	58 07       	cp.w	r7,0
80004bae:	c0 41       	brne	80004bb6 <vTaskPrioritySet+0x2a>
80004bb0:	49 c8       	lddpc	r8,80004c20 <vTaskPrioritySet+0x94>
80004bb2:	70 06       	ld.w	r6,r8[0x0]
80004bb4:	c0 28       	rjmp	80004bb8 <vTaskPrioritySet+0x2c>
80004bb6:	0e 96       	mov	r6,r7
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
80004bb8:	6c b8       	ld.w	r8,r6[0x2c]
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
80004bba:	0a 38       	cp.w	r8,r5
80004bbc:	c2 b0       	breq	80004c12 <vTaskPrioritySet+0x86>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
80004bbe:	c0 42       	brcc	80004bc6 <vTaskPrioritySet+0x3a>
80004bc0:	58 07       	cp.w	r7,0
80004bc2:	5f 17       	srne	r7
80004bc4:	c0 38       	rjmp	80004bca <vTaskPrioritySet+0x3e>
80004bc6:	58 07       	cp.w	r7,0
80004bc8:	5f 07       	sreq	r7
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
80004bca:	8d b5       	st.w	r6[0x2c],r5
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
80004bcc:	ea 05 11 08 	rsub	r5,r5,8
80004bd0:	8d 65       	st.w	r6[0x18],r5

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
80004bd2:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004bd6:	49 49       	lddpc	r9,80004c24 <vTaskPrioritySet+0x98>
80004bd8:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004bdc:	6c 59       	ld.w	r9,r6[0x14]
80004bde:	10 39       	cp.w	r9,r8
80004be0:	c1 61       	brne	80004c0c <vTaskPrioritySet+0x80>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
80004be2:	ec c5 ff fc 	sub	r5,r6,-4
80004be6:	0a 9c       	mov	r12,r5
80004be8:	f0 1f 00 10 	mcall	80004c28 <vTaskPrioritySet+0x9c>
					prvAddTaskToReadyQueue( pxTCB );
80004bec:	6c bc       	ld.w	r12,r6[0x2c]
80004bee:	49 08       	lddpc	r8,80004c2c <vTaskPrioritySet+0xa0>
80004bf0:	70 08       	ld.w	r8,r8[0x0]
80004bf2:	10 3c       	cp.w	r12,r8
80004bf4:	e0 88 00 04 	brls	80004bfc <vTaskPrioritySet+0x70>
80004bf8:	48 d8       	lddpc	r8,80004c2c <vTaskPrioritySet+0xa0>
80004bfa:	91 0c       	st.w	r8[0x0],r12
80004bfc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004c00:	0a 9b       	mov	r11,r5
80004c02:	48 98       	lddpc	r8,80004c24 <vTaskPrioritySet+0x98>
80004c04:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004c08:	f0 1f 00 0a 	mcall	80004c30 <vTaskPrioritySet+0xa4>
				}

				if( xYieldRequired == pdTRUE )
80004c0c:	58 17       	cp.w	r7,1
80004c0e:	c0 21       	brne	80004c12 <vTaskPrioritySet+0x86>
				{
					portYIELD_WITHIN_API();
80004c10:	d7 33       	scall
				}
			}
		}
		taskEXIT_CRITICAL();
80004c12:	f0 1f 00 09 	mcall	80004c34 <vTaskPrioritySet+0xa8>
	}
80004c16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c1a:	00 00       	add	r0,r0
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	3f a8       	mov	r8,-6
80004c20:	00 00       	add	r0,r0
80004c22:	08 8c       	andn	r12,r4
80004c24:	00 00       	add	r0,r0
80004c26:	07 d8       	ld.ub	r8,r3[0x5]
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	3e ee       	mov	lr,-18
80004c2c:	00 00       	add	r0,r0
80004c2e:	08 f4       	st.b	--r4,r4
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	3e 9e       	mov	lr,-23
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	40 b4       	lddsp	r4,sp[0x2c]

80004c38 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
80004c38:	eb cd 40 e0 	pushm	r5-r7,lr
80004c3c:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80004c3e:	f0 1f 00 19 	mcall	80004ca0 <vTaskDelete+0x68>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
80004c42:	49 98       	lddpc	r8,80004ca4 <vTaskDelete+0x6c>
80004c44:	70 08       	ld.w	r8,r8[0x0]
80004c46:	10 37       	cp.w	r7,r8
80004c48:	c0 31       	brne	80004c4e <vTaskDelete+0x16>
80004c4a:	30 07       	mov	r7,0
80004c4c:	c0 38       	rjmp	80004c52 <vTaskDelete+0x1a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
80004c4e:	58 07       	cp.w	r7,0
80004c50:	c0 41       	brne	80004c58 <vTaskDelete+0x20>
80004c52:	49 58       	lddpc	r8,80004ca4 <vTaskDelete+0x6c>
80004c54:	70 06       	ld.w	r6,r8[0x0]
80004c56:	c0 28       	rjmp	80004c5a <vTaskDelete+0x22>
80004c58:	0e 96       	mov	r6,r7

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80004c5a:	ec c5 ff fc 	sub	r5,r6,-4
80004c5e:	0a 9c       	mov	r12,r5
80004c60:	f0 1f 00 12 	mcall	80004ca8 <vTaskDelete+0x70>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
80004c64:	6c a8       	ld.w	r8,r6[0x28]
80004c66:	58 08       	cp.w	r8,0
80004c68:	c0 50       	breq	80004c72 <vTaskDelete+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80004c6a:	ec cc ff e8 	sub	r12,r6,-24
80004c6e:	f0 1f 00 0f 	mcall	80004ca8 <vTaskDelete+0x70>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
80004c72:	0a 9b       	mov	r11,r5
80004c74:	48 ec       	lddpc	r12,80004cac <vTaskDelete+0x74>
80004c76:	f0 1f 00 0f 	mcall	80004cb0 <vTaskDelete+0x78>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
80004c7a:	48 f8       	lddpc	r8,80004cb4 <vTaskDelete+0x7c>
80004c7c:	70 09       	ld.w	r9,r8[0x0]
80004c7e:	2f f9       	sub	r9,-1
80004c80:	91 09       	st.w	r8[0x0],r9

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
80004c82:	48 e8       	lddpc	r8,80004cb8 <vTaskDelete+0x80>
80004c84:	70 09       	ld.w	r9,r8[0x0]
80004c86:	2f f9       	sub	r9,-1
80004c88:	91 09       	st.w	r8[0x0],r9

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
80004c8a:	f0 1f 00 0d 	mcall	80004cbc <vTaskDelete+0x84>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
80004c8e:	48 d8       	lddpc	r8,80004cc0 <vTaskDelete+0x88>
80004c90:	70 08       	ld.w	r8,r8[0x0]
80004c92:	58 08       	cp.w	r8,0
80004c94:	c0 40       	breq	80004c9c <vTaskDelete+0x64>
		{
			if( ( void * ) pxTaskToDelete == NULL )
80004c96:	58 07       	cp.w	r7,0
80004c98:	c0 21       	brne	80004c9c <vTaskDelete+0x64>
			{
				portYIELD_WITHIN_API();
80004c9a:	d7 33       	scall
80004c9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	3f a8       	mov	r8,-6
80004ca4:	00 00       	add	r0,r0
80004ca6:	08 8c       	andn	r12,r4
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	3e ee       	mov	lr,-18
80004cac:	00 00       	add	r0,r0
80004cae:	08 78       	tst	r8,r4
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	3e 9e       	mov	lr,-23
80004cb4:	00 00       	add	r0,r0
80004cb6:	07 cc       	ld.ub	r12,r3[0x4]
80004cb8:	00 00       	add	r0,r0
80004cba:	08 d4       	st.w	--r4,r4
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	40 b4       	lddsp	r4,sp[0x2c]
80004cc0:	00 00       	add	r0,r0
80004cc2:	07 c8       	ld.ub	r8,r3[0x4]

80004cc4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004cc4:	eb cd 40 80 	pushm	r7,lr
80004cc8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80004cca:	49 08       	lddpc	r8,80004d08 <prvAddCurrentTaskToDelayedList+0x44>
80004ccc:	70 08       	ld.w	r8,r8[0x0]
80004cce:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80004cd0:	48 f8       	lddpc	r8,80004d0c <prvAddCurrentTaskToDelayedList+0x48>
80004cd2:	70 08       	ld.w	r8,r8[0x0]
80004cd4:	10 3c       	cp.w	r12,r8
80004cd6:	c0 a2       	brcc	80004cea <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004cd8:	48 c8       	lddpc	r8,80004d08 <prvAddCurrentTaskToDelayedList+0x44>
80004cda:	70 0b       	ld.w	r11,r8[0x0]
80004cdc:	48 d8       	lddpc	r8,80004d10 <prvAddCurrentTaskToDelayedList+0x4c>
80004cde:	70 0c       	ld.w	r12,r8[0x0]
80004ce0:	2f cb       	sub	r11,-4
80004ce2:	f0 1f 00 0d 	mcall	80004d14 <prvAddCurrentTaskToDelayedList+0x50>
80004ce6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004cea:	48 88       	lddpc	r8,80004d08 <prvAddCurrentTaskToDelayedList+0x44>
80004cec:	70 0b       	ld.w	r11,r8[0x0]
80004cee:	48 b8       	lddpc	r8,80004d18 <prvAddCurrentTaskToDelayedList+0x54>
80004cf0:	70 0c       	ld.w	r12,r8[0x0]
80004cf2:	2f cb       	sub	r11,-4
80004cf4:	f0 1f 00 08 	mcall	80004d14 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80004cf8:	48 98       	lddpc	r8,80004d1c <prvAddCurrentTaskToDelayedList+0x58>
80004cfa:	70 08       	ld.w	r8,r8[0x0]
80004cfc:	10 37       	cp.w	r7,r8
80004cfe:	c0 32       	brcc	80004d04 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80004d00:	48 78       	lddpc	r8,80004d1c <prvAddCurrentTaskToDelayedList+0x58>
80004d02:	91 07       	st.w	r8[0x0],r7
80004d04:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d08:	00 00       	add	r0,r0
80004d0a:	08 8c       	andn	r12,r4
80004d0c:	00 00       	add	r0,r0
80004d0e:	08 b8       	st.h	r4++,r8
80004d10:	00 00       	add	r0,r0
80004d12:	07 d4       	ld.ub	r4,r3[0x5]
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	3e ba       	mov	r10,-21
80004d18:	00 00       	add	r0,r0
80004d1a:	07 c4       	ld.ub	r4,r3[0x4]
80004d1c:	00 00       	add	r0,r0
80004d1e:	00 30       	cp.w	r0,r0

80004d20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80004d20:	eb cd 40 c0 	pushm	r6-r7,lr
80004d24:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80004d26:	58 0c       	cp.w	r12,0
80004d28:	c1 10       	breq	80004d4a <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80004d2a:	f0 1f 00 0a 	mcall	80004d50 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80004d2e:	48 a8       	lddpc	r8,80004d54 <vTaskDelay+0x34>
80004d30:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004d32:	48 a8       	lddpc	r8,80004d58 <vTaskDelay+0x38>
80004d34:	70 0c       	ld.w	r12,r8[0x0]
80004d36:	2f cc       	sub	r12,-4
80004d38:	f0 1f 00 09 	mcall	80004d5c <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80004d3c:	ee 06 00 0c 	add	r12,r7,r6
80004d40:	f0 1f 00 08 	mcall	80004d60 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80004d44:	f0 1f 00 08 	mcall	80004d64 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004d48:	c0 21       	brne	80004d4c <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80004d4a:	d7 33       	scall
80004d4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d50:	80 00       	ld.sh	r0,r0[0x0]
80004d52:	46 7c       	lddsp	r12,sp[0x19c]
80004d54:	00 00       	add	r0,r0
80004d56:	08 b8       	st.h	r4++,r8
80004d58:	00 00       	add	r0,r0
80004d5a:	08 8c       	andn	r12,r4
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	3e ee       	mov	lr,-18
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	4c c4       	lddpc	r4,80004e90 <prvIdleTask+0x50>
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	49 8c       	lddpc	r12,80004dc4 <vTaskDelayUntil+0x5c>

80004d68 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80004d68:	eb cd 40 c0 	pushm	r6-r7,lr
80004d6c:	18 96       	mov	r6,r12
80004d6e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80004d70:	f0 1f 00 18 	mcall	80004dd0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80004d74:	6c 08       	ld.w	r8,r6[0x0]
80004d76:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80004d78:	49 79       	lddpc	r9,80004dd4 <vTaskDelayUntil+0x6c>
80004d7a:	72 09       	ld.w	r9,r9[0x0]
80004d7c:	12 38       	cp.w	r8,r9
80004d7e:	e0 88 00 0c 	brls	80004d96 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80004d82:	0e 38       	cp.w	r8,r7
80004d84:	e0 88 00 22 	brls	80004dc8 <vTaskDelayUntil+0x60>
80004d88:	49 38       	lddpc	r8,80004dd4 <vTaskDelayUntil+0x6c>
80004d8a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80004d8c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80004d8e:	10 37       	cp.w	r7,r8
80004d90:	e0 88 00 14 	brls	80004db8 <vTaskDelayUntil+0x50>
80004d94:	c0 a8       	rjmp	80004da8 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80004d96:	0e 38       	cp.w	r8,r7
80004d98:	e0 8b 00 16 	brhi	80004dc4 <vTaskDelayUntil+0x5c>
80004d9c:	48 e8       	lddpc	r8,80004dd4 <vTaskDelayUntil+0x6c>
80004d9e:	70 08       	ld.w	r8,r8[0x0]
80004da0:	10 37       	cp.w	r7,r8
80004da2:	e0 8b 00 11 	brhi	80004dc4 <vTaskDelayUntil+0x5c>
80004da6:	c1 18       	rjmp	80004dc8 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004da8:	48 c8       	lddpc	r8,80004dd8 <vTaskDelayUntil+0x70>
80004daa:	70 0c       	ld.w	r12,r8[0x0]
80004dac:	2f cc       	sub	r12,-4
80004dae:	f0 1f 00 0c 	mcall	80004ddc <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80004db2:	0e 9c       	mov	r12,r7
80004db4:	f0 1f 00 0b 	mcall	80004de0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80004db8:	f0 1f 00 0b 	mcall	80004de4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004dbc:	c0 81       	brne	80004dcc <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80004dbe:	d7 33       	scall
80004dc0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80004dc4:	8d 07       	st.w	r6[0x0],r7
80004dc6:	cf 1b       	rjmp	80004da8 <vTaskDelayUntil+0x40>
80004dc8:	8d 07       	st.w	r6[0x0],r7
80004dca:	cf 7b       	rjmp	80004db8 <vTaskDelayUntil+0x50>
80004dcc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	46 7c       	lddsp	r12,sp[0x19c]
80004dd4:	00 00       	add	r0,r0
80004dd6:	08 b8       	st.h	r4++,r8
80004dd8:	00 00       	add	r0,r0
80004dda:	08 8c       	andn	r12,r4
80004ddc:	80 00       	ld.sh	r0,r0[0x0]
80004dde:	3e ee       	mov	lr,-18
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	4c c4       	lddpc	r4,80004f10 <xTaskGenericCreate+0x50>
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	49 8c       	lddpc	r12,80004e44 <prvIdleTask+0x4>

80004de8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80004de8:	eb cd 40 c0 	pushm	r6-r7,lr
80004dec:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80004dee:	48 e7       	lddpc	r7,80004e24 <vTaskPlaceOnEventList+0x3c>
80004df0:	6e 0b       	ld.w	r11,r7[0x0]
80004df2:	2e 8b       	sub	r11,-24
80004df4:	f0 1f 00 0d 	mcall	80004e28 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004df8:	6e 0c       	ld.w	r12,r7[0x0]
80004dfa:	2f cc       	sub	r12,-4
80004dfc:	f0 1f 00 0c 	mcall	80004e2c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80004e00:	5b f6       	cp.w	r6,-1
80004e02:	c0 81       	brne	80004e12 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004e04:	6e 0b       	ld.w	r11,r7[0x0]
80004e06:	2f cb       	sub	r11,-4
80004e08:	48 ac       	lddpc	r12,80004e30 <vTaskPlaceOnEventList+0x48>
80004e0a:	f0 1f 00 0b 	mcall	80004e34 <vTaskPlaceOnEventList+0x4c>
80004e0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80004e12:	48 a8       	lddpc	r8,80004e38 <vTaskPlaceOnEventList+0x50>
80004e14:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80004e16:	ec 0c 00 0c 	add	r12,r6,r12
80004e1a:	f0 1f 00 09 	mcall	80004e3c <vTaskPlaceOnEventList+0x54>
80004e1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e22:	00 00       	add	r0,r0
80004e24:	00 00       	add	r0,r0
80004e26:	08 8c       	andn	r12,r4
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	3e ba       	mov	r10,-21
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	3e ee       	mov	lr,-18
80004e30:	00 00       	add	r0,r0
80004e32:	08 e0       	st.h	--r4,r0
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	3e 9e       	mov	lr,-23
80004e38:	00 00       	add	r0,r0
80004e3a:	08 b8       	st.h	r4++,r8
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	4c c4       	lddpc	r4,80004f6c <xTaskGenericCreate+0xac>

80004e40 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80004e40:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004e44:	49 57       	lddpc	r7,80004e98 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004e46:	49 64       	lddpc	r4,80004e9c <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80004e48:	49 63       	lddpc	r3,80004ea0 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004e4a:	49 75       	lddpc	r5,80004ea4 <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004e4c:	6e 08       	ld.w	r8,r7[0x0]
80004e4e:	58 08       	cp.w	r8,0
80004e50:	c1 e0       	breq	80004e8c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80004e52:	f0 1f 00 16 	mcall	80004ea8 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004e56:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80004e58:	f0 1f 00 15 	mcall	80004eac <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
80004e5c:	58 06       	cp.w	r6,0
80004e5e:	c1 70       	breq	80004e8c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80004e60:	f0 1f 00 14 	mcall	80004eb0 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80004e64:	68 38       	ld.w	r8,r4[0xc]
80004e66:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80004e68:	ec cc ff fc 	sub	r12,r6,-4
80004e6c:	f0 1f 00 12 	mcall	80004eb4 <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80004e70:	66 08       	ld.w	r8,r3[0x0]
80004e72:	20 18       	sub	r8,1
80004e74:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80004e76:	6e 08       	ld.w	r8,r7[0x0]
80004e78:	20 18       	sub	r8,1
80004e7a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80004e7c:	f0 1f 00 0f 	mcall	80004eb8 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80004e80:	6c cc       	ld.w	r12,r6[0x30]
80004e82:	f0 1f 00 0f 	mcall	80004ebc <prvIdleTask+0x7c>
		vPortFree( pxTCB );
80004e86:	0c 9c       	mov	r12,r6
80004e88:	f0 1f 00 0d 	mcall	80004ebc <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004e8c:	6a 08       	ld.w	r8,r5[0x0]
80004e8e:	58 18       	cp.w	r8,1
80004e90:	fe 98 ff de 	brls	80004e4c <prvIdleTask+0xc>
			{
				taskYIELD();
80004e94:	d7 33       	scall
80004e96:	cd bb       	rjmp	80004e4c <prvIdleTask+0xc>
80004e98:	00 00       	add	r0,r0
80004e9a:	07 cc       	ld.ub	r12,r3[0x4]
80004e9c:	00 00       	add	r0,r0
80004e9e:	08 78       	tst	r8,r4
80004ea0:	00 00       	add	r0,r0
80004ea2:	08 d8       	st.w	--r4,r8
80004ea4:	00 00       	add	r0,r0
80004ea6:	07 d8       	ld.ub	r8,r3[0x5]
80004ea8:	80 00       	ld.sh	r0,r0[0x0]
80004eaa:	46 7c       	lddsp	r12,sp[0x19c]
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	49 8c       	lddpc	r12,80004f0c <xTaskGenericCreate+0x4c>
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	3f a8       	mov	r8,-6
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	3e ee       	mov	lr,-18
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	40 b4       	lddsp	r4,sp[0x2c]
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	41 88       	lddsp	r8,sp[0x60]

80004ec0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80004ec0:	d4 31       	pushm	r0-r7,lr
80004ec2:	20 1d       	sub	sp,4
80004ec4:	fa c4 ff d8 	sub	r4,sp,-40
80004ec8:	50 0c       	stdsp	sp[0x0],r12
80004eca:	16 91       	mov	r1,r11
80004ecc:	14 97       	mov	r7,r10
80004ece:	12 90       	mov	r0,r9
80004ed0:	10 93       	mov	r3,r8
80004ed2:	68 02       	ld.w	r2,r4[0x0]
80004ed4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80004ed6:	34 4c       	mov	r12,68
80004ed8:	f0 1f 00 5b 	mcall	80005044 <xTaskGenericCreate+0x184>
80004edc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004ede:	c0 31       	brne	80004ee4 <xTaskGenericCreate+0x24>
80004ee0:	3f fc       	mov	r12,-1
80004ee2:	ca d8       	rjmp	8000503c <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004ee4:	58 06       	cp.w	r6,0
80004ee6:	e0 81 00 ad 	brne	80005040 <xTaskGenericCreate+0x180>
80004eea:	0e 9c       	mov	r12,r7
80004eec:	5c 7c       	castu.h	r12
80004eee:	a3 6c       	lsl	r12,0x2
80004ef0:	f0 1f 00 55 	mcall	80005044 <xTaskGenericCreate+0x184>
80004ef4:	18 96       	mov	r6,r12
80004ef6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80004ef8:	c0 61       	brne	80004f04 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004efa:	0a 9c       	mov	r12,r5
80004efc:	f0 1f 00 53 	mcall	80005048 <xTaskGenericCreate+0x188>
80004f00:	3f fc       	mov	r12,-1
80004f02:	c9 d8       	rjmp	8000503c <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80004f04:	5c 77       	castu.h	r7
80004f06:	ee 0a 15 02 	lsl	r10,r7,0x2
80004f0a:	e0 6b 00 a5 	mov	r11,165
80004f0e:	0c 9c       	mov	r12,r6
80004f10:	f0 1f 00 4f 	mcall	8000504c <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80004f14:	ee c6 00 01 	sub	r6,r7,1
80004f18:	6a c8       	ld.w	r8,r5[0x30]
80004f1a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004f1e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80004f22:	31 0a       	mov	r10,16
80004f24:	02 9b       	mov	r11,r1
80004f26:	ea cc ff cc 	sub	r12,r5,-52
80004f2a:	f0 1f 00 4a 	mcall	80005050 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004f2e:	30 08       	mov	r8,0
80004f30:	eb 68 00 43 	st.b	r5[67],r8
80004f34:	58 73       	cp.w	r3,7
80004f36:	e6 07 17 80 	movls	r7,r3
80004f3a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80004f3e:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80004f40:	ea c4 ff fc 	sub	r4,r5,-4
80004f44:	08 9c       	mov	r12,r4
80004f46:	f0 1f 00 44 	mcall	80005054 <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80004f4a:	ea cc ff e8 	sub	r12,r5,-24
80004f4e:	f0 1f 00 42 	mcall	80005054 <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80004f52:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80004f54:	ee 07 11 08 	rsub	r7,r7,8
80004f58:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80004f5a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80004f5c:	00 9a       	mov	r10,r0
80004f5e:	40 0b       	lddsp	r11,sp[0x0]
80004f60:	0c 9c       	mov	r12,r6
80004f62:	f0 1f 00 3e 	mcall	80005058 <xTaskGenericCreate+0x198>
80004f66:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80004f68:	58 02       	cp.w	r2,0
80004f6a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80004f6e:	f0 1f 00 3c 	mcall	8000505c <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80004f72:	4b c8       	lddpc	r8,80005060 <xTaskGenericCreate+0x1a0>
80004f74:	70 09       	ld.w	r9,r8[0x0]
80004f76:	2f f9       	sub	r9,-1
80004f78:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80004f7a:	4b b8       	lddpc	r8,80005064 <xTaskGenericCreate+0x1a4>
80004f7c:	70 08       	ld.w	r8,r8[0x0]
80004f7e:	58 08       	cp.w	r8,0
80004f80:	c2 61       	brne	80004fcc <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80004f82:	4b 98       	lddpc	r8,80005064 <xTaskGenericCreate+0x1a4>
80004f84:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80004f86:	4b 78       	lddpc	r8,80005060 <xTaskGenericCreate+0x1a0>
80004f88:	70 08       	ld.w	r8,r8[0x0]
80004f8a:	58 18       	cp.w	r8,1
80004f8c:	c2 b1       	brne	80004fe2 <xTaskGenericCreate+0x122>
80004f8e:	4b 77       	lddpc	r7,80005068 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80004f90:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80004f94:	0e 9c       	mov	r12,r7
80004f96:	f0 1f 00 36 	mcall	8000506c <xTaskGenericCreate+0x1ac>
80004f9a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004f9c:	0c 37       	cp.w	r7,r6
80004f9e:	cf b1       	brne	80004f94 <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004fa0:	4b 47       	lddpc	r7,80005070 <xTaskGenericCreate+0x1b0>
80004fa2:	0e 9c       	mov	r12,r7
80004fa4:	f0 1f 00 32 	mcall	8000506c <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004fa8:	4b 36       	lddpc	r6,80005074 <xTaskGenericCreate+0x1b4>
80004faa:	0c 9c       	mov	r12,r6
80004fac:	f0 1f 00 30 	mcall	8000506c <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004fb0:	4b 2c       	lddpc	r12,80005078 <xTaskGenericCreate+0x1b8>
80004fb2:	f0 1f 00 2f 	mcall	8000506c <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80004fb6:	4b 2c       	lddpc	r12,8000507c <xTaskGenericCreate+0x1bc>
80004fb8:	f0 1f 00 2d 	mcall	8000506c <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004fbc:	4b 1c       	lddpc	r12,80005080 <xTaskGenericCreate+0x1c0>
80004fbe:	f0 1f 00 2c 	mcall	8000506c <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80004fc2:	4b 18       	lddpc	r8,80005084 <xTaskGenericCreate+0x1c4>
80004fc4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80004fc6:	4b 18       	lddpc	r8,80005088 <xTaskGenericCreate+0x1c8>
80004fc8:	91 06       	st.w	r8[0x0],r6
80004fca:	c0 c8       	rjmp	80004fe2 <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80004fcc:	4b 08       	lddpc	r8,8000508c <xTaskGenericCreate+0x1cc>
80004fce:	70 08       	ld.w	r8,r8[0x0]
80004fd0:	58 08       	cp.w	r8,0
80004fd2:	c0 81       	brne	80004fe2 <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80004fd4:	4a 48       	lddpc	r8,80005064 <xTaskGenericCreate+0x1a4>
80004fd6:	70 08       	ld.w	r8,r8[0x0]
80004fd8:	70 b8       	ld.w	r8,r8[0x2c]
80004fda:	10 33       	cp.w	r3,r8
80004fdc:	c0 33       	brcs	80004fe2 <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80004fde:	4a 28       	lddpc	r8,80005064 <xTaskGenericCreate+0x1a4>
80004fe0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80004fe2:	6a b8       	ld.w	r8,r5[0x2c]
80004fe4:	4a b9       	lddpc	r9,80005090 <xTaskGenericCreate+0x1d0>
80004fe6:	72 09       	ld.w	r9,r9[0x0]
80004fe8:	12 38       	cp.w	r8,r9
80004fea:	e0 88 00 04 	brls	80004ff2 <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004fee:	4a 99       	lddpc	r9,80005090 <xTaskGenericCreate+0x1d0>
80004ff0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80004ff2:	4a 98       	lddpc	r8,80005094 <xTaskGenericCreate+0x1d4>
80004ff4:	70 09       	ld.w	r9,r8[0x0]
80004ff6:	2f f9       	sub	r9,-1
80004ff8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80004ffa:	6a b8       	ld.w	r8,r5[0x2c]
80004ffc:	4a 79       	lddpc	r9,80005098 <xTaskGenericCreate+0x1d8>
80004ffe:	72 09       	ld.w	r9,r9[0x0]
80005000:	12 38       	cp.w	r8,r9
80005002:	e0 88 00 04 	brls	8000500a <xTaskGenericCreate+0x14a>
80005006:	4a 59       	lddpc	r9,80005098 <xTaskGenericCreate+0x1d8>
80005008:	93 08       	st.w	r9[0x0],r8
8000500a:	6a bc       	ld.w	r12,r5[0x2c]
8000500c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005010:	08 9b       	mov	r11,r4
80005012:	49 68       	lddpc	r8,80005068 <xTaskGenericCreate+0x1a8>
80005014:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005018:	f0 1f 00 21 	mcall	8000509c <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000501c:	f0 1f 00 21 	mcall	800050a0 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005020:	49 b8       	lddpc	r8,8000508c <xTaskGenericCreate+0x1cc>
80005022:	70 08       	ld.w	r8,r8[0x0]
80005024:	58 08       	cp.w	r8,0
80005026:	c0 a0       	breq	8000503a <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005028:	48 f8       	lddpc	r8,80005064 <xTaskGenericCreate+0x1a4>
8000502a:	70 08       	ld.w	r8,r8[0x0]
8000502c:	70 b8       	ld.w	r8,r8[0x2c]
8000502e:	10 33       	cp.w	r3,r8
80005030:	e0 88 00 05 	brls	8000503a <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
80005034:	d7 33       	scall
80005036:	30 1c       	mov	r12,1
80005038:	c0 28       	rjmp	8000503c <xTaskGenericCreate+0x17c>
8000503a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000503c:	2f fd       	sub	sp,-4
8000503e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005040:	99 c6       	st.w	r12[0x30],r6
80005042:	c6 1b       	rjmp	80004f04 <xTaskGenericCreate+0x44>
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	41 b0       	lddsp	r0,sp[0x6c]
80005048:	80 00       	ld.sh	r0,r0[0x0]
8000504a:	41 88       	lddsp	r8,sp[0x60]
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	5f a8       	srle	r8
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	5f d8       	srvc	r8
80005054:	80 00       	ld.sh	r0,r0[0x0]
80005056:	3e 98       	mov	r8,-23
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	3f 14       	mov	r4,-15
8000505c:	80 00       	ld.sh	r0,r0[0x0]
8000505e:	3f a8       	mov	r8,-6
80005060:	00 00       	add	r0,r0
80005062:	08 d8       	st.w	--r4,r8
80005064:	00 00       	add	r0,r0
80005066:	08 8c       	andn	r12,r4
80005068:	00 00       	add	r0,r0
8000506a:	07 d8       	ld.ub	r8,r3[0x5]
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	3e 84       	mov	r4,-24
80005070:	00 00       	add	r0,r0
80005072:	08 a4       	st.w	r4++,r4
80005074:	00 00       	add	r0,r0
80005076:	08 c0       	st.b	r4++,r0
80005078:	00 00       	add	r0,r0
8000507a:	08 90       	mov	r0,r4
8000507c:	00 00       	add	r0,r0
8000507e:	08 78       	tst	r8,r4
80005080:	00 00       	add	r0,r0
80005082:	08 e0       	st.h	--r4,r0
80005084:	00 00       	add	r0,r0
80005086:	07 c4       	ld.ub	r4,r3[0x4]
80005088:	00 00       	add	r0,r0
8000508a:	07 d4       	ld.ub	r4,r3[0x5]
8000508c:	00 00       	add	r0,r0
8000508e:	07 c8       	ld.ub	r8,r3[0x4]
80005090:	00 00       	add	r0,r0
80005092:	07 c0       	ld.ub	r0,r3[0x4]
80005094:	00 00       	add	r0,r0
80005096:	08 d4       	st.w	--r4,r4
80005098:	00 00       	add	r0,r0
8000509a:	08 f4       	st.b	--r4,r4
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	3e 9e       	mov	lr,-23
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	40 b4       	lddsp	r4,sp[0x2c]

800050a4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800050a4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800050a6:	30 09       	mov	r9,0
800050a8:	1a d9       	st.w	--sp,r9
800050aa:	1a d9       	st.w	--sp,r9
800050ac:	1a d9       	st.w	--sp,r9
800050ae:	12 98       	mov	r8,r9
800050b0:	e0 6a 01 00 	mov	r10,256
800050b4:	48 9b       	lddpc	r11,800050d8 <vTaskStartScheduler+0x34>
800050b6:	48 ac       	lddpc	r12,800050dc <vTaskStartScheduler+0x38>
800050b8:	f0 1f 00 0a 	mcall	800050e0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800050bc:	2f dd       	sub	sp,-12
800050be:	58 1c       	cp.w	r12,1
800050c0:	c0 a1       	brne	800050d4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800050c2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800050c4:	30 19       	mov	r9,1
800050c6:	48 88       	lddpc	r8,800050e4 <vTaskStartScheduler+0x40>
800050c8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800050ca:	30 09       	mov	r9,0
800050cc:	48 78       	lddpc	r8,800050e8 <vTaskStartScheduler+0x44>
800050ce:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800050d0:	f0 1f 00 07 	mcall	800050ec <vTaskStartScheduler+0x48>
800050d4:	d8 02       	popm	pc
800050d6:	00 00       	add	r0,r0
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	69 24       	ld.w	r4,r4[0x48]
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	4e 40       	lddpc	r0,8000526c <__avr32_f64_mul_res_subnormal+0x32>
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	4e c0       	lddpc	r0,80005290 <__avr32_f64_mul_res_zero+0x4>
800050e4:	00 00       	add	r0,r0
800050e6:	07 c8       	ld.ub	r8,r3[0x4]
800050e8:	00 00       	add	r0,r0
800050ea:	08 b8       	st.h	r4++,r8
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	3f b8       	mov	r8,-5

800050f0 <__avr32_f64_mul>:
800050f0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
800050f4:	e0 80 00 dc 	breq	800052ac <__avr32_f64_mul_op1_zero>
800050f8:	d4 21       	pushm	r4-r7,lr
800050fa:	f7 e9 20 0e 	eor	lr,r11,r9
800050fe:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80005102:	30 15       	mov	r5,1
80005104:	c4 30       	breq	8000518a <__avr32_f64_mul_op1_subnormal>
80005106:	ab 6b       	lsl	r11,0xa
80005108:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000510c:	ab 6a       	lsl	r10,0xa
8000510e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80005112:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80005116:	c5 c0       	breq	800051ce <__avr32_f64_mul_op2_subnormal>
80005118:	a1 78       	lsl	r8,0x1
8000511a:	5c f9       	rol	r9
8000511c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80005120:	e0 47 07 ff 	cp.w	r7,2047
80005124:	c7 70       	breq	80005212 <__avr32_f64_mul_op_nan_or_inf>
80005126:	e0 46 07 ff 	cp.w	r6,2047
8000512a:	c7 40       	breq	80005212 <__avr32_f64_mul_op_nan_or_inf>
8000512c:	ee 06 00 0c 	add	r12,r7,r6
80005130:	e0 2c 03 fe 	sub	r12,1022
80005134:	f6 08 06 44 	mulu.d	r4,r11,r8
80005138:	f4 09 07 44 	macu.d	r4,r10,r9
8000513c:	f4 08 06 46 	mulu.d	r6,r10,r8
80005140:	f6 09 06 4a 	mulu.d	r10,r11,r9
80005144:	08 07       	add	r7,r4
80005146:	f4 05 00 4a 	adc	r10,r10,r5
8000514a:	5c 0b       	acr	r11
8000514c:	ed bb 00 14 	bld	r11,0x14
80005150:	c0 50       	breq	8000515a <__avr32_f64_mul+0x6a>
80005152:	a1 77       	lsl	r7,0x1
80005154:	5c fa       	rol	r10
80005156:	5c fb       	rol	r11
80005158:	20 1c       	sub	r12,1
8000515a:	58 0c       	cp.w	r12,0
8000515c:	e0 8a 00 6f 	brle	8000523a <__avr32_f64_mul_res_subnormal>
80005160:	e0 4c 07 ff 	cp.w	r12,2047
80005164:	e0 84 00 9c 	brge	8000529c <__avr32_f64_mul_res_inf>
80005168:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000516c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80005170:	ef e6 12 17 	or	r7,r7,r6>>0x1
80005174:	ee 17 80 00 	eorh	r7,0x8000
80005178:	f1 b7 04 20 	satu	r7,0x1
8000517c:	0e 0a       	add	r10,r7
8000517e:	5c 0b       	acr	r11
80005180:	ed be 00 1f 	bld	lr,0x1f
80005184:	ef bb 00 1f 	bst	r11,0x1f
80005188:	d8 22       	popm	r4-r7,pc

8000518a <__avr32_f64_mul_op1_subnormal>:
8000518a:	e4 1b 00 0f 	andh	r11,0xf
8000518e:	f4 0c 12 00 	clz	r12,r10
80005192:	f6 06 12 00 	clz	r6,r11
80005196:	f7 bc 03 e1 	sublo	r12,-31
8000519a:	f8 06 17 30 	movlo	r6,r12
8000519e:	f7 b6 02 01 	subhs	r6,1
800051a2:	e0 46 00 20 	cp.w	r6,32
800051a6:	c0 d4       	brge	800051c0 <__avr32_f64_mul_op1_subnormal+0x36>
800051a8:	ec 0c 11 20 	rsub	r12,r6,32
800051ac:	f6 06 09 4b 	lsl	r11,r11,r6
800051b0:	f4 0c 0a 4c 	lsr	r12,r10,r12
800051b4:	18 4b       	or	r11,r12
800051b6:	f4 06 09 4a 	lsl	r10,r10,r6
800051ba:	20 b6       	sub	r6,11
800051bc:	0c 17       	sub	r7,r6
800051be:	ca ab       	rjmp	80005112 <__avr32_f64_mul+0x22>
800051c0:	f4 06 09 4b 	lsl	r11,r10,r6
800051c4:	c6 40       	breq	8000528c <__avr32_f64_mul_res_zero>
800051c6:	30 0a       	mov	r10,0
800051c8:	20 b6       	sub	r6,11
800051ca:	0c 17       	sub	r7,r6
800051cc:	ca 3b       	rjmp	80005112 <__avr32_f64_mul+0x22>

800051ce <__avr32_f64_mul_op2_subnormal>:
800051ce:	e4 19 00 0f 	andh	r9,0xf
800051d2:	f0 0c 12 00 	clz	r12,r8
800051d6:	f2 05 12 00 	clz	r5,r9
800051da:	f7 bc 03 ea 	sublo	r12,-22
800051de:	f8 05 17 30 	movlo	r5,r12
800051e2:	f7 b5 02 0a 	subhs	r5,10
800051e6:	e0 45 00 20 	cp.w	r5,32
800051ea:	c0 d4       	brge	80005204 <__avr32_f64_mul_op2_subnormal+0x36>
800051ec:	ea 0c 11 20 	rsub	r12,r5,32
800051f0:	f2 05 09 49 	lsl	r9,r9,r5
800051f4:	f0 0c 0a 4c 	lsr	r12,r8,r12
800051f8:	18 49       	or	r9,r12
800051fa:	f0 05 09 48 	lsl	r8,r8,r5
800051fe:	20 25       	sub	r5,2
80005200:	0a 16       	sub	r6,r5
80005202:	c8 fb       	rjmp	80005120 <__avr32_f64_mul+0x30>
80005204:	f0 05 09 49 	lsl	r9,r8,r5
80005208:	c4 20       	breq	8000528c <__avr32_f64_mul_res_zero>
8000520a:	30 08       	mov	r8,0
8000520c:	20 25       	sub	r5,2
8000520e:	0a 16       	sub	r6,r5
80005210:	c8 8b       	rjmp	80005120 <__avr32_f64_mul+0x30>

80005212 <__avr32_f64_mul_op_nan_or_inf>:
80005212:	e4 19 00 0f 	andh	r9,0xf
80005216:	e4 1b 00 0f 	andh	r11,0xf
8000521a:	14 4b       	or	r11,r10
8000521c:	10 49       	or	r9,r8
8000521e:	e0 47 07 ff 	cp.w	r7,2047
80005222:	c0 91       	brne	80005234 <__avr32_f64_mul_op1_not_naninf>
80005224:	58 0b       	cp.w	r11,0
80005226:	c3 81       	brne	80005296 <__avr32_f64_mul_res_nan>
80005228:	e0 46 07 ff 	cp.w	r6,2047
8000522c:	c3 81       	brne	8000529c <__avr32_f64_mul_res_inf>
8000522e:	58 09       	cp.w	r9,0
80005230:	c3 60       	breq	8000529c <__avr32_f64_mul_res_inf>
80005232:	c3 28       	rjmp	80005296 <__avr32_f64_mul_res_nan>

80005234 <__avr32_f64_mul_op1_not_naninf>:
80005234:	58 09       	cp.w	r9,0
80005236:	c3 30       	breq	8000529c <__avr32_f64_mul_res_inf>
80005238:	c2 f8       	rjmp	80005296 <__avr32_f64_mul_res_nan>

8000523a <__avr32_f64_mul_res_subnormal>:
8000523a:	5c 3c       	neg	r12
8000523c:	2f fc       	sub	r12,-1
8000523e:	f1 bc 04 c0 	satu	r12,0x6
80005242:	e0 4c 00 20 	cp.w	r12,32
80005246:	c1 14       	brge	80005268 <__avr32_f64_mul_res_subnormal+0x2e>
80005248:	f8 08 11 20 	rsub	r8,r12,32
8000524c:	0e 46       	or	r6,r7
8000524e:	ee 0c 0a 47 	lsr	r7,r7,r12
80005252:	f4 08 09 49 	lsl	r9,r10,r8
80005256:	12 47       	or	r7,r9
80005258:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000525c:	f6 08 09 49 	lsl	r9,r11,r8
80005260:	12 4a       	or	r10,r9
80005262:	f6 0c 0a 4b 	lsr	r11,r11,r12
80005266:	c8 3b       	rjmp	8000516c <__avr32_f64_mul+0x7c>
80005268:	f8 08 11 20 	rsub	r8,r12,32
8000526c:	f9 b9 00 00 	moveq	r9,0
80005270:	c0 30       	breq	80005276 <__avr32_f64_mul_res_subnormal+0x3c>
80005272:	f6 08 09 49 	lsl	r9,r11,r8
80005276:	0e 46       	or	r6,r7
80005278:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000527c:	f4 0c 0a 4a 	lsr	r10,r10,r12
80005280:	f3 ea 10 07 	or	r7,r9,r10
80005284:	f6 0c 0a 4a 	lsr	r10,r11,r12
80005288:	30 0b       	mov	r11,0
8000528a:	c7 1b       	rjmp	8000516c <__avr32_f64_mul+0x7c>

8000528c <__avr32_f64_mul_res_zero>:
8000528c:	1c 9b       	mov	r11,lr
8000528e:	e6 1b 80 00 	andh	r11,0x8000,COH
80005292:	30 0a       	mov	r10,0
80005294:	d8 22       	popm	r4-r7,pc

80005296 <__avr32_f64_mul_res_nan>:
80005296:	3f fb       	mov	r11,-1
80005298:	3f fa       	mov	r10,-1
8000529a:	d8 22       	popm	r4-r7,pc

8000529c <__avr32_f64_mul_res_inf>:
8000529c:	f0 6b 00 00 	mov	r11,-1048576
800052a0:	ed be 00 1f 	bld	lr,0x1f
800052a4:	ef bb 00 1f 	bst	r11,0x1f
800052a8:	30 0a       	mov	r10,0
800052aa:	d8 22       	popm	r4-r7,pc

800052ac <__avr32_f64_mul_op1_zero>:
800052ac:	f7 e9 20 0b 	eor	r11,r11,r9
800052b0:	e6 1b 80 00 	andh	r11,0x8000,COH
800052b4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
800052b8:	e0 4c 07 ff 	cp.w	r12,2047
800052bc:	5e 1c       	retne	r12
800052be:	3f fa       	mov	r10,-1
800052c0:	3f fb       	mov	r11,-1
800052c2:	5e fc       	retal	r12

800052c4 <__avr32_f64_sub_from_add>:
800052c4:	ee 19 80 00 	eorh	r9,0x8000

800052c8 <__avr32_f64_sub>:
800052c8:	f7 e9 20 0c 	eor	r12,r11,r9
800052cc:	e0 86 00 ca 	brmi	80005460 <__avr32_f64_add_from_sub>
800052d0:	eb cd 40 e0 	pushm	r5-r7,lr
800052d4:	16 9c       	mov	r12,r11
800052d6:	e6 1c 80 00 	andh	r12,0x8000,COH
800052da:	bf db       	cbr	r11,0x1f
800052dc:	bf d9       	cbr	r9,0x1f
800052de:	10 3a       	cp.w	r10,r8
800052e0:	f2 0b 13 00 	cpc	r11,r9
800052e4:	c0 92       	brcc	800052f6 <__avr32_f64_sub+0x2e>
800052e6:	16 97       	mov	r7,r11
800052e8:	12 9b       	mov	r11,r9
800052ea:	0e 99       	mov	r9,r7
800052ec:	14 97       	mov	r7,r10
800052ee:	10 9a       	mov	r10,r8
800052f0:	0e 98       	mov	r8,r7
800052f2:	ee 1c 80 00 	eorh	r12,0x8000
800052f6:	f6 07 16 14 	lsr	r7,r11,0x14
800052fa:	ab 7b       	lsl	r11,0xb
800052fc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80005300:	ab 7a       	lsl	r10,0xb
80005302:	bf bb       	sbr	r11,0x1f
80005304:	f2 06 16 14 	lsr	r6,r9,0x14
80005308:	c4 40       	breq	80005390 <__avr32_f64_sub_opL_subnormal>
8000530a:	ab 79       	lsl	r9,0xb
8000530c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80005310:	ab 78       	lsl	r8,0xb
80005312:	bf b9       	sbr	r9,0x1f

80005314 <__avr32_f64_sub_opL_subnormal_done>:
80005314:	e0 47 07 ff 	cp.w	r7,2047
80005318:	c4 f0       	breq	800053b6 <__avr32_f64_sub_opH_nan_or_inf>
8000531a:	0e 26       	rsub	r6,r7
8000531c:	c1 20       	breq	80005340 <__avr32_f64_sub_shift_done>
8000531e:	ec 05 11 20 	rsub	r5,r6,32
80005322:	e0 46 00 20 	cp.w	r6,32
80005326:	c7 c2       	brcc	8000541e <__avr32_f64_sub_longshift>
80005328:	f0 05 09 4e 	lsl	lr,r8,r5
8000532c:	f2 05 09 45 	lsl	r5,r9,r5
80005330:	f0 06 0a 48 	lsr	r8,r8,r6
80005334:	f2 06 0a 49 	lsr	r9,r9,r6
80005338:	0a 48       	or	r8,r5
8000533a:	58 0e       	cp.w	lr,0
8000533c:	5f 1e       	srne	lr
8000533e:	1c 48       	or	r8,lr

80005340 <__avr32_f64_sub_shift_done>:
80005340:	10 1a       	sub	r10,r8
80005342:	f6 09 01 4b 	sbc	r11,r11,r9
80005346:	f6 06 12 00 	clz	r6,r11
8000534a:	c0 e0       	breq	80005366 <__avr32_f64_sub_longnormalize_done>
8000534c:	c7 83       	brcs	8000543c <__avr32_f64_sub_longnormalize>
8000534e:	ec 0e 11 20 	rsub	lr,r6,32
80005352:	f6 06 09 4b 	lsl	r11,r11,r6
80005356:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000535a:	1c 4b       	or	r11,lr
8000535c:	f4 06 09 4a 	lsl	r10,r10,r6
80005360:	0c 17       	sub	r7,r6
80005362:	e0 8a 00 39 	brle	800053d4 <__avr32_f64_sub_subnormal_result>

80005366 <__avr32_f64_sub_longnormalize_done>:
80005366:	f4 09 15 15 	lsl	r9,r10,0x15
8000536a:	ab 9a       	lsr	r10,0xb
8000536c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80005370:	ab 9b       	lsr	r11,0xb
80005372:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80005376:	18 4b       	or	r11,r12

80005378 <__avr32_f64_sub_round>:
80005378:	fc 17 80 00 	movh	r7,0x8000
8000537c:	ed ba 00 00 	bld	r10,0x0
80005380:	f7 b7 01 ff 	subne	r7,-1
80005384:	0e 39       	cp.w	r9,r7
80005386:	5f 29       	srhs	r9
80005388:	12 0a       	add	r10,r9
8000538a:	5c 0b       	acr	r11
8000538c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80005390 <__avr32_f64_sub_opL_subnormal>:
80005390:	ab 79       	lsl	r9,0xb
80005392:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80005396:	ab 78       	lsl	r8,0xb
80005398:	f3 e8 10 0e 	or	lr,r9,r8
8000539c:	f9 b6 01 01 	movne	r6,1
800053a0:	ee 0e 11 00 	rsub	lr,r7,0
800053a4:	f9 b7 00 01 	moveq	r7,1
800053a8:	ef bb 00 1f 	bst	r11,0x1f
800053ac:	f7 ea 10 0e 	or	lr,r11,r10
800053b0:	f9 b7 00 00 	moveq	r7,0
800053b4:	cb 0b       	rjmp	80005314 <__avr32_f64_sub_opL_subnormal_done>

800053b6 <__avr32_f64_sub_opH_nan_or_inf>:
800053b6:	bf db       	cbr	r11,0x1f
800053b8:	f7 ea 10 0e 	or	lr,r11,r10
800053bc:	c0 81       	brne	800053cc <__avr32_f64_sub_return_nan>
800053be:	e0 46 07 ff 	cp.w	r6,2047
800053c2:	c0 50       	breq	800053cc <__avr32_f64_sub_return_nan>
800053c4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
800053c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800053cc <__avr32_f64_sub_return_nan>:
800053cc:	3f fa       	mov	r10,-1
800053ce:	3f fb       	mov	r11,-1
800053d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800053d4 <__avr32_f64_sub_subnormal_result>:
800053d4:	5c 37       	neg	r7
800053d6:	2f f7       	sub	r7,-1
800053d8:	f1 b7 04 c0 	satu	r7,0x6
800053dc:	e0 47 00 20 	cp.w	r7,32
800053e0:	c1 14       	brge	80005402 <__avr32_f64_sub_subnormal_result+0x2e>
800053e2:	ee 08 11 20 	rsub	r8,r7,32
800053e6:	f4 08 09 49 	lsl	r9,r10,r8
800053ea:	5f 16       	srne	r6
800053ec:	f4 07 0a 4a 	lsr	r10,r10,r7
800053f0:	0c 4a       	or	r10,r6
800053f2:	f6 08 09 49 	lsl	r9,r11,r8
800053f6:	f5 e9 10 0a 	or	r10,r10,r9
800053fa:	f4 07 0a 4b 	lsr	r11,r10,r7
800053fe:	30 07       	mov	r7,0
80005400:	cb 3b       	rjmp	80005366 <__avr32_f64_sub_longnormalize_done>
80005402:	ee 08 11 40 	rsub	r8,r7,64
80005406:	f6 08 09 49 	lsl	r9,r11,r8
8000540a:	14 49       	or	r9,r10
8000540c:	5f 16       	srne	r6
8000540e:	f6 07 0a 4a 	lsr	r10,r11,r7
80005412:	0c 4a       	or	r10,r6
80005414:	30 0b       	mov	r11,0
80005416:	30 07       	mov	r7,0
80005418:	ca 7b       	rjmp	80005366 <__avr32_f64_sub_longnormalize_done>
8000541a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000541e <__avr32_f64_sub_longshift>:
8000541e:	f1 b6 04 c0 	satu	r6,0x6
80005422:	f0 0e 17 00 	moveq	lr,r8
80005426:	c0 40       	breq	8000542e <__avr32_f64_sub_longshift+0x10>
80005428:	f2 05 09 4e 	lsl	lr,r9,r5
8000542c:	10 4e       	or	lr,r8
8000542e:	f2 06 0a 48 	lsr	r8,r9,r6
80005432:	30 09       	mov	r9,0
80005434:	58 0e       	cp.w	lr,0
80005436:	5f 1e       	srne	lr
80005438:	1c 48       	or	r8,lr
8000543a:	c8 3b       	rjmp	80005340 <__avr32_f64_sub_shift_done>

8000543c <__avr32_f64_sub_longnormalize>:
8000543c:	f4 06 12 00 	clz	r6,r10
80005440:	f9 b7 03 00 	movlo	r7,0
80005444:	f9 b6 03 00 	movlo	r6,0
80005448:	f9 bc 03 00 	movlo	r12,0
8000544c:	f7 b6 02 e0 	subhs	r6,-32
80005450:	f4 06 09 4b 	lsl	r11,r10,r6
80005454:	30 0a       	mov	r10,0
80005456:	0c 17       	sub	r7,r6
80005458:	fe 9a ff be 	brle	800053d4 <__avr32_f64_sub_subnormal_result>
8000545c:	c8 5b       	rjmp	80005366 <__avr32_f64_sub_longnormalize_done>
8000545e:	d7 03       	nop

80005460 <__avr32_f64_add_from_sub>:
80005460:	ee 19 80 00 	eorh	r9,0x8000

80005464 <__avr32_f64_add>:
80005464:	f7 e9 20 0c 	eor	r12,r11,r9
80005468:	fe 96 ff 2e 	brmi	800052c4 <__avr32_f64_sub_from_add>
8000546c:	eb cd 40 e0 	pushm	r5-r7,lr
80005470:	16 9c       	mov	r12,r11
80005472:	e6 1c 80 00 	andh	r12,0x8000,COH
80005476:	bf db       	cbr	r11,0x1f
80005478:	bf d9       	cbr	r9,0x1f
8000547a:	12 3b       	cp.w	r11,r9
8000547c:	c0 72       	brcc	8000548a <__avr32_f64_add+0x26>
8000547e:	16 97       	mov	r7,r11
80005480:	12 9b       	mov	r11,r9
80005482:	0e 99       	mov	r9,r7
80005484:	14 97       	mov	r7,r10
80005486:	10 9a       	mov	r10,r8
80005488:	0e 98       	mov	r8,r7
8000548a:	30 0e       	mov	lr,0
8000548c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80005490:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80005494:	b5 ab       	sbr	r11,0x14
80005496:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000549a:	c6 20       	breq	8000555e <__avr32_f64_add_op2_subnormal>
8000549c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
800054a0:	b5 a9       	sbr	r9,0x14
800054a2:	e0 47 07 ff 	cp.w	r7,2047
800054a6:	c2 80       	breq	800054f6 <__avr32_f64_add_opH_nan_or_inf>
800054a8:	0e 26       	rsub	r6,r7
800054aa:	c1 20       	breq	800054ce <__avr32_f64_add_shift_done>
800054ac:	e0 46 00 36 	cp.w	r6,54
800054b0:	c1 52       	brcc	800054da <__avr32_f64_add_res_of_done>
800054b2:	ec 05 11 20 	rsub	r5,r6,32
800054b6:	e0 46 00 20 	cp.w	r6,32
800054ba:	c3 52       	brcc	80005524 <__avr32_f64_add_longshift>
800054bc:	f0 05 09 4e 	lsl	lr,r8,r5
800054c0:	f2 05 09 45 	lsl	r5,r9,r5
800054c4:	f0 06 0a 48 	lsr	r8,r8,r6
800054c8:	f2 06 0a 49 	lsr	r9,r9,r6
800054cc:	0a 48       	or	r8,r5

800054ce <__avr32_f64_add_shift_done>:
800054ce:	10 0a       	add	r10,r8
800054d0:	f6 09 00 4b 	adc	r11,r11,r9
800054d4:	ed bb 00 15 	bld	r11,0x15
800054d8:	c3 40       	breq	80005540 <__avr32_f64_add_res_of>

800054da <__avr32_f64_add_res_of_done>:
800054da:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800054de:	18 4b       	or	r11,r12

800054e0 <__avr32_f64_add_round>:
800054e0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
800054e4:	18 4e       	or	lr,r12
800054e6:	ee 1e 80 00 	eorh	lr,0x8000
800054ea:	f1 be 04 20 	satu	lr,0x1
800054ee:	1c 0a       	add	r10,lr
800054f0:	5c 0b       	acr	r11
800054f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800054f6 <__avr32_f64_add_opH_nan_or_inf>:
800054f6:	b5 cb       	cbr	r11,0x14
800054f8:	f7 ea 10 0e 	or	lr,r11,r10
800054fc:	c1 01       	brne	8000551c <__avr32_f64_add_return_nan>
800054fe:	e0 46 07 ff 	cp.w	r6,2047
80005502:	c0 30       	breq	80005508 <__avr32_f64_add_opL_nan_or_inf>
80005504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80005508 <__avr32_f64_add_opL_nan_or_inf>:
80005508:	b5 c9       	cbr	r9,0x14
8000550a:	f3 e8 10 0e 	or	lr,r9,r8
8000550e:	c0 71       	brne	8000551c <__avr32_f64_add_return_nan>
80005510:	30 0a       	mov	r10,0
80005512:	fc 1b 7f f0 	movh	r11,0x7ff0
80005516:	18 4b       	or	r11,r12
80005518:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000551c <__avr32_f64_add_return_nan>:
8000551c:	3f fa       	mov	r10,-1
8000551e:	3f fb       	mov	r11,-1
80005520:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80005524 <__avr32_f64_add_longshift>:
80005524:	f1 b6 04 c0 	satu	r6,0x6
80005528:	f0 0e 17 00 	moveq	lr,r8
8000552c:	c0 60       	breq	80005538 <__avr32_f64_add_longshift+0x14>
8000552e:	f2 05 09 4e 	lsl	lr,r9,r5
80005532:	58 08       	cp.w	r8,0
80005534:	5f 18       	srne	r8
80005536:	10 4e       	or	lr,r8
80005538:	f2 06 0a 48 	lsr	r8,r9,r6
8000553c:	30 09       	mov	r9,0
8000553e:	cc 8b       	rjmp	800054ce <__avr32_f64_add_shift_done>

80005540 <__avr32_f64_add_res_of>:
80005540:	fd ee 10 1e 	or	lr,lr,lr<<0x1
80005544:	a1 9b       	lsr	r11,0x1
80005546:	5d 0a       	ror	r10
80005548:	5d 0e       	ror	lr
8000554a:	2f f7       	sub	r7,-1
8000554c:	e0 47 07 ff 	cp.w	r7,2047
80005550:	f9 ba 00 00 	moveq	r10,0
80005554:	f9 bb 00 00 	moveq	r11,0
80005558:	f9 be 00 00 	moveq	lr,0
8000555c:	cb fb       	rjmp	800054da <__avr32_f64_add_res_of_done>

8000555e <__avr32_f64_add_op2_subnormal>:
8000555e:	30 16       	mov	r6,1
80005560:	58 07       	cp.w	r7,0
80005562:	ca 01       	brne	800054a2 <__avr32_f64_add+0x3e>
80005564:	b5 cb       	cbr	r11,0x14
80005566:	10 0a       	add	r10,r8
80005568:	f6 09 00 4b 	adc	r11,r11,r9
8000556c:	18 4b       	or	r11,r12
8000556e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005572:	d7 03       	nop

80005574 <__avr32_u32_to_f64>:
80005574:	f8 cb 00 00 	sub	r11,r12,0
80005578:	30 0c       	mov	r12,0
8000557a:	c0 38       	rjmp	80005580 <__avr32_s32_to_f64+0x4>

8000557c <__avr32_s32_to_f64>:
8000557c:	18 9b       	mov	r11,r12
8000557e:	5c 4b       	abs	r11
80005580:	30 0a       	mov	r10,0
80005582:	5e 0b       	reteq	r11
80005584:	d4 01       	pushm	lr
80005586:	e0 69 04 1e 	mov	r9,1054
8000558a:	f6 08 12 00 	clz	r8,r11
8000558e:	c1 70       	breq	800055bc <__avr32_s32_to_f64+0x40>
80005590:	c0 c3       	brcs	800055a8 <__avr32_s32_to_f64+0x2c>
80005592:	f0 0e 11 20 	rsub	lr,r8,32
80005596:	f6 08 09 4b 	lsl	r11,r11,r8
8000559a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000559e:	1c 4b       	or	r11,lr
800055a0:	f4 08 09 4a 	lsl	r10,r10,r8
800055a4:	10 19       	sub	r9,r8
800055a6:	c0 b8       	rjmp	800055bc <__avr32_s32_to_f64+0x40>
800055a8:	f4 08 12 00 	clz	r8,r10
800055ac:	f9 b8 03 00 	movlo	r8,0
800055b0:	f7 b8 02 e0 	subhs	r8,-32
800055b4:	f4 08 09 4b 	lsl	r11,r10,r8
800055b8:	30 0a       	mov	r10,0
800055ba:	10 19       	sub	r9,r8
800055bc:	58 09       	cp.w	r9,0
800055be:	e0 89 00 30 	brgt	8000561e <__avr32_s32_to_f64+0xa2>
800055c2:	5c 39       	neg	r9
800055c4:	2f f9       	sub	r9,-1
800055c6:	e0 49 00 36 	cp.w	r9,54
800055ca:	c0 43       	brcs	800055d2 <__avr32_s32_to_f64+0x56>
800055cc:	30 0b       	mov	r11,0
800055ce:	30 0a       	mov	r10,0
800055d0:	c2 68       	rjmp	8000561c <__avr32_s32_to_f64+0xa0>
800055d2:	2f 69       	sub	r9,-10
800055d4:	f2 08 11 20 	rsub	r8,r9,32
800055d8:	e0 49 00 20 	cp.w	r9,32
800055dc:	c0 b2       	brcc	800055f2 <__avr32_s32_to_f64+0x76>
800055de:	f4 08 09 4e 	lsl	lr,r10,r8
800055e2:	f6 08 09 48 	lsl	r8,r11,r8
800055e6:	f4 09 0a 4a 	lsr	r10,r10,r9
800055ea:	f6 09 0a 4b 	lsr	r11,r11,r9
800055ee:	10 4b       	or	r11,r8
800055f0:	c0 88       	rjmp	80005600 <__avr32_s32_to_f64+0x84>
800055f2:	f6 08 09 4e 	lsl	lr,r11,r8
800055f6:	14 4e       	or	lr,r10
800055f8:	16 9a       	mov	r10,r11
800055fa:	30 0b       	mov	r11,0
800055fc:	f4 09 0a 4a 	lsr	r10,r10,r9
80005600:	ed ba 00 00 	bld	r10,0x0
80005604:	c0 92       	brcc	80005616 <__avr32_s32_to_f64+0x9a>
80005606:	1c 7e       	tst	lr,lr
80005608:	c0 41       	brne	80005610 <__avr32_s32_to_f64+0x94>
8000560a:	ed ba 00 01 	bld	r10,0x1
8000560e:	c0 42       	brcc	80005616 <__avr32_s32_to_f64+0x9a>
80005610:	2f fa       	sub	r10,-1
80005612:	f7 bb 02 ff 	subhs	r11,-1
80005616:	5c fc       	rol	r12
80005618:	5d 0b       	ror	r11
8000561a:	5d 0a       	ror	r10
8000561c:	d8 02       	popm	pc
8000561e:	e0 68 03 ff 	mov	r8,1023
80005622:	ed ba 00 0b 	bld	r10,0xb
80005626:	f7 b8 00 ff 	subeq	r8,-1
8000562a:	10 0a       	add	r10,r8
8000562c:	5c 0b       	acr	r11
8000562e:	f7 b9 03 fe 	sublo	r9,-2
80005632:	e0 49 07 ff 	cp.w	r9,2047
80005636:	c0 55       	brlt	80005640 <__avr32_s32_to_f64+0xc4>
80005638:	30 0a       	mov	r10,0
8000563a:	fc 1b ff e0 	movh	r11,0xffe0
8000563e:	c0 c8       	rjmp	80005656 <__floatsidf_return_op1>
80005640:	ed bb 00 1f 	bld	r11,0x1f
80005644:	f7 b9 01 01 	subne	r9,1
80005648:	ab 9a       	lsr	r10,0xb
8000564a:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000564e:	a1 7b       	lsl	r11,0x1
80005650:	ab 9b       	lsr	r11,0xb
80005652:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80005656 <__floatsidf_return_op1>:
80005656:	a1 7c       	lsl	r12,0x1
80005658:	5d 0b       	ror	r11
8000565a:	d8 02       	popm	pc

8000565c <__avr32_f64_cmp_lt>:
8000565c:	1a de       	st.w	--sp,lr
8000565e:	1a d7       	st.w	--sp,r7
80005660:	a1 7b       	lsl	r11,0x1
80005662:	5f 3c       	srlo	r12
80005664:	a1 79       	lsl	r9,0x1
80005666:	5f 37       	srlo	r7
80005668:	5c fc       	rol	r12
8000566a:	fc 1e ff e0 	movh	lr,0xffe0
8000566e:	58 0a       	cp.w	r10,0
80005670:	fc 0b 13 00 	cpc	r11,lr
80005674:	e0 8b 00 1d 	brhi	800056ae <__avr32_f64_cmp_lt+0x52>
80005678:	58 08       	cp.w	r8,0
8000567a:	fc 09 13 00 	cpc	r9,lr
8000567e:	e0 8b 00 18 	brhi	800056ae <__avr32_f64_cmp_lt+0x52>
80005682:	58 0b       	cp.w	r11,0
80005684:	f5 ba 00 00 	subfeq	r10,0
80005688:	c1 50       	breq	800056b2 <__avr32_f64_cmp_lt+0x56>
8000568a:	1b 07       	ld.w	r7,sp++
8000568c:	1b 0e       	ld.w	lr,sp++
8000568e:	58 3c       	cp.w	r12,3
80005690:	c0 a0       	breq	800056a4 <__avr32_f64_cmp_lt+0x48>
80005692:	58 1c       	cp.w	r12,1
80005694:	c0 33       	brcs	8000569a <__avr32_f64_cmp_lt+0x3e>
80005696:	5e 0d       	reteq	0
80005698:	5e 1f       	retne	1
8000569a:	10 3a       	cp.w	r10,r8
8000569c:	f2 0b 13 00 	cpc	r11,r9
800056a0:	5e 2d       	reths	0
800056a2:	5e 3f       	retlo	1
800056a4:	14 38       	cp.w	r8,r10
800056a6:	f6 09 13 00 	cpc	r9,r11
800056aa:	5e 2d       	reths	0
800056ac:	5e 3f       	retlo	1
800056ae:	1b 07       	ld.w	r7,sp++
800056b0:	d8 0a       	popm	pc,r12=0
800056b2:	58 17       	cp.w	r7,1
800056b4:	5f 1c       	srne	r12
800056b6:	58 09       	cp.w	r9,0
800056b8:	f5 b8 00 00 	subfeq	r8,0
800056bc:	1b 07       	ld.w	r7,sp++
800056be:	1b 0e       	ld.w	lr,sp++
800056c0:	5e 0d       	reteq	0
800056c2:	5e fc       	retal	r12

800056c4 <__avr32_f64_div>:
800056c4:	eb cd 40 ff 	pushm	r0-r7,lr
800056c8:	f7 e9 20 0e 	eor	lr,r11,r9
800056cc:	f6 07 16 14 	lsr	r7,r11,0x14
800056d0:	a9 7b       	lsl	r11,0x9
800056d2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
800056d6:	a9 7a       	lsl	r10,0x9
800056d8:	bd bb       	sbr	r11,0x1d
800056da:	e4 1b 3f ff 	andh	r11,0x3fff
800056de:	ab d7       	cbr	r7,0xb
800056e0:	e0 80 00 cc 	breq	80005878 <__avr32_f64_div_round_subnormal+0x54>
800056e4:	e0 47 07 ff 	cp.w	r7,2047
800056e8:	e0 84 00 b5 	brge	80005852 <__avr32_f64_div_round_subnormal+0x2e>
800056ec:	f2 06 16 14 	lsr	r6,r9,0x14
800056f0:	a9 79       	lsl	r9,0x9
800056f2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800056f6:	a9 78       	lsl	r8,0x9
800056f8:	bd b9       	sbr	r9,0x1d
800056fa:	e4 19 3f ff 	andh	r9,0x3fff
800056fe:	ab d6       	cbr	r6,0xb
80005700:	e0 80 00 e2 	breq	800058c4 <__avr32_f64_div_round_subnormal+0xa0>
80005704:	e0 46 07 ff 	cp.w	r6,2047
80005708:	e0 84 00 b2 	brge	8000586c <__avr32_f64_div_round_subnormal+0x48>
8000570c:	0c 17       	sub	r7,r6
8000570e:	fe 37 fc 01 	sub	r7,-1023
80005712:	fc 1c 80 00 	movh	r12,0x8000
80005716:	f8 03 16 01 	lsr	r3,r12,0x1
8000571a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000571e:	5c d4       	com	r4
80005720:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
80005724:	e6 09 06 44 	mulu.d	r4,r3,r9
80005728:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000572c:	e6 05 06 44 	mulu.d	r4,r3,r5
80005730:	ea 03 15 02 	lsl	r3,r5,0x2
80005734:	e6 09 06 44 	mulu.d	r4,r3,r9
80005738:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000573c:	e6 05 06 44 	mulu.d	r4,r3,r5
80005740:	ea 03 15 02 	lsl	r3,r5,0x2
80005744:	e6 09 06 44 	mulu.d	r4,r3,r9
80005748:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000574c:	e6 05 06 44 	mulu.d	r4,r3,r5
80005750:	ea 03 15 02 	lsl	r3,r5,0x2
80005754:	e6 08 06 40 	mulu.d	r0,r3,r8
80005758:	e4 09 07 40 	macu.d	r0,r2,r9
8000575c:	e6 09 06 44 	mulu.d	r4,r3,r9
80005760:	02 04       	add	r4,r1
80005762:	5c 05       	acr	r5
80005764:	a3 65       	lsl	r5,0x2
80005766:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000576a:	a3 64       	lsl	r4,0x2
8000576c:	5c 34       	neg	r4
8000576e:	f8 05 01 45 	sbc	r5,r12,r5
80005772:	e6 04 06 40 	mulu.d	r0,r3,r4
80005776:	e4 05 07 40 	macu.d	r0,r2,r5
8000577a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000577e:	02 04       	add	r4,r1
80005780:	5c 05       	acr	r5
80005782:	ea 03 15 02 	lsl	r3,r5,0x2
80005786:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000578a:	e8 02 15 02 	lsl	r2,r4,0x2
8000578e:	e6 08 06 40 	mulu.d	r0,r3,r8
80005792:	e4 09 07 40 	macu.d	r0,r2,r9
80005796:	e6 09 06 44 	mulu.d	r4,r3,r9
8000579a:	02 04       	add	r4,r1
8000579c:	5c 05       	acr	r5
8000579e:	a3 65       	lsl	r5,0x2
800057a0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
800057a4:	a3 64       	lsl	r4,0x2
800057a6:	5c 34       	neg	r4
800057a8:	f8 05 01 45 	sbc	r5,r12,r5
800057ac:	e6 04 06 40 	mulu.d	r0,r3,r4
800057b0:	e4 05 07 40 	macu.d	r0,r2,r5
800057b4:	e6 05 06 44 	mulu.d	r4,r3,r5
800057b8:	02 04       	add	r4,r1
800057ba:	5c 05       	acr	r5
800057bc:	ea 03 15 02 	lsl	r3,r5,0x2
800057c0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
800057c4:	e8 02 15 02 	lsl	r2,r4,0x2
800057c8:	e6 0a 06 40 	mulu.d	r0,r3,r10
800057cc:	e4 0b 07 40 	macu.d	r0,r2,r11
800057d0:	e6 0b 06 42 	mulu.d	r2,r3,r11
800057d4:	02 02       	add	r2,r1
800057d6:	5c 03       	acr	r3
800057d8:	ed b3 00 1c 	bld	r3,0x1c
800057dc:	c0 90       	breq	800057ee <__avr32_f64_div+0x12a>
800057de:	a1 72       	lsl	r2,0x1
800057e0:	5c f3       	rol	r3
800057e2:	20 17       	sub	r7,1
800057e4:	a3 9a       	lsr	r10,0x3
800057e6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800057ea:	a3 9b       	lsr	r11,0x3
800057ec:	c0 58       	rjmp	800057f6 <__avr32_f64_div+0x132>
800057ee:	a5 8a       	lsr	r10,0x4
800057f0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800057f4:	a5 8b       	lsr	r11,0x4
800057f6:	58 07       	cp.w	r7,0
800057f8:	e0 8a 00 8b 	brle	8000590e <__avr32_f64_div_res_subnormal>
800057fc:	e0 12 ff 00 	andl	r2,0xff00
80005800:	e8 12 00 80 	orl	r2,0x80
80005804:	e6 08 06 40 	mulu.d	r0,r3,r8
80005808:	e4 09 07 40 	macu.d	r0,r2,r9
8000580c:	e4 08 06 44 	mulu.d	r4,r2,r8
80005810:	e6 09 06 48 	mulu.d	r8,r3,r9
80005814:	00 05       	add	r5,r0
80005816:	f0 01 00 48 	adc	r8,r8,r1
8000581a:	5c 09       	acr	r9
8000581c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80005820:	58 04       	cp.w	r4,0
80005822:	5c 25       	cpc	r5

80005824 <__avr32_f64_div_round_subnormal>:
80005824:	f4 08 13 00 	cpc	r8,r10
80005828:	f6 09 13 00 	cpc	r9,r11
8000582c:	5f 36       	srlo	r6
8000582e:	f8 06 17 00 	moveq	r6,r12
80005832:	e4 0a 16 08 	lsr	r10,r2,0x8
80005836:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000583a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000583e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80005842:	ed be 00 1f 	bld	lr,0x1f
80005846:	ef bb 00 1f 	bst	r11,0x1f
8000584a:	0c 0a       	add	r10,r6
8000584c:	5c 0b       	acr	r11
8000584e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80005852:	e4 1b 00 0f 	andh	r11,0xf
80005856:	14 4b       	or	r11,r10
80005858:	e0 81 00 a7 	brne	800059a6 <__avr32_f64_div_res_subnormal+0x98>
8000585c:	f2 06 16 14 	lsr	r6,r9,0x14
80005860:	ab d6       	cbr	r6,0xb
80005862:	e0 46 07 ff 	cp.w	r6,2047
80005866:	e0 81 00 a4 	brne	800059ae <__avr32_f64_div_res_subnormal+0xa0>
8000586a:	c9 e8       	rjmp	800059a6 <__avr32_f64_div_res_subnormal+0x98>
8000586c:	e4 19 00 0f 	andh	r9,0xf
80005870:	10 49       	or	r9,r8
80005872:	e0 81 00 9a 	brne	800059a6 <__avr32_f64_div_res_subnormal+0x98>
80005876:	c9 28       	rjmp	8000599a <__avr32_f64_div_res_subnormal+0x8c>
80005878:	a3 7b       	lsl	r11,0x3
8000587a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000587e:	a3 7a       	lsl	r10,0x3
80005880:	f5 eb 10 04 	or	r4,r10,r11
80005884:	e0 80 00 a0 	breq	800059c4 <__avr32_f64_div_op1_zero>
80005888:	f6 04 12 00 	clz	r4,r11
8000588c:	c1 70       	breq	800058ba <__avr32_f64_div_round_subnormal+0x96>
8000588e:	c0 c3       	brcs	800058a6 <__avr32_f64_div_round_subnormal+0x82>
80005890:	e8 05 11 20 	rsub	r5,r4,32
80005894:	f6 04 09 4b 	lsl	r11,r11,r4
80005898:	f4 05 0a 45 	lsr	r5,r10,r5
8000589c:	0a 4b       	or	r11,r5
8000589e:	f4 04 09 4a 	lsl	r10,r10,r4
800058a2:	08 17       	sub	r7,r4
800058a4:	c0 b8       	rjmp	800058ba <__avr32_f64_div_round_subnormal+0x96>
800058a6:	f4 04 12 00 	clz	r4,r10
800058aa:	f9 b4 03 00 	movlo	r4,0
800058ae:	f7 b4 02 e0 	subhs	r4,-32
800058b2:	f4 04 09 4b 	lsl	r11,r10,r4
800058b6:	30 0a       	mov	r10,0
800058b8:	08 17       	sub	r7,r4
800058ba:	a3 8a       	lsr	r10,0x2
800058bc:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
800058c0:	a3 8b       	lsr	r11,0x2
800058c2:	c1 1b       	rjmp	800056e4 <__avr32_f64_div+0x20>
800058c4:	a3 79       	lsl	r9,0x3
800058c6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
800058ca:	a3 78       	lsl	r8,0x3
800058cc:	f3 e8 10 04 	or	r4,r9,r8
800058d0:	c6 f0       	breq	800059ae <__avr32_f64_div_res_subnormal+0xa0>
800058d2:	f2 04 12 00 	clz	r4,r9
800058d6:	c1 70       	breq	80005904 <__avr32_f64_div_round_subnormal+0xe0>
800058d8:	c0 c3       	brcs	800058f0 <__avr32_f64_div_round_subnormal+0xcc>
800058da:	e8 05 11 20 	rsub	r5,r4,32
800058de:	f2 04 09 49 	lsl	r9,r9,r4
800058e2:	f0 05 0a 45 	lsr	r5,r8,r5
800058e6:	0a 49       	or	r9,r5
800058e8:	f0 04 09 48 	lsl	r8,r8,r4
800058ec:	08 16       	sub	r6,r4
800058ee:	c0 b8       	rjmp	80005904 <__avr32_f64_div_round_subnormal+0xe0>
800058f0:	f0 04 12 00 	clz	r4,r8
800058f4:	f9 b4 03 00 	movlo	r4,0
800058f8:	f7 b4 02 e0 	subhs	r4,-32
800058fc:	f0 04 09 49 	lsl	r9,r8,r4
80005900:	30 08       	mov	r8,0
80005902:	08 16       	sub	r6,r4
80005904:	a3 88       	lsr	r8,0x2
80005906:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000590a:	a3 89       	lsr	r9,0x2
8000590c:	cf ca       	rjmp	80005704 <__avr32_f64_div+0x40>

8000590e <__avr32_f64_div_res_subnormal>:
8000590e:	5c 37       	neg	r7
80005910:	2f f7       	sub	r7,-1
80005912:	f1 b7 04 c0 	satu	r7,0x6
80005916:	e0 47 00 20 	cp.w	r7,32
8000591a:	c1 54       	brge	80005944 <__avr32_f64_div_res_subnormal+0x36>
8000591c:	ee 06 11 20 	rsub	r6,r7,32
80005920:	e4 07 0a 42 	lsr	r2,r2,r7
80005924:	e6 06 09 4c 	lsl	r12,r3,r6
80005928:	18 42       	or	r2,r12
8000592a:	e6 07 0a 43 	lsr	r3,r3,r7
8000592e:	f4 06 09 41 	lsl	r1,r10,r6
80005932:	f4 07 0a 4a 	lsr	r10,r10,r7
80005936:	f6 06 09 4c 	lsl	r12,r11,r6
8000593a:	18 4a       	or	r10,r12
8000593c:	f6 07 0a 4b 	lsr	r11,r11,r7
80005940:	30 00       	mov	r0,0
80005942:	c1 58       	rjmp	8000596c <__avr32_f64_div_res_subnormal+0x5e>
80005944:	ee 06 11 20 	rsub	r6,r7,32
80005948:	f9 b0 00 00 	moveq	r0,0
8000594c:	f9 bc 00 00 	moveq	r12,0
80005950:	c0 50       	breq	8000595a <__avr32_f64_div_res_subnormal+0x4c>
80005952:	f4 06 09 40 	lsl	r0,r10,r6
80005956:	f6 06 09 4c 	lsl	r12,r11,r6
8000595a:	e6 07 0a 42 	lsr	r2,r3,r7
8000595e:	30 03       	mov	r3,0
80005960:	f4 07 0a 41 	lsr	r1,r10,r7
80005964:	18 41       	or	r1,r12
80005966:	f6 07 0a 4a 	lsr	r10,r11,r7
8000596a:	30 0b       	mov	r11,0
8000596c:	e0 12 ff 00 	andl	r2,0xff00
80005970:	e8 12 00 80 	orl	r2,0x80
80005974:	e6 08 06 46 	mulu.d	r6,r3,r8
80005978:	e4 09 07 46 	macu.d	r6,r2,r9
8000597c:	e4 08 06 44 	mulu.d	r4,r2,r8
80005980:	e6 09 06 48 	mulu.d	r8,r3,r9
80005984:	0c 05       	add	r5,r6
80005986:	f0 07 00 48 	adc	r8,r8,r7
8000598a:	5c 09       	acr	r9
8000598c:	30 07       	mov	r7,0
8000598e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80005992:	00 34       	cp.w	r4,r0
80005994:	e2 05 13 00 	cpc	r5,r1
80005998:	c4 6b       	rjmp	80005824 <__avr32_f64_div_round_subnormal>
8000599a:	1c 9b       	mov	r11,lr
8000599c:	e6 1b 80 00 	andh	r11,0x8000,COH
800059a0:	30 0a       	mov	r10,0
800059a2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800059a6:	3f fb       	mov	r11,-1
800059a8:	30 0a       	mov	r10,0
800059aa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800059ae:	f5 eb 10 04 	or	r4,r10,r11
800059b2:	c0 90       	breq	800059c4 <__avr32_f64_div_op1_zero>
800059b4:	1c 9b       	mov	r11,lr
800059b6:	e6 1b 80 00 	andh	r11,0x8000,COH
800059ba:	ea 1b 7f f0 	orh	r11,0x7ff0
800059be:	30 0a       	mov	r10,0
800059c0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

800059c4 <__avr32_f64_div_op1_zero>:
800059c4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
800059c8:	ce f0       	breq	800059a6 <__avr32_f64_div_res_subnormal+0x98>
800059ca:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
800059ce:	e0 44 07 ff 	cp.w	r4,2047
800059d2:	ce 41       	brne	8000599a <__avr32_f64_div_res_subnormal+0x8c>
800059d4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
800059d8:	ce 10       	breq	8000599a <__avr32_f64_div_res_subnormal+0x8c>
800059da:	ce 6b       	rjmp	800059a6 <__avr32_f64_div_res_subnormal+0x98>

800059dc <atexit>:
800059dc:	d4 01       	pushm	lr
800059de:	30 09       	mov	r9,0
800059e0:	18 9b       	mov	r11,r12
800059e2:	12 9a       	mov	r10,r9
800059e4:	12 9c       	mov	r12,r9
800059e6:	e0 a0 03 2f 	rcall	80006044 <__register_exitproc>
800059ea:	d8 02       	popm	pc

800059ec <exit>:
800059ec:	d4 21       	pushm	r4-r7,lr
800059ee:	30 0b       	mov	r11,0
800059f0:	18 97       	mov	r7,r12
800059f2:	e0 a0 03 7b 	rcall	800060e8 <__call_exitprocs>
800059f6:	fe c8 f0 c6 	sub	r8,pc,-3898
800059fa:	70 0c       	ld.w	r12,r8[0x0]
800059fc:	78 a8       	ld.w	r8,r12[0x28]
800059fe:	58 08       	cp.w	r8,0
80005a00:	c0 20       	breq	80005a04 <exit+0x18>
80005a02:	5d 18       	icall	r8
80005a04:	0e 9c       	mov	r12,r7
80005a06:	e0 a0 02 fe 	rcall	80006002 <_exit>
80005a0a:	d7 03       	nop

80005a0c <free>:
80005a0c:	d4 01       	pushm	lr
80005a0e:	e0 68 01 24 	mov	r8,292
80005a12:	18 9b       	mov	r11,r12
80005a14:	70 0c       	ld.w	r12,r8[0x0]
80005a16:	e0 a0 04 1d 	rcall	80006250 <_free_r>
80005a1a:	d8 02       	popm	pc

80005a1c <malloc>:
80005a1c:	d4 01       	pushm	lr
80005a1e:	e0 68 01 24 	mov	r8,292
80005a22:	18 9b       	mov	r11,r12
80005a24:	70 0c       	ld.w	r12,r8[0x0]
80005a26:	c0 3c       	rcall	80005a2c <_malloc_r>
80005a28:	d8 02       	popm	pc
80005a2a:	d7 03       	nop

80005a2c <_malloc_r>:
80005a2c:	d4 31       	pushm	r0-r7,lr
80005a2e:	f6 c8 ff f5 	sub	r8,r11,-11
80005a32:	18 95       	mov	r5,r12
80005a34:	10 97       	mov	r7,r8
80005a36:	e0 17 ff f8 	andl	r7,0xfff8
80005a3a:	59 68       	cp.w	r8,22
80005a3c:	f9 b7 08 10 	movls	r7,16
80005a40:	16 37       	cp.w	r7,r11
80005a42:	5f 38       	srlo	r8
80005a44:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80005a48:	c0 50       	breq	80005a52 <_malloc_r+0x26>
80005a4a:	30 c8       	mov	r8,12
80005a4c:	99 38       	st.w	r12[0xc],r8
80005a4e:	e0 8f 01 f8 	bral	80005e3e <_malloc_r+0x412>
80005a52:	fe b0 f3 83 	rcall	80004158 <__malloc_lock>
80005a56:	e0 47 01 f7 	cp.w	r7,503
80005a5a:	e0 8b 00 1d 	brhi	80005a94 <_malloc_r+0x68>
80005a5e:	ee 03 16 03 	lsr	r3,r7,0x3
80005a62:	e0 68 01 28 	mov	r8,296
80005a66:	f0 03 00 38 	add	r8,r8,r3<<0x3
80005a6a:	70 36       	ld.w	r6,r8[0xc]
80005a6c:	10 36       	cp.w	r6,r8
80005a6e:	c0 61       	brne	80005a7a <_malloc_r+0x4e>
80005a70:	ec c8 ff f8 	sub	r8,r6,-8
80005a74:	70 36       	ld.w	r6,r8[0xc]
80005a76:	10 36       	cp.w	r6,r8
80005a78:	c0 c0       	breq	80005a90 <_malloc_r+0x64>
80005a7a:	6c 18       	ld.w	r8,r6[0x4]
80005a7c:	e0 18 ff fc 	andl	r8,0xfffc
80005a80:	6c 3a       	ld.w	r10,r6[0xc]
80005a82:	ec 08 00 09 	add	r9,r6,r8
80005a86:	0a 9c       	mov	r12,r5
80005a88:	6c 28       	ld.w	r8,r6[0x8]
80005a8a:	95 28       	st.w	r10[0x8],r8
80005a8c:	91 3a       	st.w	r8[0xc],r10
80005a8e:	c4 78       	rjmp	80005b1c <_malloc_r+0xf0>
80005a90:	2f e3       	sub	r3,-2
80005a92:	c4 d8       	rjmp	80005b2c <_malloc_r+0x100>
80005a94:	ee 03 16 09 	lsr	r3,r7,0x9
80005a98:	c0 41       	brne	80005aa0 <_malloc_r+0x74>
80005a9a:	ee 03 16 03 	lsr	r3,r7,0x3
80005a9e:	c2 68       	rjmp	80005aea <_malloc_r+0xbe>
80005aa0:	58 43       	cp.w	r3,4
80005aa2:	e0 8b 00 06 	brhi	80005aae <_malloc_r+0x82>
80005aa6:	ee 03 16 06 	lsr	r3,r7,0x6
80005aaa:	2c 83       	sub	r3,-56
80005aac:	c1 f8       	rjmp	80005aea <_malloc_r+0xbe>
80005aae:	59 43       	cp.w	r3,20
80005ab0:	e0 8b 00 04 	brhi	80005ab8 <_malloc_r+0x8c>
80005ab4:	2a 53       	sub	r3,-91
80005ab6:	c1 a8       	rjmp	80005aea <_malloc_r+0xbe>
80005ab8:	e0 43 00 54 	cp.w	r3,84
80005abc:	e0 8b 00 06 	brhi	80005ac8 <_malloc_r+0x9c>
80005ac0:	ee 03 16 0c 	lsr	r3,r7,0xc
80005ac4:	29 23       	sub	r3,-110
80005ac6:	c1 28       	rjmp	80005aea <_malloc_r+0xbe>
80005ac8:	e0 43 01 54 	cp.w	r3,340
80005acc:	e0 8b 00 06 	brhi	80005ad8 <_malloc_r+0xac>
80005ad0:	ee 03 16 0f 	lsr	r3,r7,0xf
80005ad4:	28 93       	sub	r3,-119
80005ad6:	c0 a8       	rjmp	80005aea <_malloc_r+0xbe>
80005ad8:	e0 43 05 54 	cp.w	r3,1364
80005adc:	e0 88 00 04 	brls	80005ae4 <_malloc_r+0xb8>
80005ae0:	37 e3       	mov	r3,126
80005ae2:	c0 48       	rjmp	80005aea <_malloc_r+0xbe>
80005ae4:	ee 03 16 12 	lsr	r3,r7,0x12
80005ae8:	28 43       	sub	r3,-124
80005aea:	e0 6a 01 28 	mov	r10,296
80005aee:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80005af2:	74 36       	ld.w	r6,r10[0xc]
80005af4:	c1 98       	rjmp	80005b26 <_malloc_r+0xfa>
80005af6:	6c 19       	ld.w	r9,r6[0x4]
80005af8:	e0 19 ff fc 	andl	r9,0xfffc
80005afc:	f2 07 01 0b 	sub	r11,r9,r7
80005b00:	58 fb       	cp.w	r11,15
80005b02:	e0 8a 00 04 	brle	80005b0a <_malloc_r+0xde>
80005b06:	20 13       	sub	r3,1
80005b08:	c1 18       	rjmp	80005b2a <_malloc_r+0xfe>
80005b0a:	6c 38       	ld.w	r8,r6[0xc]
80005b0c:	58 0b       	cp.w	r11,0
80005b0e:	c0 b5       	brlt	80005b24 <_malloc_r+0xf8>
80005b10:	6c 2a       	ld.w	r10,r6[0x8]
80005b12:	ec 09 00 09 	add	r9,r6,r9
80005b16:	0a 9c       	mov	r12,r5
80005b18:	91 2a       	st.w	r8[0x8],r10
80005b1a:	95 38       	st.w	r10[0xc],r8
80005b1c:	72 18       	ld.w	r8,r9[0x4]
80005b1e:	a1 a8       	sbr	r8,0x0
80005b20:	93 18       	st.w	r9[0x4],r8
80005b22:	cb c8       	rjmp	80005c9a <_malloc_r+0x26e>
80005b24:	10 96       	mov	r6,r8
80005b26:	14 36       	cp.w	r6,r10
80005b28:	ce 71       	brne	80005af6 <_malloc_r+0xca>
80005b2a:	2f f3       	sub	r3,-1
80005b2c:	e0 6a 01 28 	mov	r10,296
80005b30:	f4 cc ff f8 	sub	r12,r10,-8
80005b34:	78 26       	ld.w	r6,r12[0x8]
80005b36:	18 36       	cp.w	r6,r12
80005b38:	c6 c0       	breq	80005c10 <_malloc_r+0x1e4>
80005b3a:	6c 19       	ld.w	r9,r6[0x4]
80005b3c:	e0 19 ff fc 	andl	r9,0xfffc
80005b40:	f2 07 01 08 	sub	r8,r9,r7
80005b44:	58 f8       	cp.w	r8,15
80005b46:	e0 89 00 8f 	brgt	80005c64 <_malloc_r+0x238>
80005b4a:	99 3c       	st.w	r12[0xc],r12
80005b4c:	99 2c       	st.w	r12[0x8],r12
80005b4e:	58 08       	cp.w	r8,0
80005b50:	c0 55       	brlt	80005b5a <_malloc_r+0x12e>
80005b52:	ec 09 00 09 	add	r9,r6,r9
80005b56:	0a 9c       	mov	r12,r5
80005b58:	ce 2b       	rjmp	80005b1c <_malloc_r+0xf0>
80005b5a:	e0 49 01 ff 	cp.w	r9,511
80005b5e:	e0 8b 00 13 	brhi	80005b84 <_malloc_r+0x158>
80005b62:	a3 99       	lsr	r9,0x3
80005b64:	f4 09 00 38 	add	r8,r10,r9<<0x3
80005b68:	70 2b       	ld.w	r11,r8[0x8]
80005b6a:	8d 38       	st.w	r6[0xc],r8
80005b6c:	8d 2b       	st.w	r6[0x8],r11
80005b6e:	97 36       	st.w	r11[0xc],r6
80005b70:	91 26       	st.w	r8[0x8],r6
80005b72:	a3 49       	asr	r9,0x2
80005b74:	74 18       	ld.w	r8,r10[0x4]
80005b76:	30 1b       	mov	r11,1
80005b78:	f6 09 09 49 	lsl	r9,r11,r9
80005b7c:	f1 e9 10 09 	or	r9,r8,r9
80005b80:	95 19       	st.w	r10[0x4],r9
80005b82:	c4 78       	rjmp	80005c10 <_malloc_r+0x1e4>
80005b84:	f2 0a 16 09 	lsr	r10,r9,0x9
80005b88:	58 4a       	cp.w	r10,4
80005b8a:	e0 8b 00 07 	brhi	80005b98 <_malloc_r+0x16c>
80005b8e:	f2 0a 16 06 	lsr	r10,r9,0x6
80005b92:	2c 8a       	sub	r10,-56
80005b94:	c2 08       	rjmp	80005bd4 <_malloc_r+0x1a8>
80005b96:	d7 03       	nop
80005b98:	59 4a       	cp.w	r10,20
80005b9a:	e0 8b 00 04 	brhi	80005ba2 <_malloc_r+0x176>
80005b9e:	2a 5a       	sub	r10,-91
80005ba0:	c1 a8       	rjmp	80005bd4 <_malloc_r+0x1a8>
80005ba2:	e0 4a 00 54 	cp.w	r10,84
80005ba6:	e0 8b 00 06 	brhi	80005bb2 <_malloc_r+0x186>
80005baa:	f2 0a 16 0c 	lsr	r10,r9,0xc
80005bae:	29 2a       	sub	r10,-110
80005bb0:	c1 28       	rjmp	80005bd4 <_malloc_r+0x1a8>
80005bb2:	e0 4a 01 54 	cp.w	r10,340
80005bb6:	e0 8b 00 06 	brhi	80005bc2 <_malloc_r+0x196>
80005bba:	f2 0a 16 0f 	lsr	r10,r9,0xf
80005bbe:	28 9a       	sub	r10,-119
80005bc0:	c0 a8       	rjmp	80005bd4 <_malloc_r+0x1a8>
80005bc2:	e0 4a 05 54 	cp.w	r10,1364
80005bc6:	e0 88 00 04 	brls	80005bce <_malloc_r+0x1a2>
80005bca:	37 ea       	mov	r10,126
80005bcc:	c0 48       	rjmp	80005bd4 <_malloc_r+0x1a8>
80005bce:	f2 0a 16 12 	lsr	r10,r9,0x12
80005bd2:	28 4a       	sub	r10,-124
80005bd4:	e0 6b 01 28 	mov	r11,296
80005bd8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80005bdc:	68 28       	ld.w	r8,r4[0x8]
80005bde:	08 38       	cp.w	r8,r4
80005be0:	c0 e1       	brne	80005bfc <_malloc_r+0x1d0>
80005be2:	76 19       	ld.w	r9,r11[0x4]
80005be4:	a3 4a       	asr	r10,0x2
80005be6:	30 1e       	mov	lr,1
80005be8:	fc 0a 09 4a 	lsl	r10,lr,r10
80005bec:	f3 ea 10 0a 	or	r10,r9,r10
80005bf0:	10 99       	mov	r9,r8
80005bf2:	97 1a       	st.w	r11[0x4],r10
80005bf4:	c0 a8       	rjmp	80005c08 <_malloc_r+0x1dc>
80005bf6:	70 28       	ld.w	r8,r8[0x8]
80005bf8:	08 38       	cp.w	r8,r4
80005bfa:	c0 60       	breq	80005c06 <_malloc_r+0x1da>
80005bfc:	70 1a       	ld.w	r10,r8[0x4]
80005bfe:	e0 1a ff fc 	andl	r10,0xfffc
80005c02:	14 39       	cp.w	r9,r10
80005c04:	cf 93       	brcs	80005bf6 <_malloc_r+0x1ca>
80005c06:	70 39       	ld.w	r9,r8[0xc]
80005c08:	8d 39       	st.w	r6[0xc],r9
80005c0a:	8d 28       	st.w	r6[0x8],r8
80005c0c:	91 36       	st.w	r8[0xc],r6
80005c0e:	93 26       	st.w	r9[0x8],r6
80005c10:	e6 08 14 02 	asr	r8,r3,0x2
80005c14:	30 1b       	mov	r11,1
80005c16:	e0 64 01 28 	mov	r4,296
80005c1a:	f6 08 09 4b 	lsl	r11,r11,r8
80005c1e:	68 18       	ld.w	r8,r4[0x4]
80005c20:	10 3b       	cp.w	r11,r8
80005c22:	e0 8b 00 6b 	brhi	80005cf8 <_malloc_r+0x2cc>
80005c26:	f7 e8 00 09 	and	r9,r11,r8
80005c2a:	c0 b1       	brne	80005c40 <_malloc_r+0x214>
80005c2c:	e0 13 ff fc 	andl	r3,0xfffc
80005c30:	a1 7b       	lsl	r11,0x1
80005c32:	2f c3       	sub	r3,-4
80005c34:	c0 38       	rjmp	80005c3a <_malloc_r+0x20e>
80005c36:	2f c3       	sub	r3,-4
80005c38:	a1 7b       	lsl	r11,0x1
80005c3a:	f7 e8 00 09 	and	r9,r11,r8
80005c3e:	cf c0       	breq	80005c36 <_malloc_r+0x20a>
80005c40:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80005c44:	06 92       	mov	r2,r3
80005c46:	1c 91       	mov	r1,lr
80005c48:	62 36       	ld.w	r6,r1[0xc]
80005c4a:	c2 e8       	rjmp	80005ca6 <_malloc_r+0x27a>
80005c4c:	6c 1a       	ld.w	r10,r6[0x4]
80005c4e:	e0 1a ff fc 	andl	r10,0xfffc
80005c52:	f4 07 01 08 	sub	r8,r10,r7
80005c56:	58 f8       	cp.w	r8,15
80005c58:	e0 8a 00 15 	brle	80005c82 <_malloc_r+0x256>
80005c5c:	6c 3a       	ld.w	r10,r6[0xc]
80005c5e:	6c 29       	ld.w	r9,r6[0x8]
80005c60:	95 29       	st.w	r10[0x8],r9
80005c62:	93 3a       	st.w	r9[0xc],r10
80005c64:	0e 99       	mov	r9,r7
80005c66:	ec 07 00 07 	add	r7,r6,r7
80005c6a:	a1 a9       	sbr	r9,0x0
80005c6c:	99 37       	st.w	r12[0xc],r7
80005c6e:	99 27       	st.w	r12[0x8],r7
80005c70:	8d 19       	st.w	r6[0x4],r9
80005c72:	ee 08 09 08 	st.w	r7[r8],r8
80005c76:	8f 2c       	st.w	r7[0x8],r12
80005c78:	8f 3c       	st.w	r7[0xc],r12
80005c7a:	a1 a8       	sbr	r8,0x0
80005c7c:	0a 9c       	mov	r12,r5
80005c7e:	8f 18       	st.w	r7[0x4],r8
80005c80:	c0 d8       	rjmp	80005c9a <_malloc_r+0x26e>
80005c82:	6c 39       	ld.w	r9,r6[0xc]
80005c84:	58 08       	cp.w	r8,0
80005c86:	c0 f5       	brlt	80005ca4 <_malloc_r+0x278>
80005c88:	ec 0a 00 0a 	add	r10,r6,r10
80005c8c:	74 18       	ld.w	r8,r10[0x4]
80005c8e:	a1 a8       	sbr	r8,0x0
80005c90:	0a 9c       	mov	r12,r5
80005c92:	95 18       	st.w	r10[0x4],r8
80005c94:	6c 28       	ld.w	r8,r6[0x8]
80005c96:	93 28       	st.w	r9[0x8],r8
80005c98:	91 39       	st.w	r8[0xc],r9
80005c9a:	fe b0 f2 65 	rcall	80004164 <__malloc_unlock>
80005c9e:	ec cc ff f8 	sub	r12,r6,-8
80005ca2:	d8 32       	popm	r0-r7,pc
80005ca4:	12 96       	mov	r6,r9
80005ca6:	02 36       	cp.w	r6,r1
80005ca8:	cd 21       	brne	80005c4c <_malloc_r+0x220>
80005caa:	2f f2       	sub	r2,-1
80005cac:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80005cb0:	c0 30       	breq	80005cb6 <_malloc_r+0x28a>
80005cb2:	2f 81       	sub	r1,-8
80005cb4:	cc ab       	rjmp	80005c48 <_malloc_r+0x21c>
80005cb6:	1c 98       	mov	r8,lr
80005cb8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80005cbc:	c0 81       	brne	80005ccc <_malloc_r+0x2a0>
80005cbe:	68 19       	ld.w	r9,r4[0x4]
80005cc0:	f6 08 11 ff 	rsub	r8,r11,-1
80005cc4:	f3 e8 00 08 	and	r8,r9,r8
80005cc8:	89 18       	st.w	r4[0x4],r8
80005cca:	c0 78       	rjmp	80005cd8 <_malloc_r+0x2ac>
80005ccc:	f0 c9 00 08 	sub	r9,r8,8
80005cd0:	20 13       	sub	r3,1
80005cd2:	70 08       	ld.w	r8,r8[0x0]
80005cd4:	12 38       	cp.w	r8,r9
80005cd6:	cf 10       	breq	80005cb8 <_malloc_r+0x28c>
80005cd8:	a1 7b       	lsl	r11,0x1
80005cda:	68 18       	ld.w	r8,r4[0x4]
80005cdc:	10 3b       	cp.w	r11,r8
80005cde:	e0 8b 00 0d 	brhi	80005cf8 <_malloc_r+0x2cc>
80005ce2:	58 0b       	cp.w	r11,0
80005ce4:	c0 a0       	breq	80005cf8 <_malloc_r+0x2cc>
80005ce6:	04 93       	mov	r3,r2
80005ce8:	c0 38       	rjmp	80005cee <_malloc_r+0x2c2>
80005cea:	2f c3       	sub	r3,-4
80005cec:	a1 7b       	lsl	r11,0x1
80005cee:	f7 e8 00 09 	and	r9,r11,r8
80005cf2:	ca 71       	brne	80005c40 <_malloc_r+0x214>
80005cf4:	cf bb       	rjmp	80005cea <_malloc_r+0x2be>
80005cf6:	d7 03       	nop
80005cf8:	68 23       	ld.w	r3,r4[0x8]
80005cfa:	66 12       	ld.w	r2,r3[0x4]
80005cfc:	e0 12 ff fc 	andl	r2,0xfffc
80005d00:	0e 32       	cp.w	r2,r7
80005d02:	5f 39       	srlo	r9
80005d04:	e4 07 01 08 	sub	r8,r2,r7
80005d08:	58 f8       	cp.w	r8,15
80005d0a:	5f aa       	srle	r10
80005d0c:	f5 e9 10 09 	or	r9,r10,r9
80005d10:	e0 80 00 98 	breq	80005e40 <_malloc_r+0x414>
80005d14:	e0 68 09 00 	mov	r8,2304
80005d18:	70 01       	ld.w	r1,r8[0x0]
80005d1a:	e0 68 05 34 	mov	r8,1332
80005d1e:	2f 01       	sub	r1,-16
80005d20:	70 08       	ld.w	r8,r8[0x0]
80005d22:	0e 01       	add	r1,r7
80005d24:	5b f8       	cp.w	r8,-1
80005d26:	c0 40       	breq	80005d2e <_malloc_r+0x302>
80005d28:	28 11       	sub	r1,-127
80005d2a:	e0 11 ff 80 	andl	r1,0xff80
80005d2e:	02 9b       	mov	r11,r1
80005d30:	0a 9c       	mov	r12,r5
80005d32:	c4 3d       	rcall	80005fb8 <_sbrk_r>
80005d34:	18 96       	mov	r6,r12
80005d36:	5b fc       	cp.w	r12,-1
80005d38:	c7 40       	breq	80005e20 <_malloc_r+0x3f4>
80005d3a:	e6 02 00 08 	add	r8,r3,r2
80005d3e:	10 3c       	cp.w	r12,r8
80005d40:	c0 32       	brcc	80005d46 <_malloc_r+0x31a>
80005d42:	08 33       	cp.w	r3,r4
80005d44:	c6 e1       	brne	80005e20 <_malloc_r+0x3f4>
80005d46:	e0 6a 09 04 	mov	r10,2308
80005d4a:	74 09       	ld.w	r9,r10[0x0]
80005d4c:	e2 09 00 09 	add	r9,r1,r9
80005d50:	95 09       	st.w	r10[0x0],r9
80005d52:	10 36       	cp.w	r6,r8
80005d54:	c0 a1       	brne	80005d68 <_malloc_r+0x33c>
80005d56:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80005d5a:	c0 71       	brne	80005d68 <_malloc_r+0x33c>
80005d5c:	e2 02 00 02 	add	r2,r1,r2
80005d60:	68 28       	ld.w	r8,r4[0x8]
80005d62:	a1 a2       	sbr	r2,0x0
80005d64:	91 12       	st.w	r8[0x4],r2
80005d66:	c4 e8       	rjmp	80005e02 <_malloc_r+0x3d6>
80005d68:	e0 6a 05 34 	mov	r10,1332
80005d6c:	74 0b       	ld.w	r11,r10[0x0]
80005d6e:	5b fb       	cp.w	r11,-1
80005d70:	c0 31       	brne	80005d76 <_malloc_r+0x34a>
80005d72:	95 06       	st.w	r10[0x0],r6
80005d74:	c0 78       	rjmp	80005d82 <_malloc_r+0x356>
80005d76:	ec 09 00 09 	add	r9,r6,r9
80005d7a:	e0 6a 09 04 	mov	r10,2308
80005d7e:	10 19       	sub	r9,r8
80005d80:	95 09       	st.w	r10[0x0],r9
80005d82:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80005d86:	f0 09 11 08 	rsub	r9,r8,8
80005d8a:	58 08       	cp.w	r8,0
80005d8c:	f2 08 17 10 	movne	r8,r9
80005d90:	ed d8 e1 06 	addne	r6,r6,r8
80005d94:	28 08       	sub	r8,-128
80005d96:	ec 01 00 01 	add	r1,r6,r1
80005d9a:	0a 9c       	mov	r12,r5
80005d9c:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80005da0:	f0 01 01 01 	sub	r1,r8,r1
80005da4:	02 9b       	mov	r11,r1
80005da6:	c0 9d       	rcall	80005fb8 <_sbrk_r>
80005da8:	e0 68 09 04 	mov	r8,2308
80005dac:	5b fc       	cp.w	r12,-1
80005dae:	ec 0c 17 00 	moveq	r12,r6
80005db2:	f9 b1 00 00 	moveq	r1,0
80005db6:	70 09       	ld.w	r9,r8[0x0]
80005db8:	0c 1c       	sub	r12,r6
80005dba:	89 26       	st.w	r4[0x8],r6
80005dbc:	02 0c       	add	r12,r1
80005dbe:	12 01       	add	r1,r9
80005dc0:	a1 ac       	sbr	r12,0x0
80005dc2:	91 01       	st.w	r8[0x0],r1
80005dc4:	8d 1c       	st.w	r6[0x4],r12
80005dc6:	08 33       	cp.w	r3,r4
80005dc8:	c1 d0       	breq	80005e02 <_malloc_r+0x3d6>
80005dca:	58 f2       	cp.w	r2,15
80005dcc:	e0 8b 00 05 	brhi	80005dd6 <_malloc_r+0x3aa>
80005dd0:	30 18       	mov	r8,1
80005dd2:	8d 18       	st.w	r6[0x4],r8
80005dd4:	c2 68       	rjmp	80005e20 <_malloc_r+0x3f4>
80005dd6:	30 59       	mov	r9,5
80005dd8:	20 c2       	sub	r2,12
80005dda:	e0 12 ff f8 	andl	r2,0xfff8
80005dde:	e6 02 00 08 	add	r8,r3,r2
80005de2:	91 29       	st.w	r8[0x8],r9
80005de4:	91 19       	st.w	r8[0x4],r9
80005de6:	66 18       	ld.w	r8,r3[0x4]
80005de8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005dec:	e5 e8 10 08 	or	r8,r2,r8
80005df0:	87 18       	st.w	r3[0x4],r8
80005df2:	58 f2       	cp.w	r2,15
80005df4:	e0 88 00 07 	brls	80005e02 <_malloc_r+0x3d6>
80005df8:	e6 cb ff f8 	sub	r11,r3,-8
80005dfc:	0a 9c       	mov	r12,r5
80005dfe:	e0 a0 02 29 	rcall	80006250 <_free_r>
80005e02:	e0 69 08 fc 	mov	r9,2300
80005e06:	72 0a       	ld.w	r10,r9[0x0]
80005e08:	e0 68 09 04 	mov	r8,2308
80005e0c:	70 08       	ld.w	r8,r8[0x0]
80005e0e:	14 38       	cp.w	r8,r10
80005e10:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80005e14:	e0 69 08 f8 	mov	r9,2296
80005e18:	72 0a       	ld.w	r10,r9[0x0]
80005e1a:	14 38       	cp.w	r8,r10
80005e1c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80005e20:	68 28       	ld.w	r8,r4[0x8]
80005e22:	70 18       	ld.w	r8,r8[0x4]
80005e24:	e0 18 ff fc 	andl	r8,0xfffc
80005e28:	0e 38       	cp.w	r8,r7
80005e2a:	5f 39       	srlo	r9
80005e2c:	0e 18       	sub	r8,r7
80005e2e:	58 f8       	cp.w	r8,15
80005e30:	5f aa       	srle	r10
80005e32:	f5 e9 10 09 	or	r9,r10,r9
80005e36:	c0 50       	breq	80005e40 <_malloc_r+0x414>
80005e38:	0a 9c       	mov	r12,r5
80005e3a:	fe b0 f1 95 	rcall	80004164 <__malloc_unlock>
80005e3e:	d8 3a       	popm	r0-r7,pc,r12=0
80005e40:	68 26       	ld.w	r6,r4[0x8]
80005e42:	a1 a8       	sbr	r8,0x0
80005e44:	0e 99       	mov	r9,r7
80005e46:	a1 a9       	sbr	r9,0x0
80005e48:	8d 19       	st.w	r6[0x4],r9
80005e4a:	ec 07 00 07 	add	r7,r6,r7
80005e4e:	0a 9c       	mov	r12,r5
80005e50:	89 27       	st.w	r4[0x8],r7
80005e52:	8f 18       	st.w	r7[0x4],r8
80005e54:	fe b0 f1 88 	rcall	80004164 <__malloc_unlock>
80005e58:	ec cc ff f8 	sub	r12,r6,-8
80005e5c:	d8 32       	popm	r0-r7,pc
80005e5e:	d7 03       	nop

80005e60 <memcpy>:
80005e60:	58 8a       	cp.w	r10,8
80005e62:	c2 f5       	brlt	80005ec0 <memcpy+0x60>
80005e64:	f9 eb 10 09 	or	r9,r12,r11
80005e68:	e2 19 00 03 	andl	r9,0x3,COH
80005e6c:	e0 81 00 97 	brne	80005f9a <memcpy+0x13a>
80005e70:	e0 4a 00 20 	cp.w	r10,32
80005e74:	c3 b4       	brge	80005eea <memcpy+0x8a>
80005e76:	f4 08 14 02 	asr	r8,r10,0x2
80005e7a:	f0 09 11 08 	rsub	r9,r8,8
80005e7e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80005e82:	76 69       	ld.w	r9,r11[0x18]
80005e84:	99 69       	st.w	r12[0x18],r9
80005e86:	76 59       	ld.w	r9,r11[0x14]
80005e88:	99 59       	st.w	r12[0x14],r9
80005e8a:	76 49       	ld.w	r9,r11[0x10]
80005e8c:	99 49       	st.w	r12[0x10],r9
80005e8e:	76 39       	ld.w	r9,r11[0xc]
80005e90:	99 39       	st.w	r12[0xc],r9
80005e92:	76 29       	ld.w	r9,r11[0x8]
80005e94:	99 29       	st.w	r12[0x8],r9
80005e96:	76 19       	ld.w	r9,r11[0x4]
80005e98:	99 19       	st.w	r12[0x4],r9
80005e9a:	76 09       	ld.w	r9,r11[0x0]
80005e9c:	99 09       	st.w	r12[0x0],r9
80005e9e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80005ea2:	f8 08 00 28 	add	r8,r12,r8<<0x2
80005ea6:	e0 1a 00 03 	andl	r10,0x3
80005eaa:	f4 0a 11 04 	rsub	r10,r10,4
80005eae:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005eb2:	17 a9       	ld.ub	r9,r11[0x2]
80005eb4:	b0 a9       	st.b	r8[0x2],r9
80005eb6:	17 99       	ld.ub	r9,r11[0x1]
80005eb8:	b0 99       	st.b	r8[0x1],r9
80005eba:	17 89       	ld.ub	r9,r11[0x0]
80005ebc:	b0 89       	st.b	r8[0x0],r9
80005ebe:	5e fc       	retal	r12
80005ec0:	f4 0a 11 09 	rsub	r10,r10,9
80005ec4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005ec8:	17 f9       	ld.ub	r9,r11[0x7]
80005eca:	b8 f9       	st.b	r12[0x7],r9
80005ecc:	17 e9       	ld.ub	r9,r11[0x6]
80005ece:	b8 e9       	st.b	r12[0x6],r9
80005ed0:	17 d9       	ld.ub	r9,r11[0x5]
80005ed2:	b8 d9       	st.b	r12[0x5],r9
80005ed4:	17 c9       	ld.ub	r9,r11[0x4]
80005ed6:	b8 c9       	st.b	r12[0x4],r9
80005ed8:	17 b9       	ld.ub	r9,r11[0x3]
80005eda:	b8 b9       	st.b	r12[0x3],r9
80005edc:	17 a9       	ld.ub	r9,r11[0x2]
80005ede:	b8 a9       	st.b	r12[0x2],r9
80005ee0:	17 99       	ld.ub	r9,r11[0x1]
80005ee2:	b8 99       	st.b	r12[0x1],r9
80005ee4:	17 89       	ld.ub	r9,r11[0x0]
80005ee6:	b8 89       	st.b	r12[0x0],r9
80005ee8:	5e fc       	retal	r12
80005eea:	eb cd 40 c0 	pushm	r6-r7,lr
80005eee:	18 99       	mov	r9,r12
80005ef0:	22 0a       	sub	r10,32
80005ef2:	b7 07       	ld.d	r6,r11++
80005ef4:	b3 26       	st.d	r9++,r6
80005ef6:	b7 07       	ld.d	r6,r11++
80005ef8:	b3 26       	st.d	r9++,r6
80005efa:	b7 07       	ld.d	r6,r11++
80005efc:	b3 26       	st.d	r9++,r6
80005efe:	b7 07       	ld.d	r6,r11++
80005f00:	b3 26       	st.d	r9++,r6
80005f02:	22 0a       	sub	r10,32
80005f04:	cf 74       	brge	80005ef2 <memcpy+0x92>
80005f06:	2f 0a       	sub	r10,-16
80005f08:	c0 65       	brlt	80005f14 <memcpy+0xb4>
80005f0a:	b7 07       	ld.d	r6,r11++
80005f0c:	b3 26       	st.d	r9++,r6
80005f0e:	b7 07       	ld.d	r6,r11++
80005f10:	b3 26       	st.d	r9++,r6
80005f12:	21 0a       	sub	r10,16
80005f14:	5c 3a       	neg	r10
80005f16:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80005f1a:	d7 03       	nop
80005f1c:	d7 03       	nop
80005f1e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80005f22:	f3 66 00 0e 	st.b	r9[14],r6
80005f26:	f7 36 00 0d 	ld.ub	r6,r11[13]
80005f2a:	f3 66 00 0d 	st.b	r9[13],r6
80005f2e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005f32:	f3 66 00 0c 	st.b	r9[12],r6
80005f36:	f7 36 00 0b 	ld.ub	r6,r11[11]
80005f3a:	f3 66 00 0b 	st.b	r9[11],r6
80005f3e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80005f42:	f3 66 00 0a 	st.b	r9[10],r6
80005f46:	f7 36 00 09 	ld.ub	r6,r11[9]
80005f4a:	f3 66 00 09 	st.b	r9[9],r6
80005f4e:	f7 36 00 08 	ld.ub	r6,r11[8]
80005f52:	f3 66 00 08 	st.b	r9[8],r6
80005f56:	f7 36 00 07 	ld.ub	r6,r11[7]
80005f5a:	f3 66 00 07 	st.b	r9[7],r6
80005f5e:	f7 36 00 06 	ld.ub	r6,r11[6]
80005f62:	f3 66 00 06 	st.b	r9[6],r6
80005f66:	f7 36 00 05 	ld.ub	r6,r11[5]
80005f6a:	f3 66 00 05 	st.b	r9[5],r6
80005f6e:	f7 36 00 04 	ld.ub	r6,r11[4]
80005f72:	f3 66 00 04 	st.b	r9[4],r6
80005f76:	f7 36 00 03 	ld.ub	r6,r11[3]
80005f7a:	f3 66 00 03 	st.b	r9[3],r6
80005f7e:	f7 36 00 02 	ld.ub	r6,r11[2]
80005f82:	f3 66 00 02 	st.b	r9[2],r6
80005f86:	f7 36 00 01 	ld.ub	r6,r11[1]
80005f8a:	f3 66 00 01 	st.b	r9[1],r6
80005f8e:	f7 36 00 00 	ld.ub	r6,r11[0]
80005f92:	f3 66 00 00 	st.b	r9[0],r6
80005f96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f9a:	20 1a       	sub	r10,1
80005f9c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80005fa0:	f8 0a 0b 09 	st.b	r12[r10],r9
80005fa4:	cf b1       	brne	80005f9a <memcpy+0x13a>
80005fa6:	5e fc       	retal	r12

80005fa8 <memset>:
80005fa8:	18 98       	mov	r8,r12
80005faa:	c0 38       	rjmp	80005fb0 <memset+0x8>
80005fac:	10 cb       	st.b	r8++,r11
80005fae:	20 1a       	sub	r10,1
80005fb0:	58 0a       	cp.w	r10,0
80005fb2:	cf d1       	brne	80005fac <memset+0x4>
80005fb4:	5e fc       	retal	r12
80005fb6:	d7 03       	nop

80005fb8 <_sbrk_r>:
80005fb8:	d4 21       	pushm	r4-r7,lr
80005fba:	30 08       	mov	r8,0
80005fbc:	18 97       	mov	r7,r12
80005fbe:	e0 66 09 38 	mov	r6,2360
80005fc2:	16 9c       	mov	r12,r11
80005fc4:	8d 08       	st.w	r6[0x0],r8
80005fc6:	c2 3c       	rcall	8000600c <_sbrk>
80005fc8:	5b fc       	cp.w	r12,-1
80005fca:	c0 51       	brne	80005fd4 <_sbrk_r+0x1c>
80005fcc:	6c 08       	ld.w	r8,r6[0x0]
80005fce:	58 08       	cp.w	r8,0
80005fd0:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005fd4:	d8 22       	popm	r4-r7,pc
80005fd6:	d7 03       	nop

80005fd8 <strncpy>:
80005fd8:	30 08       	mov	r8,0
80005fda:	10 3a       	cp.w	r10,r8
80005fdc:	5e 0c       	reteq	r12
80005fde:	f6 08 07 09 	ld.ub	r9,r11[r8]
80005fe2:	f8 08 0b 09 	st.b	r12[r8],r9
80005fe6:	2f f8       	sub	r8,-1
80005fe8:	58 09       	cp.w	r9,0
80005fea:	cf 81       	brne	80005fda <strncpy+0x2>
80005fec:	10 3a       	cp.w	r10,r8
80005fee:	5e 0c       	reteq	r12
80005ff0:	f8 08 0b 09 	st.b	r12[r8],r9
80005ff4:	2f f8       	sub	r8,-1
80005ff6:	cf bb       	rjmp	80005fec <strncpy+0x14>

80005ff8 <_init_argv>:
80005ff8:	30 e8       	mov	r8,14
80005ffa:	d6 73       	breakpoint
80005ffc:	3f fc       	mov	r12,-1
80005ffe:	35 8b       	mov	r11,88
80006000:	5e fc       	retal	r12

80006002 <_exit>:
80006002:	30 d8       	mov	r8,13
80006004:	d6 73       	breakpoint
80006006:	3f fc       	mov	r12,-1
80006008:	35 8b       	mov	r11,88
8000600a:	c0 08       	rjmp	8000600a <_exit+0x8>

8000600c <_sbrk>:
8000600c:	d4 01       	pushm	lr
8000600e:	e0 68 09 2c 	mov	r8,2348
80006012:	70 09       	ld.w	r9,r8[0x0]
80006014:	58 09       	cp.w	r9,0
80006016:	c0 41       	brne	8000601e <_sbrk+0x12>
80006018:	e0 69 09 40 	mov	r9,2368
8000601c:	91 09       	st.w	r8[0x0],r9
8000601e:	e0 69 09 2c 	mov	r9,2348
80006022:	e0 6a f0 00 	mov	r10,61440
80006026:	72 08       	ld.w	r8,r9[0x0]
80006028:	f0 0c 00 0c 	add	r12,r8,r12
8000602c:	14 3c       	cp.w	r12,r10
8000602e:	e0 8b 00 04 	brhi	80006036 <_sbrk+0x2a>
80006032:	93 0c       	st.w	r9[0x0],r12
80006034:	c0 58       	rjmp	8000603e <_sbrk+0x32>
80006036:	cb fc       	rcall	800061b4 <__errno>
80006038:	30 c8       	mov	r8,12
8000603a:	99 08       	st.w	r12[0x0],r8
8000603c:	3f f8       	mov	r8,-1
8000603e:	10 9c       	mov	r12,r8
80006040:	d8 02       	popm	pc
80006042:	d7 03       	nop

80006044 <__register_exitproc>:
80006044:	d4 31       	pushm	r0-r7,lr
80006046:	fe c8 f7 16 	sub	r8,pc,-2282
8000604a:	70 03       	ld.w	r3,r8[0x0]
8000604c:	67 24       	ld.w	r4,r3[0x48]
8000604e:	e6 c8 ff b4 	sub	r8,r3,-76
80006052:	58 04       	cp.w	r4,0
80006054:	f0 04 17 00 	moveq	r4,r8
80006058:	e7 f4 0a 12 	st.weq	r3[0x48],r4
8000605c:	18 97       	mov	r7,r12
8000605e:	16 96       	mov	r6,r11
80006060:	14 95       	mov	r5,r10
80006062:	12 92       	mov	r2,r9
80006064:	68 18       	ld.w	r8,r4[0x4]
80006066:	59 f8       	cp.w	r8,31
80006068:	e0 8a 00 0e 	brle	80006084 <__register_exitproc+0x40>
8000606c:	e0 6c 00 8c 	mov	r12,140
80006070:	fe b0 fc d6 	rcall	80005a1c <malloc>
80006074:	18 94       	mov	r4,r12
80006076:	c3 80       	breq	800060e6 <__register_exitproc+0xa2>
80006078:	67 28       	ld.w	r8,r3[0x48]
8000607a:	99 08       	st.w	r12[0x0],r8
8000607c:	e7 4c 00 48 	st.w	r3[72],r12
80006080:	30 08       	mov	r8,0
80006082:	99 18       	st.w	r12[0x4],r8
80006084:	58 07       	cp.w	r7,0
80006086:	c2 70       	breq	800060d4 <__register_exitproc+0x90>
80006088:	e8 fc 00 88 	ld.w	r12,r4[136]
8000608c:	58 0c       	cp.w	r12,0
8000608e:	c0 d1       	brne	800060a8 <__register_exitproc+0x64>
80006090:	e0 6c 01 08 	mov	r12,264
80006094:	fe b0 fc c4 	rcall	80005a1c <malloc>
80006098:	c2 70       	breq	800060e6 <__register_exitproc+0xa2>
8000609a:	30 08       	mov	r8,0
8000609c:	e9 4c 00 88 	st.w	r4[136],r12
800060a0:	f9 48 01 04 	st.w	r12[260],r8
800060a4:	f9 48 01 00 	st.w	r12[256],r8
800060a8:	68 18       	ld.w	r8,r4[0x4]
800060aa:	f0 c9 ff e0 	sub	r9,r8,-32
800060ae:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
800060b2:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
800060b6:	30 1a       	mov	r10,1
800060b8:	f8 f9 01 00 	ld.w	r9,r12[256]
800060bc:	f4 08 09 48 	lsl	r8,r10,r8
800060c0:	10 49       	or	r9,r8
800060c2:	f9 49 01 00 	st.w	r12[256],r9
800060c6:	58 27       	cp.w	r7,2
800060c8:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
800060cc:	f3 d8 e0 38 	oreq	r8,r9,r8
800060d0:	f9 f8 0a 41 	st.weq	r12[0x104],r8
800060d4:	68 18       	ld.w	r8,r4[0x4]
800060d6:	30 0c       	mov	r12,0
800060d8:	f0 c9 ff ff 	sub	r9,r8,-1
800060dc:	2f e8       	sub	r8,-2
800060de:	89 19       	st.w	r4[0x4],r9
800060e0:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
800060e4:	d8 32       	popm	r0-r7,pc
800060e6:	dc 3a       	popm	r0-r7,pc,r12=-1

800060e8 <__call_exitprocs>:
800060e8:	d4 31       	pushm	r0-r7,lr
800060ea:	20 3d       	sub	sp,12
800060ec:	fe c8 f7 bc 	sub	r8,pc,-2116
800060f0:	50 2c       	stdsp	sp[0x8],r12
800060f2:	70 08       	ld.w	r8,r8[0x0]
800060f4:	16 91       	mov	r1,r11
800060f6:	50 08       	stdsp	sp[0x0],r8
800060f8:	2b 88       	sub	r8,-72
800060fa:	50 18       	stdsp	sp[0x4],r8
800060fc:	40 0a       	lddsp	r10,sp[0x0]
800060fe:	40 14       	lddsp	r4,sp[0x4]
80006100:	75 27       	ld.w	r7,r10[0x48]
80006102:	c5 58       	rjmp	800061ac <__call_exitprocs+0xc4>
80006104:	6e 15       	ld.w	r5,r7[0x4]
80006106:	ee f6 00 88 	ld.w	r6,r7[136]
8000610a:	ea c2 ff ff 	sub	r2,r5,-1
8000610e:	20 15       	sub	r5,1
80006110:	ee 02 00 22 	add	r2,r7,r2<<0x2
80006114:	ec 05 00 23 	add	r3,r6,r5<<0x2
80006118:	c3 58       	rjmp	80006182 <__call_exitprocs+0x9a>
8000611a:	58 01       	cp.w	r1,0
8000611c:	c0 70       	breq	8000612a <__call_exitprocs+0x42>
8000611e:	58 06       	cp.w	r6,0
80006120:	c2 e0       	breq	8000617c <__call_exitprocs+0x94>
80006122:	e6 f8 00 80 	ld.w	r8,r3[128]
80006126:	02 38       	cp.w	r8,r1
80006128:	c2 a1       	brne	8000617c <__call_exitprocs+0x94>
8000612a:	6e 19       	ld.w	r9,r7[0x4]
8000612c:	64 08       	ld.w	r8,r2[0x0]
8000612e:	20 19       	sub	r9,1
80006130:	12 35       	cp.w	r5,r9
80006132:	ef f5 0a 01 	st.weq	r7[0x4],r5
80006136:	f9 b9 01 00 	movne	r9,0
8000613a:	e5 f9 1a 00 	st.wne	r2[0x0],r9
8000613e:	58 08       	cp.w	r8,0
80006140:	c1 e0       	breq	8000617c <__call_exitprocs+0x94>
80006142:	6e 10       	ld.w	r0,r7[0x4]
80006144:	58 06       	cp.w	r6,0
80006146:	c0 90       	breq	80006158 <__call_exitprocs+0x70>
80006148:	30 1a       	mov	r10,1
8000614a:	f4 05 09 49 	lsl	r9,r10,r5
8000614e:	ec fa 01 00 	ld.w	r10,r6[256]
80006152:	f3 ea 00 0a 	and	r10,r9,r10
80006156:	c0 31       	brne	8000615c <__call_exitprocs+0x74>
80006158:	5d 18       	icall	r8
8000615a:	c0 b8       	rjmp	80006170 <__call_exitprocs+0x88>
8000615c:	ec fa 01 04 	ld.w	r10,r6[260]
80006160:	66 0b       	ld.w	r11,r3[0x0]
80006162:	14 69       	and	r9,r10
80006164:	c0 41       	brne	8000616c <__call_exitprocs+0x84>
80006166:	40 2c       	lddsp	r12,sp[0x8]
80006168:	5d 18       	icall	r8
8000616a:	c0 38       	rjmp	80006170 <__call_exitprocs+0x88>
8000616c:	16 9c       	mov	r12,r11
8000616e:	5d 18       	icall	r8
80006170:	6e 18       	ld.w	r8,r7[0x4]
80006172:	10 30       	cp.w	r0,r8
80006174:	cc 41       	brne	800060fc <__call_exitprocs+0x14>
80006176:	68 08       	ld.w	r8,r4[0x0]
80006178:	0e 38       	cp.w	r8,r7
8000617a:	cc 11       	brne	800060fc <__call_exitprocs+0x14>
8000617c:	20 15       	sub	r5,1
8000617e:	20 43       	sub	r3,4
80006180:	20 42       	sub	r2,4
80006182:	58 05       	cp.w	r5,0
80006184:	cc b4       	brge	8000611a <__call_exitprocs+0x32>
80006186:	6e 18       	ld.w	r8,r7[0x4]
80006188:	58 08       	cp.w	r8,0
8000618a:	c0 f1       	brne	800061a8 <__call_exitprocs+0xc0>
8000618c:	6e 08       	ld.w	r8,r7[0x0]
8000618e:	58 08       	cp.w	r8,0
80006190:	c0 c0       	breq	800061a8 <__call_exitprocs+0xc0>
80006192:	89 08       	st.w	r4[0x0],r8
80006194:	58 06       	cp.w	r6,0
80006196:	c0 40       	breq	8000619e <__call_exitprocs+0xb6>
80006198:	0c 9c       	mov	r12,r6
8000619a:	fe b0 fc 39 	rcall	80005a0c <free>
8000619e:	0e 9c       	mov	r12,r7
800061a0:	fe b0 fc 36 	rcall	80005a0c <free>
800061a4:	68 07       	ld.w	r7,r4[0x0]
800061a6:	c0 38       	rjmp	800061ac <__call_exitprocs+0xc4>
800061a8:	0e 94       	mov	r4,r7
800061aa:	6e 07       	ld.w	r7,r7[0x0]
800061ac:	58 07       	cp.w	r7,0
800061ae:	ca b1       	brne	80006104 <__call_exitprocs+0x1c>
800061b0:	2f dd       	sub	sp,-12
800061b2:	d8 32       	popm	r0-r7,pc

800061b4 <__errno>:
800061b4:	e0 68 01 24 	mov	r8,292
800061b8:	70 0c       	ld.w	r12,r8[0x0]
800061ba:	2f 4c       	sub	r12,-12
800061bc:	5e fc       	retal	r12
800061be:	d7 03       	nop

800061c0 <_malloc_trim_r>:
800061c0:	d4 21       	pushm	r4-r7,lr
800061c2:	16 95       	mov	r5,r11
800061c4:	18 97       	mov	r7,r12
800061c6:	fe b0 ef c9 	rcall	80004158 <__malloc_lock>
800061ca:	e0 64 01 28 	mov	r4,296
800061ce:	68 28       	ld.w	r8,r4[0x8]
800061d0:	70 16       	ld.w	r6,r8[0x4]
800061d2:	e0 16 ff fc 	andl	r6,0xfffc
800061d6:	ec c8 ff 91 	sub	r8,r6,-111
800061da:	f0 05 01 05 	sub	r5,r8,r5
800061de:	e0 15 ff 80 	andl	r5,0xff80
800061e2:	ea c5 00 80 	sub	r5,r5,128
800061e6:	e0 45 00 7f 	cp.w	r5,127
800061ea:	e0 8a 00 22 	brle	8000622e <_malloc_trim_r+0x6e>
800061ee:	30 0b       	mov	r11,0
800061f0:	0e 9c       	mov	r12,r7
800061f2:	ce 3e       	rcall	80005fb8 <_sbrk_r>
800061f4:	68 28       	ld.w	r8,r4[0x8]
800061f6:	0c 08       	add	r8,r6
800061f8:	10 3c       	cp.w	r12,r8
800061fa:	c1 a1       	brne	8000622e <_malloc_trim_r+0x6e>
800061fc:	ea 0b 11 00 	rsub	r11,r5,0
80006200:	0e 9c       	mov	r12,r7
80006202:	cd be       	rcall	80005fb8 <_sbrk_r>
80006204:	5b fc       	cp.w	r12,-1
80006206:	c1 81       	brne	80006236 <_malloc_trim_r+0x76>
80006208:	30 0b       	mov	r11,0
8000620a:	0e 9c       	mov	r12,r7
8000620c:	cd 6e       	rcall	80005fb8 <_sbrk_r>
8000620e:	68 28       	ld.w	r8,r4[0x8]
80006210:	f8 08 01 09 	sub	r9,r12,r8
80006214:	58 f9       	cp.w	r9,15
80006216:	e0 8a 00 0c 	brle	8000622e <_malloc_trim_r+0x6e>
8000621a:	a1 a9       	sbr	r9,0x0
8000621c:	91 19       	st.w	r8[0x4],r9
8000621e:	e0 68 05 34 	mov	r8,1332
80006222:	70 09       	ld.w	r9,r8[0x0]
80006224:	e0 68 09 04 	mov	r8,2308
80006228:	f8 09 01 09 	sub	r9,r12,r9
8000622c:	91 09       	st.w	r8[0x0],r9
8000622e:	0e 9c       	mov	r12,r7
80006230:	fe b0 ef 9a 	rcall	80004164 <__malloc_unlock>
80006234:	d8 2a       	popm	r4-r7,pc,r12=0
80006236:	68 28       	ld.w	r8,r4[0x8]
80006238:	0a 16       	sub	r6,r5
8000623a:	a1 a6       	sbr	r6,0x0
8000623c:	91 16       	st.w	r8[0x4],r6
8000623e:	e0 68 09 04 	mov	r8,2308
80006242:	70 09       	ld.w	r9,r8[0x0]
80006244:	0a 19       	sub	r9,r5
80006246:	0e 9c       	mov	r12,r7
80006248:	91 09       	st.w	r8[0x0],r9
8000624a:	fe b0 ef 8d 	rcall	80004164 <__malloc_unlock>
8000624e:	da 2a       	popm	r4-r7,pc,r12=1

80006250 <_free_r>:
80006250:	d4 21       	pushm	r4-r7,lr
80006252:	16 96       	mov	r6,r11
80006254:	18 97       	mov	r7,r12
80006256:	58 0b       	cp.w	r11,0
80006258:	e0 80 00 c0 	breq	800063d8 <_free_r+0x188>
8000625c:	fe b0 ef 7e 	rcall	80004158 <__malloc_lock>
80006260:	20 86       	sub	r6,8
80006262:	e0 6a 01 28 	mov	r10,296
80006266:	6c 18       	ld.w	r8,r6[0x4]
80006268:	74 2e       	ld.w	lr,r10[0x8]
8000626a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000626e:	a1 c8       	cbr	r8,0x0
80006270:	ec 08 00 09 	add	r9,r6,r8
80006274:	72 1b       	ld.w	r11,r9[0x4]
80006276:	e0 1b ff fc 	andl	r11,0xfffc
8000627a:	1c 39       	cp.w	r9,lr
8000627c:	c1 e1       	brne	800062b8 <_free_r+0x68>
8000627e:	f6 08 00 08 	add	r8,r11,r8
80006282:	58 0c       	cp.w	r12,0
80006284:	c0 81       	brne	80006294 <_free_r+0x44>
80006286:	6c 09       	ld.w	r9,r6[0x0]
80006288:	12 16       	sub	r6,r9
8000628a:	12 08       	add	r8,r9
8000628c:	6c 3b       	ld.w	r11,r6[0xc]
8000628e:	6c 29       	ld.w	r9,r6[0x8]
80006290:	97 29       	st.w	r11[0x8],r9
80006292:	93 3b       	st.w	r9[0xc],r11
80006294:	10 99       	mov	r9,r8
80006296:	95 26       	st.w	r10[0x8],r6
80006298:	a1 a9       	sbr	r9,0x0
8000629a:	8d 19       	st.w	r6[0x4],r9
8000629c:	e0 69 05 30 	mov	r9,1328
800062a0:	72 09       	ld.w	r9,r9[0x0]
800062a2:	12 38       	cp.w	r8,r9
800062a4:	c0 63       	brcs	800062b0 <_free_r+0x60>
800062a6:	e0 68 09 00 	mov	r8,2304
800062aa:	0e 9c       	mov	r12,r7
800062ac:	70 0b       	ld.w	r11,r8[0x0]
800062ae:	c8 9f       	rcall	800061c0 <_malloc_trim_r>
800062b0:	0e 9c       	mov	r12,r7
800062b2:	fe b0 ef 59 	rcall	80004164 <__malloc_unlock>
800062b6:	d8 22       	popm	r4-r7,pc
800062b8:	93 1b       	st.w	r9[0x4],r11
800062ba:	58 0c       	cp.w	r12,0
800062bc:	c0 30       	breq	800062c2 <_free_r+0x72>
800062be:	30 0c       	mov	r12,0
800062c0:	c1 08       	rjmp	800062e0 <_free_r+0x90>
800062c2:	6c 0e       	ld.w	lr,r6[0x0]
800062c4:	f4 c5 ff f8 	sub	r5,r10,-8
800062c8:	1c 16       	sub	r6,lr
800062ca:	1c 08       	add	r8,lr
800062cc:	6c 2e       	ld.w	lr,r6[0x8]
800062ce:	0a 3e       	cp.w	lr,r5
800062d0:	f9 bc 00 01 	moveq	r12,1
800062d4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800062d8:	eb fe 1a 02 	st.wne	r5[0x8],lr
800062dc:	fd f5 1a 03 	st.wne	lr[0xc],r5
800062e0:	f2 0b 00 0e 	add	lr,r9,r11
800062e4:	7c 1e       	ld.w	lr,lr[0x4]
800062e6:	ed be 00 00 	bld	lr,0x0
800062ea:	c1 40       	breq	80006312 <_free_r+0xc2>
800062ec:	16 08       	add	r8,r11
800062ee:	58 0c       	cp.w	r12,0
800062f0:	c0 d1       	brne	8000630a <_free_r+0xba>
800062f2:	e0 6e 01 28 	mov	lr,296
800062f6:	72 2b       	ld.w	r11,r9[0x8]
800062f8:	2f 8e       	sub	lr,-8
800062fa:	1c 3b       	cp.w	r11,lr
800062fc:	c0 71       	brne	8000630a <_free_r+0xba>
800062fe:	97 36       	st.w	r11[0xc],r6
80006300:	97 26       	st.w	r11[0x8],r6
80006302:	8d 2b       	st.w	r6[0x8],r11
80006304:	8d 3b       	st.w	r6[0xc],r11
80006306:	30 1c       	mov	r12,1
80006308:	c0 58       	rjmp	80006312 <_free_r+0xc2>
8000630a:	72 2b       	ld.w	r11,r9[0x8]
8000630c:	72 39       	ld.w	r9,r9[0xc]
8000630e:	93 2b       	st.w	r9[0x8],r11
80006310:	97 39       	st.w	r11[0xc],r9
80006312:	10 99       	mov	r9,r8
80006314:	ec 08 09 08 	st.w	r6[r8],r8
80006318:	a1 a9       	sbr	r9,0x0
8000631a:	8d 19       	st.w	r6[0x4],r9
8000631c:	58 0c       	cp.w	r12,0
8000631e:	c5 a1       	brne	800063d2 <_free_r+0x182>
80006320:	e0 48 01 ff 	cp.w	r8,511
80006324:	e0 8b 00 13 	brhi	8000634a <_free_r+0xfa>
80006328:	a3 98       	lsr	r8,0x3
8000632a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000632e:	72 2b       	ld.w	r11,r9[0x8]
80006330:	8d 39       	st.w	r6[0xc],r9
80006332:	8d 2b       	st.w	r6[0x8],r11
80006334:	97 36       	st.w	r11[0xc],r6
80006336:	93 26       	st.w	r9[0x8],r6
80006338:	a3 48       	asr	r8,0x2
8000633a:	74 19       	ld.w	r9,r10[0x4]
8000633c:	30 1b       	mov	r11,1
8000633e:	f6 08 09 48 	lsl	r8,r11,r8
80006342:	f3 e8 10 08 	or	r8,r9,r8
80006346:	95 18       	st.w	r10[0x4],r8
80006348:	c4 58       	rjmp	800063d2 <_free_r+0x182>
8000634a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000634e:	58 4b       	cp.w	r11,4
80006350:	e0 8b 00 06 	brhi	8000635c <_free_r+0x10c>
80006354:	f0 0b 16 06 	lsr	r11,r8,0x6
80006358:	2c 8b       	sub	r11,-56
8000635a:	c2 08       	rjmp	8000639a <_free_r+0x14a>
8000635c:	59 4b       	cp.w	r11,20
8000635e:	e0 8b 00 04 	brhi	80006366 <_free_r+0x116>
80006362:	2a 5b       	sub	r11,-91
80006364:	c1 b8       	rjmp	8000639a <_free_r+0x14a>
80006366:	e0 4b 00 54 	cp.w	r11,84
8000636a:	e0 8b 00 06 	brhi	80006376 <_free_r+0x126>
8000636e:	f0 0b 16 0c 	lsr	r11,r8,0xc
80006372:	29 2b       	sub	r11,-110
80006374:	c1 38       	rjmp	8000639a <_free_r+0x14a>
80006376:	e0 4b 01 54 	cp.w	r11,340
8000637a:	e0 8b 00 06 	brhi	80006386 <_free_r+0x136>
8000637e:	f0 0b 16 0f 	lsr	r11,r8,0xf
80006382:	28 9b       	sub	r11,-119
80006384:	c0 b8       	rjmp	8000639a <_free_r+0x14a>
80006386:	e0 4b 05 54 	cp.w	r11,1364
8000638a:	e0 88 00 05 	brls	80006394 <_free_r+0x144>
8000638e:	37 eb       	mov	r11,126
80006390:	c0 58       	rjmp	8000639a <_free_r+0x14a>
80006392:	d7 03       	nop
80006394:	f0 0b 16 12 	lsr	r11,r8,0x12
80006398:	28 4b       	sub	r11,-124
8000639a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000639e:	78 29       	ld.w	r9,r12[0x8]
800063a0:	18 39       	cp.w	r9,r12
800063a2:	c0 e1       	brne	800063be <_free_r+0x16e>
800063a4:	74 18       	ld.w	r8,r10[0x4]
800063a6:	a3 4b       	asr	r11,0x2
800063a8:	30 1c       	mov	r12,1
800063aa:	f8 0b 09 4b 	lsl	r11,r12,r11
800063ae:	f1 eb 10 0b 	or	r11,r8,r11
800063b2:	12 98       	mov	r8,r9
800063b4:	95 1b       	st.w	r10[0x4],r11
800063b6:	c0 a8       	rjmp	800063ca <_free_r+0x17a>
800063b8:	72 29       	ld.w	r9,r9[0x8]
800063ba:	18 39       	cp.w	r9,r12
800063bc:	c0 60       	breq	800063c8 <_free_r+0x178>
800063be:	72 1a       	ld.w	r10,r9[0x4]
800063c0:	e0 1a ff fc 	andl	r10,0xfffc
800063c4:	14 38       	cp.w	r8,r10
800063c6:	cf 93       	brcs	800063b8 <_free_r+0x168>
800063c8:	72 38       	ld.w	r8,r9[0xc]
800063ca:	8d 38       	st.w	r6[0xc],r8
800063cc:	8d 29       	st.w	r6[0x8],r9
800063ce:	93 36       	st.w	r9[0xc],r6
800063d0:	91 26       	st.w	r8[0x8],r6
800063d2:	0e 9c       	mov	r12,r7
800063d4:	fe b0 ee c8 	rcall	80004164 <__malloc_unlock>
800063d8:	d8 22       	popm	r4-r7,pc
800063da:	d7 03       	nop

800063dc <__do_global_ctors_aux>:
800063dc:	d4 21       	pushm	r4-r7,lr
800063de:	30 c7       	mov	r7,12
800063e0:	c0 28       	rjmp	800063e4 <__do_global_ctors_aux+0x8>
800063e2:	5d 18       	icall	r8
800063e4:	20 47       	sub	r7,4
800063e6:	6e 08       	ld.w	r8,r7[0x0]
800063e8:	5b f8       	cp.w	r8,-1
800063ea:	cf c1       	brne	800063e2 <__do_global_ctors_aux+0x6>
800063ec:	d8 22       	popm	r4-r7,pc
800063ee:	d7 03       	nop

Disassembly of section .exception:

80006400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80006400:	c0 08       	rjmp	80006400 <_evba>
	...

80006404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80006404:	c0 08       	rjmp	80006404 <_handle_TLB_Multiple_Hit>
	...

80006408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80006408:	c0 08       	rjmp	80006408 <_handle_Bus_Error_Data_Fetch>
	...

8000640c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000640c:	c0 08       	rjmp	8000640c <_handle_Bus_Error_Instruction_Fetch>
	...

80006410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80006410:	c0 08       	rjmp	80006410 <_handle_NMI>
	...

80006414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80006414:	c0 08       	rjmp	80006414 <_handle_Instruction_Address>
	...

80006418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80006418:	c0 08       	rjmp	80006418 <_handle_ITLB_Protection>
	...

8000641c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000641c:	c0 08       	rjmp	8000641c <_handle_Breakpoint>
	...

80006420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80006420:	c0 08       	rjmp	80006420 <_handle_Illegal_Opcode>
	...

80006424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80006424:	c0 08       	rjmp	80006424 <_handle_Unimplemented_Instruction>
	...

80006428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80006428:	c0 08       	rjmp	80006428 <_handle_Privilege_Violation>
	...

8000642c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000642c:	c0 08       	rjmp	8000642c <_handle_Floating_Point>
	...

80006430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80006430:	c0 08       	rjmp	80006430 <_handle_Coprocessor_Absent>
	...

80006434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80006434:	c0 08       	rjmp	80006434 <_handle_Data_Address_Read>
	...

80006438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80006438:	c0 08       	rjmp	80006438 <_handle_Data_Address_Write>
	...

8000643c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000643c:	c0 08       	rjmp	8000643c <_handle_DTLB_Protection_Read>
	...

80006440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80006440:	c0 08       	rjmp	80006440 <_handle_DTLB_Protection_Write>
	...

80006444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80006444:	c0 08       	rjmp	80006444 <_handle_DTLB_Modified>
	...

80006450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80006450:	c0 08       	rjmp	80006450 <_handle_ITLB_Miss>
	...

80006460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80006460:	c0 08       	rjmp	80006460 <_handle_DTLB_Miss_Read>
	...

80006470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80006470:	c0 08       	rjmp	80006470 <_handle_DTLB_Miss_Write>
	...

80006500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80006500:	fe cf 24 f0 	sub	pc,pc,9456

80006504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80006504:	30 0c       	mov	r12,0
80006506:	fe b0 df 4b 	rcall	8000239c <_get_interrupt_handler>
8000650a:	58 0c       	cp.w	r12,0
8000650c:	f8 0f 17 10 	movne	pc,r12
80006510:	d6 03       	rete

80006512 <_int1>:
80006512:	30 1c       	mov	r12,1
80006514:	fe b0 df 44 	rcall	8000239c <_get_interrupt_handler>
80006518:	58 0c       	cp.w	r12,0
8000651a:	f8 0f 17 10 	movne	pc,r12
8000651e:	d6 03       	rete

80006520 <_int2>:
80006520:	30 2c       	mov	r12,2
80006522:	fe b0 df 3d 	rcall	8000239c <_get_interrupt_handler>
80006526:	58 0c       	cp.w	r12,0
80006528:	f8 0f 17 10 	movne	pc,r12
8000652c:	d6 03       	rete

8000652e <_int3>:
8000652e:	30 3c       	mov	r12,3
80006530:	fe b0 df 36 	rcall	8000239c <_get_interrupt_handler>
80006534:	58 0c       	cp.w	r12,0
80006536:	f8 0f 17 10 	movne	pc,r12
8000653a:	d6 03       	rete
8000653c:	d7 03       	nop
8000653e:	d7 03       	nop
80006540:	d7 03       	nop
80006542:	d7 03       	nop
80006544:	d7 03       	nop
80006546:	d7 03       	nop
80006548:	d7 03       	nop
8000654a:	d7 03       	nop
8000654c:	d7 03       	nop
8000654e:	d7 03       	nop
80006550:	d7 03       	nop
80006552:	d7 03       	nop
80006554:	d7 03       	nop
80006556:	d7 03       	nop
80006558:	d7 03       	nop
8000655a:	d7 03       	nop
8000655c:	d7 03       	nop
8000655e:	d7 03       	nop
80006560:	d7 03       	nop
80006562:	d7 03       	nop
80006564:	d7 03       	nop
80006566:	d7 03       	nop
80006568:	d7 03       	nop
8000656a:	d7 03       	nop
8000656c:	d7 03       	nop
8000656e:	d7 03       	nop
80006570:	d7 03       	nop
80006572:	d7 03       	nop
80006574:	d7 03       	nop
80006576:	d7 03       	nop
80006578:	d7 03       	nop
8000657a:	d7 03       	nop
8000657c:	d7 03       	nop
8000657e:	d7 03       	nop
80006580:	d7 03       	nop
80006582:	d7 03       	nop
80006584:	d7 03       	nop
80006586:	d7 03       	nop
80006588:	d7 03       	nop
8000658a:	d7 03       	nop
8000658c:	d7 03       	nop
8000658e:	d7 03       	nop
80006590:	d7 03       	nop
80006592:	d7 03       	nop
80006594:	d7 03       	nop
80006596:	d7 03       	nop
80006598:	d7 03       	nop
8000659a:	d7 03       	nop
8000659c:	d7 03       	nop
8000659e:	d7 03       	nop
800065a0:	d7 03       	nop
800065a2:	d7 03       	nop
800065a4:	d7 03       	nop
800065a6:	d7 03       	nop
800065a8:	d7 03       	nop
800065aa:	d7 03       	nop
800065ac:	d7 03       	nop
800065ae:	d7 03       	nop
800065b0:	d7 03       	nop
800065b2:	d7 03       	nop
800065b4:	d7 03       	nop
800065b6:	d7 03       	nop
800065b8:	d7 03       	nop
800065ba:	d7 03       	nop
800065bc:	d7 03       	nop
800065be:	d7 03       	nop
800065c0:	d7 03       	nop
800065c2:	d7 03       	nop
800065c4:	d7 03       	nop
800065c6:	d7 03       	nop
800065c8:	d7 03       	nop
800065ca:	d7 03       	nop
800065cc:	d7 03       	nop
800065ce:	d7 03       	nop
800065d0:	d7 03       	nop
800065d2:	d7 03       	nop
800065d4:	d7 03       	nop
800065d6:	d7 03       	nop
800065d8:	d7 03       	nop
800065da:	d7 03       	nop
800065dc:	d7 03       	nop
800065de:	d7 03       	nop
800065e0:	d7 03       	nop
800065e2:	d7 03       	nop
800065e4:	d7 03       	nop
800065e6:	d7 03       	nop
800065e8:	d7 03       	nop
800065ea:	d7 03       	nop
800065ec:	d7 03       	nop
800065ee:	d7 03       	nop
800065f0:	d7 03       	nop
800065f2:	d7 03       	nop
800065f4:	d7 03       	nop
800065f6:	d7 03       	nop
800065f8:	d7 03       	nop
800065fa:	d7 03       	nop
800065fc:	d7 03       	nop
800065fe:	d7 03       	nop

Disassembly of section .fini:

80006600 <_fini>:
80006600:	eb cd 40 40 	pushm	r6,lr
80006604:	48 26       	lddpc	r6,8000660c <_fini+0xc>
80006606:	1e 26       	rsub	r6,pc
80006608:	c0 48       	rjmp	80006610 <_fini+0x10>
8000660a:	d7 03       	nop
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	65 ea       	ld.w	r10,r2[0x78]
80006610:	fe b0 dd 3c 	rcall	80002088 <__do_global_dtors_aux>
80006614:	e3 cd 80 40 	ldm	sp++,r6,pc
